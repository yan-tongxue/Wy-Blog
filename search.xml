<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10月4日博客主题更新日志</title>
    <url>/2022/10/04/10%E6%9C%884%E6%97%A5%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>10.4博客主题更新日志：<br>1.页面全局css样式修改为蓝色风格。<br>2.首页banner属性修改为video，新加入9秒循环背景视频。</p>
<p>参数如下:</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@primary</span>        :#<span class="number">25</span>ace6;</span><br><span class="line"><span class="keyword">@primary-weak</span>   :#<span class="number">267</span>bac;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">video</span></span><br><span class="line">    <span class="attr">bannerTitle:</span> <span class="string">所幸皆为美好，&lt;br&gt;所行不负年少。</span></span><br><span class="line">    <span class="attr">bannerText:</span> <span class="string">Hi</span> <span class="string">my</span> <span class="string">new</span> <span class="string">friend!</span></span><br><span class="line">    <span class="comment"># bgurl: /img/banner3.jpg</span></span><br><span class="line">    <span class="attr">bgurl:</span> <span class="string">/video/backvideo.mp4</span></span><br><span class="line">    <span class="attr">videoUrl:</span> </span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>11.3博客更新日志</title>
    <url>/2022/11/04/11-3%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>更新日志：本次博客修复了1个bug，修改social三个图标跳转路径，替换banner背景图，新增评论区功能（支持Github登录评论），新增文章打赏功能。</p>
<h3 id="修复bug"><a href="#修复bug" class="headerlink" title="修复bug"></a>修复bug</h3><p>在原来的归档页面中，下方的分页控件丢失，导致归档只能显示10篇文章，在这次的更新下，添加了丢失的分页功能，使归档页面更加完善。</p>
<p>效果图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Update-Blog-Img/img2.jpg"
                     
                >

<h3 id="修改三个图标跳转路径"><a href="#修改三个图标跳转路径" class="headerlink" title="修改三个图标跳转路径"></a>修改三个图标跳转路径</h3><p>参数如下：</p>
<p>Github：github个人主页</p>
<p>Gitee：gitee码云个人主页</p>
<p>TikTok：网页抖音个人主页</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Github</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/Yan-Tongxue</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Gitee</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github-alt</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://gitee.com/WY-Studio</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TikTok</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-youtube</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://www.douyin.com/user/MS4wLjABAAAADXge-FYlT6XAU_IyLCZfNS5Q6EUmyzohrwBgqIkwxNM</span></span><br></pre></td></tr></table></figure></div>

<p>效果图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Update-Blog-Img/img.jpg"
                     
                >

<h3 id="替换banner背景图"><a href="#替换banner背景图" class="headerlink" title="替换banner背景图"></a>替换banner背景图</h3><p>首页背景视频保持不变，归档&#x2F;友链&#x2F;关于&#x2F;文章</p>
<p>参数：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># banner </span></span><br><span class="line"><span class="attr">banner:</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">img</span></span><br><span class="line">    <span class="attr">bgurl:</span> <span class="string">/img/banner5.jpg</span></span><br><span class="line">    <span class="attr">bannerText:</span> <span class="string">Hi</span> <span class="string">my</span> <span class="string">new</span> <span class="string">friend!</span></span><br><span class="line">  <span class="attr">index:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">video</span></span><br><span class="line">    <span class="attr">bannerTitle:</span> <span class="string">所幸皆为美好，&lt;br&gt;所行不负年少。</span></span><br><span class="line">    <span class="attr">bannerText:</span> <span class="string">Hi</span> <span class="string">my</span> <span class="string">new</span> <span class="string">friend!</span></span><br><span class="line">    <span class="comment"># bgurl: /img/banner3.jpg</span></span><br><span class="line">    <span class="attr">bgurl:</span> <span class="string">/video/backvideo.mp4</span></span><br><span class="line">    <span class="attr">videoUrl:</span></span><br><span class="line">  <span class="attr">archive:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">img</span></span><br><span class="line">    <span class="attr">bannerTitle:</span> <span class="string">云间连下榻，&lt;br&gt;天上接行杯。</span></span><br><span class="line">    <span class="attr">bgurl:</span> <span class="string">/img/banner1.jpg</span></span><br><span class="line">    <span class="attr">bannerText:</span> <span class="string">The</span> <span class="string">article</span> <span class="string">archive</span></span><br><span class="line">  <span class="attr">links:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">img</span></span><br><span class="line">    <span class="attr">bannerTitle:</span> <span class="string">莫愁前路无知己，&lt;br&gt;天下谁人不识君。</span></span><br><span class="line">    <span class="attr">bgurl:</span> <span class="string">/img/banner2.jpg</span></span><br><span class="line">    <span class="attr">bannerText:</span> <span class="string">A</span> <span class="string">link</span> <span class="string">to</span> <span class="string">a</span> <span class="string">friend&#x27;s</span> <span class="string">website</span></span><br><span class="line">  <span class="attr">comment:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">img</span></span><br><span class="line">    <span class="attr">bannerTitle:</span> <span class="string">醉后不知天在水，&lt;br&gt;满船清梦压星河。</span></span><br><span class="line">    <span class="attr">bgurl:</span> </span><br><span class="line">    <span class="attr">bannerText:</span> <span class="string">The</span> <span class="string">magic</span> <span class="string">tree</span> <span class="string">hole</span></span><br><span class="line">  <span class="attr">about:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">img</span></span><br><span class="line">    <span class="attr">bannerTitle:</span> <span class="string">醉后不知天在水，&lt;br&gt;满船清梦压星河。</span></span><br><span class="line">    <span class="attr">bgurl:</span> <span class="string">/img/banner4.jpg</span></span><br><span class="line">    <span class="attr">bannerText:</span> <span class="string">About</span> <span class="string">me</span></span><br></pre></td></tr></table></figure></div>

<h3 id="新增评论区功能"><a href="#新增评论区功能" class="headerlink" title="新增评论区功能"></a>新增评论区功能</h3><p>本次在网上查询资料，发现一款好用的评论插件：giscus</p>
<p>这是由 <a class="link"   href="https://docs.github.com/en/discussions" >GitHub Discussions <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 驱动的评论系统，让访客借助 GitHub 在网站上留下评论和反应。</p>
<p>主页：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Update-Blog-Img/img4.jpg"
                     
                >

<p>配置参数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://giscus.app/client.js&quot;</span></span><br><span class="line">        data-repo=<span class="string">&quot;&quot;</span></span><br><span class="line">        data-repo-id=<span class="string">&quot;&quot;</span></span><br><span class="line">        data-category=<span class="string">&quot;General&quot;</span></span><br><span class="line">        data-category-id=<span class="string">&quot;&quot;</span></span><br><span class="line">        data-mapping=<span class="string">&quot;title&quot;</span></span><br><span class="line">        data-strict=<span class="string">&quot;1&quot;</span></span><br><span class="line">        data-reactions-enabled=<span class="string">&quot;1&quot;</span></span><br><span class="line">        data-emit-metadata=<span class="string">&quot;1&quot;</span></span><br><span class="line">        data-input-position=<span class="string">&quot;top&quot;</span></span><br><span class="line">        data-theme=<span class="string">&quot;light&quot;</span></span><br><span class="line">        data-lang=<span class="string">&quot;zh-CN&quot;</span></span><br><span class="line">        data-loading=<span class="string">&quot;lazy&quot;</span></span><br><span class="line">        crossorigin=<span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        <span class="keyword">async</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>效果图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Update-Blog-Img/img5.jpg"
                     
                >

<p>那么访客评论后是推送到Github的Yan-Tongxue&#x2F;comment储存库，我将储存库可见性设为公共的，另外在每位访客评论之后会发邮箱通知到我的账户里，这样也能方便及时看到大家的评论。</p>
<h3 id="新增文章打赏功能"><a href="#新增文章打赏功能" class="headerlink" title="新增文章打赏功能"></a>新增文章打赏功能</h3><p>这个功能也是想着新建一个搞着玩，万一有老板看上了我的文章给我的打赏了呢，本功能还在测试阶段中。</p>
<p>参数：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">comment:</span> <span class="string">reward.comment</span></span><br><span class="line">  <span class="comment"># url:</span></span><br><span class="line">  <span class="attr">methods:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">微信</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">https://www.wangyoustudio.cn//asset_img/money.jpg</span></span><br></pre></td></tr></table></figure></div>

<p>效果图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Update-Blog-Img/img1.jpg"
                     
                >]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Aplayer搭配MetingJS音乐插件的使用</title>
    <url>/2022/11/15/Aplayer%E6%90%AD%E9%85%8DMetingJS%E9%9F%B3%E4%B9%90%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Aplayer搭配MetingJS"><a href="#Aplayer搭配MetingJS" class="headerlink" title="Aplayer搭配MetingJS"></a>Aplayer搭配MetingJS</h3><p><strong>Aplayer</strong>官网文档：<a class="link"   href="https://aplayer.js.org/#/" >https://aplayer.js.org/#/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>Metingjs</strong>官网文档：<a class="link"   href="https://github.com/metowolf/MetingJS" >https://github.com/metowolf/MetingJS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>Aplayer</strong>是一个功能强大的HTML5音乐播放器，<strong>Metingjs</strong>基于<strong>Aplayer</strong>插件封装好的插件，开箱即用。</p>
<h3 id="MetingJS的简单使用"><a href="#MetingJS的简单使用" class="headerlink" title="MetingJS的简单使用"></a>MetingJS的简单使用</h3><p><strong>MetingJS</strong>支持<strong>Aplayer</strong>版本</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>API Status</th>
<th>APlayer</th>
</tr>
</thead>
<tbody><tr>
<td>1.2.x</td>
<td>Supported</td>
<td>1.10.0</td>
</tr>
<tr>
<td>2.0.x</td>
<td>Latest</td>
<td>1.10.0</td>
</tr>
</tbody></table>
<p><strong>支持的浏览器</strong></p>
<ul>
<li>Chrome</li>
<li>Firefox</li>
<li>Safari</li>
<li>Internet Explorer 11</li>
<li>Microsoft Edge</li>
</ul>
<p><strong>简单使用</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>	</span><br><span class="line">	<span class="comment">&lt;!-- require APlayer --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- require MetingJS --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">meting-js</span> <span class="attr">server</span>=<span class="string">&quot;netease&quot;</span> <span class="attr">type</span>=<span class="string">&quot;playlist&quot;</span> <span class="attr">id</span>=<span class="string">&quot;7727259103&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">meting-js</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>注意：server&#x3D;”netease” type&#x3D;”playlist” id&#x3D;”7727259103” 你可以设置”netease“为网易云音乐，”tencent“为QQ音乐平台，id当你创建一个歌单之后右键分享歌单会出现一串数字（网易云），字母（QQ音乐）</p>
<p><strong>Aplayer参数选择</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>默认</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id(编号)</td>
<td><strong>require</strong></td>
<td>歌曲ID &#x2F;播放列表ID &#x2F;专辑ID &#x2F;搜索关键字</td>
</tr>
<tr>
<td>server(平台)</td>
<td><strong>require</strong></td>
<td>音乐平台：<code>netease</code>，<code>tencent</code>，<code>kugou</code>，<code>xiami</code>，<code>baidu</code></td>
</tr>
<tr>
<td>type（类型）</td>
<td><strong>require</strong></td>
<td><code>song</code>，<code>playlist</code>，<code>album</code>，<code>search</code>，<code>artist</code></td>
</tr>
<tr>
<td>auto（支持类种 类）</td>
<td>options</td>
<td>音乐链接，支持：<code>netease</code>，<code>tencent</code>，<code>xiami</code></td>
</tr>
<tr>
<td>fixed（固定模式）</td>
<td><code>false</code></td>
<td>启用固定模式，默认<code>false</code></td>
</tr>
<tr>
<td>mini（迷你模式）</td>
<td><code>false</code></td>
<td>启用迷你模式,默认<code>false</code></td>
</tr>
<tr>
<td>autoplay（自动播放）</td>
<td><code>false</code></td>
<td>音频自动播放，默认<code>false</code></td>
</tr>
<tr>
<td>theme(主题颜色)</td>
<td><code>#2980b9</code></td>
<td>默认<code>#2980b9</code></td>
</tr>
<tr>
<td>loop（循环）</td>
<td><code>all</code></td>
<td>播放器循环播放，值：“all”，one”，“none”</td>
</tr>
<tr>
<td>order(顺序)</td>
<td><code>list</code></td>
<td>播放器播放顺序，值：“list”，“random”</td>
</tr>
<tr>
<td>preload(加载)</td>
<td><code>auto</code></td>
<td>值：“none”，“metadata”，“’auto”</td>
</tr>
<tr>
<td>volume（声量）</td>
<td><code>0.7</code></td>
<td>默认音量，请注意播放器会记住用户设置，用户自己设置音量后默认音量将不起作用</td>
</tr>
<tr>
<td>mutex（限制）</td>
<td><code>true</code></td>
<td>防止同时播放多个玩家，在该玩家开始播放时暂停其他玩家</td>
</tr>
<tr>
<td>lrc-type（歌词）</td>
<td><code>0</code></td>
<td>歌词显示</td>
</tr>
<tr>
<td>list-folded（列表折叠）</td>
<td><code>false</code></td>
<td>指示列表是否应该首先折叠</td>
</tr>
<tr>
<td>list-max-height（最大高度）</td>
<td><code>340px</code></td>
<td>列出最大高度</td>
</tr>
<tr>
<td>storage-name（储存名称）</td>
<td><code>metingjs</code></td>
<td>存储播放器设置的localStorage键</td>
</tr>
</tbody></table>
<h3 id="Aplayer的使用"><a href="#Aplayer的使用" class="headerlink" title="Aplayer的使用"></a>Aplayer的使用</h3><p>将这行代码复制进你的网页，调整好参数，就可以开始自定义化你的播放器啦！</p>
<p>我的博客网页播放器配置示例：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用Aplayer和metingjs --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;my-aplayer&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">class</span>=<span class="string">&quot;aplayer&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">data-id</span>=<span class="string">&quot;7727259103&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">data-server</span>=<span class="string">&quot;netease&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">data-type</span>=<span class="string">&quot;playlist&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">data-fixed</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">data-autoplay</span>=<span class="string">&quot;false&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">data-order</span>=<span class="string">&quot;list&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">data-volume</span>=<span class="string">&quot;0.1&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">data-theme</span>=<span class="string">&quot;#2EA7E0&quot;</span> </span></span><br><span class="line"><span class="tag">	<span class="attr">data-preload</span>=<span class="string">&quot;auto&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">data-listFolded</span>=<span class="string">&quot;ture&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>hexo插件</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT介绍OpenAI</title>
    <url>/2024/02/07/ChatGPT%E4%BB%8B%E7%BB%8DOpenAI/</url>
    <content><![CDATA[<p>ChatGPT介绍 OpenAI</p>
<p>ChatGPT是一种基于GPT（Generative Pre-train Transformer）模型的大型语言模型，由OpenAI公司开发。它是目前世界上最先进的自然语言处理技术之一。</p>
<p>ChatGPT是基于GPT-3.5架构进行训练的，拥有1750亿个参数，是目前公开的最大的语言模型之一。</p>
<p>ChatGPT可以用于各种对话应用，包括智能客服、聊天机器人等。它可以实现自然的对话流程，并能够回答各种类型的问题。除此之外，ChatGPT还可以进行文本生成、摘要、翻译等任务。</p>
<p>01</p>
<p>ChatGPT表演时间</p>
<p><strong>Show Time</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wy-blog-image.oss-cn-guangzhou.aliyuncs.com/img/20230718145000.png"
                      alt="图片"
                ></p>
<p>问题：你如何看待ChatGPT？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wy-blog-image.oss-cn-guangzhou.aliyuncs.com/img/20230718144959.png"
                      alt="图片"
                ></p>
<p>问题：写一篇微信公众号推文</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://wy-blog-image.oss-cn-guangzhou.aliyuncs.com/img/20230718145002.png"
                      alt="图片"
                ></p>
<p>问题：写一个爬虫脚本，可以批量下载资源</p>
<p>02</p>
<p>ChatGPT使用事项</p>
<p>这里可以粗略的介绍一下ChatGPT如何使用：首先你得获取一个能翻墙的VPN，因为openAi是国外的，所以需要翻墙才能进入ChatGPT网站（关于VPN就不透露太多奥~），另外小编在这里推荐一个网站，里面包含了100个ChatGPT账号。</p>
<p>网站链接：</p>
<p><strong><a class="link"   href="https://www.cmdpe.com/post/163.html" >https://www.cmdpe.com/post/163.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p>
<p>03</p>
<p>相信大家看了上述内容一定对ChatGPT很好奇把，但是使用ChatGPT仍然是一把双刃剑，好的方面能提高我们的学习能力，坏的方面说不定会成为一种依赖，所以在这里我觉得正确的去使用它才最重要！</p>
<p>ChatGPT确实火，在网络上各种声音都有，但是我觉得chatGPT及相关技术确实会对人类科技的进步产生非常大的影响，同时对于个人来说也会有非常大的影响。我作为一个体验过ChatGPT的大学生来说，我并不认为ChatGPT能够取代人类，它只能用作我们的首席助手。</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>Django+SimpleUI技术分享</title>
    <url>/2024/03/17/Django-SimpleUI%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="一、Django可视化后台自定义菜单。"><a href="#一、Django可视化后台自定义菜单。" class="headerlink" title="一、Django可视化后台自定义菜单。"></a>一、Django可视化后台自定义菜单。</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">SIMPLEUI_CONFIG = &#123;</span><br><span class="line">    <span class="string">&#x27;system_keep&#x27;</span>: <span class="literal">False</span>,  <span class="comment"># 关闭系统菜单</span></span><br><span class="line">    <span class="string">&#x27;menu_display&#x27;</span>: [<span class="string">&#x27;首页大屏&#x27;</span>,<span class="string">&#x27;认证和授权&#x27;</span>,<span class="string">&#x27;宏观质量&#x27;</span>, <span class="string">&#x27;品牌建设&#x27;</span>, <span class="string">&#x27;产品安全&#x27;</span>, <span class="string">&#x27;企业质量画像&#x27;</span>,</span><br><span class="line">                     <span class="string">&#x27;企业基础设施&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;dynamic&#x27;</span>: <span class="literal">False</span>,  <span class="comment"># 设置是否开启动态菜单, 默认为False. 如果开启, 则会在每次用户登陆时动态展示菜单内容</span></span><br><span class="line">    <span class="string">&#x27;menus&#x27;</span>: [&#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Simpleui&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;icon&#x27;</span>: <span class="string">&#x27;fas fa-code&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://gitee.com/tompeppa/simpleui&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;codename&#x27;</span>: <span class="string">&#x27;simpleui&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;在线社区&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;icon&#x27;</span>: <span class="string">&#x27;fa fa-file&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;codename&#x27;</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;models&#x27;</span>: [&#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;SimplePro&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;icon&#x27;</span>: <span class="string">&#x27;far fa-surprise&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;models&#x27;</span>: [&#123;</span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Pro文档&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://simpleui.72wo.com/docs/simplepro&#x27;</span></span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;购买Pro&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;http://simpleui.72wo.com/simplepro&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;社区&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://simpleui.72wo.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;icon&#x27;</span>: <span class="string">&#x27;fab fa-github&#x27;</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;图片转换器&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://convert.72wo.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;icon&#x27;</span>: <span class="string">&#x27;fab fa-github&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;codename&#x27;</span>: <span class="string">&#x27;nat&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：此代码块在setting.py中使用，如果需要搭配使用，需要models模型在admin.py中进行注册之后即可映射出url替代原文中的url。此自定义菜单支持多级菜单。django后台会直接以APP名称为一级菜单，数据表为二级菜单，最多到二级菜单，没法到三级菜单。我们安装simpleui可以解决这个。<br>另外需要注意的是，一级菜单必须在menu_display里命名，并且两者名字必须一致，不然可能会出现菜单列表丢失的现象。</p>
<h2 id="二、Django中admin-py的花式操作"><a href="#二、Django中admin-py的花式操作" class="headerlink" title="二、Django中admin.py的花式操作"></a>二、Django中admin.py的花式操作</h2><p>添加自定义导出表头按钮：</p>
<p>Admin</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestAdmin</span>(<span class="title class_ inherited__">ImportExportModelAdmin</span>):</span><br><span class="line">    list_display = [<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;std_type&#x27;</span>, <span class="string">&#x27;std_num&#x27;</span>]</span><br><span class="line">    search_fields = [<span class="string">&#x27;std_num&#x27;</span>]</span><br><span class="line">    list_per_page = <span class="number">20</span></span><br><span class="line">	<span class="comment"># 导出表头方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">export_table_header</span>(<span class="params">self, request, queryset</span>):</span><br><span class="line">        resource = TestResource()</span><br><span class="line">        headers = resource.get_export_headers()</span><br><span class="line"></span><br><span class="line">        response = HttpResponse(content_type=<span class="string">&#x27;text/csv&#x27;</span>)</span><br><span class="line">        response[<span class="string">&#x27;Content-Disposition&#x27;</span>] = <span class="string">&#x27;attachment; filename=&quot;table_header.csv&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line">        writer = csv.writer(response)</span><br><span class="line">        writer.writerow(headers)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">	<span class="comment"># 自定义表头按钮名称</span></span><br><span class="line">    export_table_header.short_description = <span class="string">&#x27;导出表头&#x27;</span></span><br><span class="line">    <span class="comment"># 添加自定义动作</span></span><br><span class="line">    actions = [<span class="string">&#x27;export_table_header&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    resource_class = TestResource</span><br></pre></td></tr></table></figure></div>

<p>Resource</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestResource</span>(resources.ModelResource):</span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Test</span><br><span class="line">        fields = (<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;std_type&#x27;</span>, <span class="string">&#x27;std_num&#x27;</span>, <span class="string">&#x27;dt&#x27;</span>)  <span class="comment"># 自定义指定需要导出的字段</span></span><br><span class="line">        export_order = (<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;std_type&#x27;</span>, <span class="string">&#x27;std_num&#x27;</span>, <span class="string">&#x27;dt&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">export_headers_to_csv</span>(<span class="params">self</span>):</span><br><span class="line">        dataset = self.export(queryset)</span><br><span class="line">        response = HttpResponse(content_type=<span class="string">&#x27;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;</span>)</span><br><span class="line">        response[<span class="string">&#x27;Content-Disposition&#x27;</span>] = <span class="string">&#x27;attachment; filename=&quot;exported_data.xlsx&quot;&#x27;</span></span><br><span class="line">        dataset.export(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_export_headers</span>(<span class="params">self</span>):</span><br><span class="line">        headers = []</span><br><span class="line">        <span class="keyword">for</span> field_name, field <span class="keyword">in</span> self.fields.items():</span><br><span class="line">            chinese_name = self.field_mapping.get(field.attribute, field.column_name)</span><br><span class="line">            headers.append(chinese_name)</span><br><span class="line">        <span class="keyword">return</span> headers</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitee有仓库如何提交代码</title>
    <url>/2022/11/04/Gitee%E6%9C%89%E4%BB%93%E5%BA%93%E5%A6%82%E4%BD%95%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>有时候我们在本地开发了一个项目，想推送到gitee仓库管理，有两种方式<br>一，新建gitee空仓库，然后git clone到本地，然后把代码复制进去提交</p>
<p>1.在gitee创建一个仓库，然后git clone 新建的仓库地址，到本地</p>
<p>2.把项目代码复制到clone下来的仓库</p>
<p>3.git add 提交代码</p>
<p>二.新建gitee空仓库，然后在本地项目git init初始化项目，然后推送到空项目</p>
<p>1.cd项目，执行git init，初始化本地仓库</p>
<p>2.给本地仓库关联远程仓库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://gitee.com/用户个性地址/HelloGitee.git</span><br></pre></td></tr></table></figure></div>

<p>3.先更新本地仓库，</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure></div>

<p> 4.推送本地仓库代码到远程仓库</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;第一次提交&quot;</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitee本地文件上传远程仓库</title>
    <url>/2022/09/17/Gitee%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>此篇介绍在日常使用中，国内gitee上传本地文件的方法（国外有github，不过网速较慢，国内可以使用gitee速度会快一点），包括绝大格式的图片、文章、代码等等。</p>
<h1 id="1-下载git工具"><a href="#1-下载git工具" class="headerlink" title="1.下载git工具"></a>1.下载git工具</h1><p>在浏览器输入网址：<a class="link"   href="https://git-scm.com/" >Git (git-scm.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>访问git下载官网，按照自己电脑版本下载对应的版本即可，这里通常是Windows版本。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Gitee-Note-Img/img2.jpg"
                     
                >

<h1 id="2-新建文件夹储存需要上传的文件"><a href="#2-新建文件夹储存需要上传的文件" class="headerlink" title="2.新建文件夹储存需要上传的文件"></a>2.新建文件夹储存需要上传的文件</h1><p>可以在电脑的任何地方新建一个文件夹，然后先需要上传到gitee远程仓库的文件存储到新建的文件夹中。</p>
<p>另外在此目录下右键打开Git Bash命令输入以下命令进行全局配置：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Gitee-Note-Img/img1.jpg"
                     
                >

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name<span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;xxx@qq.com&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>提示：name和email为注册的用户名以及邮箱地址，或者在gitee中新建仓库的第一次也会让你进行全局配置。</p>
<h1 id="3-创建Git仓库"><a href="#3-创建Git仓库" class="headerlink" title="3.创建Git仓库"></a>3.创建Git仓库</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Gitee-Note-Img/img3.jpg"
                     
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Gitee-Note-Img/img4.jpg"
                     
                >

<p>这里可以按照gitee的步骤创建git仓库，以下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> study <span class="comment">#创建目录</span></span><br><span class="line"><span class="built_in">cd</span> study	<span class="comment">#跳转到此目录下</span></span><br><span class="line">git init	<span class="comment">#仓库初始化</span></span><br><span class="line"><span class="built_in">touch</span> README.md	<span class="comment">#新建一个README.md（可建可不建）</span></span><br><span class="line">git add README.md	<span class="comment">#添加到上传目录</span></span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span>	<span class="comment">#上传提交，引号内可以自己定义上传的备注</span></span><br><span class="line">git remote add origin https://gitee.com/yan-songjie/study.git	<span class="comment">#配置仓库地址	</span></span><br><span class="line">git push -u origin <span class="string">&quot;master&quot;</span>	<span class="comment">#推送</span></span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Gitee-Note-Img/img5.jpg"
                     
                >

<h1 id="4-开始上传文件"><a href="#4-开始上传文件" class="headerlink" title="4.开始上传文件"></a>4.开始上传文件</h1><p>第三步创建完之后会出现一个文件夹，我们直接将需要上传的文件复制到里面，然后输入一下命令：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Gitee-Note-Img/img6.jpg"
                     
                >

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git add .	<span class="comment">#添加当前目录下的所有文件到</span></span><br></pre></td></tr></table></figure></div>

<p>将文件提交到本地：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;第一次提交&#x27;</span>	<span class="comment">#单引号内的内容为提交时的备注信息</span></span><br></pre></td></tr></table></figure></div>

<p>将本地文件推送到仓库中：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master		<span class="comment">#master是默认分支名，这里可以根据自己需要进行修改</span></span><br></pre></td></tr></table></figure></div>

<p>成功：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin dev</span><br><span class="line">Enumerating objects: 17, done.</span><br><span class="line">Counting objects: 100% (17/17), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (16/16), done.</span><br><span class="line">Writing objects: 100% (16/16), 64.89 KiB | 7.21 MiB/s, done.</span><br><span class="line">Total 16 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Powered by GITEE.COM [GNK-6.4]</span><br><span class="line">To https://gitee.com/yan-songjie/study-note.git</span><br><span class="line">   20020b8..e725037  dev -&gt; dev</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Gitee-Note-Img/img7.jpg"
                     
                >]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令行</title>
    <url>/2022/09/04/Git%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<p>此篇为Git命令行，用于敏捷高效地处理任何或小或大的项目。</p>
<p>一、git基础命令</p>
<p>1、版本命令行</p>
<p>​	git version</p>
<p>2、全局账户配置</p>
<p>​	git config –global user.name “颜松杰”<br>​	git config –global user.email “<a class="link"   href="mailto:&#x32;&#x32;&#55;&#x39;&#x36;&#x35;&#x36;&#x39;&#x30;&#57;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;" >&#x32;&#x32;&#55;&#x39;&#x36;&#x35;&#x36;&#x39;&#x30;&#57;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“</p>
<p>3、查看配置文件</p>
<p>​	git config –list</p>
<p>二、代码上传本地仓库（在文件下面使用命令行 git bash here）</p>
<p>1、初始化本地仓库</p>
<p>​	git init</p>
<p>2、查看状态</p>
<p>​	git status<br>​	git status -s</p>
<p>3、 将文件或者文件夹加入到本地库</p>
<p>​	git add 文件&#x2F;文件夹<br>​	git add -a</p>
<p>4、 提交本地仓库</p>
<p>​	git commit -m “提交的注释信息”	加入到本地仓库以后，需要提交一下</p>
<p>5、查看日志版本</p>
<p>​	git log<br>​	git log –pretty&#x3D;oneline	如果有多个版本日志，在一行上显示</p>
<p>6、回退历史</p>
<p>​	git reset –hard HEAD 版本<br>​	git reset –hard HEAD^	表示回退到上一个版本<br>​	git reset –hard HEAD^2	表示回退到上两个版本</p>
<p>7、版本穿越</p>
<p>​	git reset –hard 版本号	切换任意版本<br>​	git reflog –pretty&#x3D;oneline	查看历史的所有版本</p>
<p>8、还原文件</p>
<p>​	git checkout –文件名</p>
<p>9、删除文件</p>
<p>​	先删除本地库的文件<br>​	然后执行 git add 操作<br>​	最后在执行 git commit -m “操作”</p>
<p>三、git分支管理</p>
<p>1、查看当前分支</p>
<p>​	git branch<br>​	git branch -v</p>
<p>2、创建一个新的分支</p>
<p>​	git branch 分支名</p>
<p>3、切换分支</p>
<p>​	git checkout 分支名</p>
<p>4、子分支文件合并到主分支</p>
<p>​	先必须切换到主分支上，执行git merge 子分支名</p>
<p>5、查看冲突的文件内容</p>
<p>​	git diff</p>
<p>6、删除子分支（需要在主分支上执行）</p>
<p>​	git branch -d 分支的名字	删除的时候，会有提示，提示是否删除<br>​	git branch -D 分支的名字	强制删除，没有提示<br>​	如果子分支上有代码没有合并到主分支，也会强制删除！</p>
<p>四、发布项目</p>
<p>1、全局账户配置</p>
<p>​	git config –global user.name “颜松杰”<br>​	git config –global user.email “<a class="link"   href="mailto:&#50;&#50;&#x37;&#x39;&#x36;&#x35;&#x36;&#x39;&#48;&#x39;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#109;" >&#50;&#50;&#x37;&#x39;&#x36;&#x35;&#x36;&#x39;&#48;&#x39;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“</p>
<p>2、创建git仓库</p>
<p>​	mkdir we-chat-project	创建仓库<br>​	cd we-chat-project		进入文件夹<br>​	git init			初始化<br>​	touch README.md		设置README.md	<br>​	git add README.md	文件推送<br>​	git commit -m “first commit”	文件提交<br>​	git remote add origin <a class="link"   href="https://gitee.com/yan-songjie/we-chat-project.git" >https://gitee.com/yan-songjie/we-chat-project.git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>​	git push -u origin master</p>
<p>3、已经有git仓库（注：现有仓库举例）</p>
<p>​	cd existing_git_repo		进入文件夹<br>​	git remote add origin <a class="link"   href="https://gitee.com/yan-songjie/we-chat-project.git" >https://gitee.com/yan-songjie/we-chat-project.git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>	<br>​	git push -u origin master<br>​	上传完毕会提示输入账号密码验证<br>​	账号为gitee邮箱号<br>​	密码为gitee设置的密码</p>
<p>4、代码克隆</p>
<p>​	git clone <a class="link"   href="https://gitee.com/yan-songjie/we-chat-project.git" >https://gitee.com/yan-songjie/we-chat-project.git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 文件名<br>​	注：网址在gitee网页仓库里能直接拿到</p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Ip2region介绍</title>
    <url>/2022/09/25/Ip2region%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>ip2region v2.0 - 是一个离线IP地址定位库和IP定位数据管理框架，10微秒级别的查询效率，提供了众多主流编程语言的 xdb 数据生成和查询客户端实现。v1.0 旧版本: <a href="v1.0">v1.0版本入口</a></p>
<h1 id="Ip2region-特性"><a href="#Ip2region-特性" class="headerlink" title="Ip2region 特性"></a>Ip2region 特性</h1><h3 id="1、标准化的数据格式"><a href="#1、标准化的数据格式" class="headerlink" title="1、标准化的数据格式"></a>1、标准化的数据格式</h3><p>每个 ip 数据段的 region 信息都固定了格式：国家|区域|省份|城市|ISP，只有中国的数据绝大部分精确到了城市，其他国家部分数据只能定位到国家，后前的选项全部是0。</p>
<h3 id="2、数据去重和压缩"><a href="#2、数据去重和压缩" class="headerlink" title="2、数据去重和压缩"></a>2、数据去重和压缩</h3><p><code>xdb</code> 格式生成程序会自动去重和压缩部分数据，默认的全部 IP 数据，生成的 ip2region.xdb 数据库是 11MiB，随着数据的详细度增加数据库的大小也慢慢增大。</p>
<h3 id="3、极速查询响应"><a href="#3、极速查询响应" class="headerlink" title="3、极速查询响应"></a>3、极速查询响应</h3><p>即使是完全基于 <code>xdb</code> 文件的查询，单次查询响应时间在十微秒级别，可通过如下两种方式开启内存加速查询：</p>
<ol>
<li><code>vIndex</code> 索引缓存 ：使用固定的 <code>512KiB</code> 的内存空间缓存 vector index 数据，减少一次 IO 磁盘操作，保持平均查询效率稳定在10-20微秒之间。</li>
<li><code>xdb</code> 整个文件缓存：将整个 <code>xdb</code> 文件全部加载到内存，内存占用等同于 <code>xdb</code> 文件大小，无磁盘 IO 操作，保持微秒级别的查询效率。</li>
</ol>
<h3 id="4、IP-数据管理框架"><a href="#4、IP-数据管理框架" class="headerlink" title="4、IP 数据管理框架"></a>4、IP 数据管理框架</h3><p>v2.0 格式的 <code>xdb</code> 支持亿级别的 IP 数据段行数，region 信息也可以完全自定义，例如：你可以在 region 中追加特定业务需求的数据，例如：GPS信息&#x2F;国际统一地域信息编码&#x2F;邮编等。也就是你完全可以使用 ip2region 来管理你自己的 IP 定位数据。</p>
<h1 id="xdb-数据查询"><a href="#xdb-数据查询" class="headerlink" title="xdb 数据查询"></a><code>xdb</code> 数据查询</h1><p>API 介绍，使用文档和测试程序请参考对应 <code>searcher</code> 查询客户端下的 ReadMe 介绍，全部查询 binding 实现情况如下：</p>
<table>
<thead>
<tr>
<th align="left">Ok?</th>
<th align="left">状态</th>
<th align="left">编程语言</th>
<th align="left">描述</th>
<th align="left">贡献者</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="binding/golang">golang</a></td>
<td align="left">golang xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="binding/php">php</a></td>
<td align="left">php xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="binding/java">java</a></td>
<td align="left">java xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="binding/lua">lua</a></td>
<td align="left">纯 lua xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="binding/c">c</a></td>
<td align="left">ANSC c xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="binding/lua_c">lua_c</a></td>
<td align="left">lua c 扩展 xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">&amp;nbsp;&amp;nbsp;&amp;nbsp;</td>
<td align="left">待开始</td>
<td align="left"><a href="binding/rust">rust</a></td>
<td align="left">rust xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="binding/python">python</a></td>
<td align="left">python xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://github.com/luckydog6132" >厉害的花花 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="binding/nodejs">nodejs</a></td>
<td align="left">nodejs xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://github.com/wujjpp" >Wu Jian Ping <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="binding/csharp">csharp</a></td>
<td align="left">csharp xdb 查询客户端实现</td>
<td align="left"><a class="link"   href="https://gitee.com/Soar360" >Soar360 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">&amp;nbsp;&amp;nbsp;&amp;nbsp;</td>
<td align="left">待开始</td>
<td align="left"><a href="binding/php7_ext">php_ext</a></td>
<td align="left">php c 扩展 xdb 查询客户端实现</td>
<td align="left">待确定</td>
</tr>
<tr>
<td align="left">&amp;nbsp;&amp;nbsp;&amp;nbsp;</td>
<td align="left">待开始</td>
<td align="left"><a href="binding/nginx">nginx</a></td>
<td align="left">nginx 扩展 xdb 查询客户端实现</td>
<td align="left">待确定</td>
</tr>
</tbody></table>
<h1 id="xdb-数据生成"><a href="#xdb-数据生成" class="headerlink" title="xdb 数据生成"></a><code>xdb</code> 数据生成</h1><p>API 介绍，使用文档和测试程序请参考对应 <code>maker</code> 生成程序下的 ReadMe 介绍，全部生成 maker 实现情况如下：</p>
<table>
<thead>
<tr>
<th align="left">Ok?</th>
<th align="left">状态</th>
<th align="left">编程语言</th>
<th align="left">描述</th>
<th align="left">贡献者</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="maker/golang">golang</a></td>
<td align="left">golang xdb 生成程序实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="maker/java">java</a></td>
<td align="left">java xdb 生成程序实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">&amp;nbsp;&amp;nbsp;&amp;nbsp;</td>
<td align="left">待开始</td>
<td align="left"><a href="maker/c">c</a></td>
<td align="left">ANSC c xdb 生成程序实现</td>
<td align="left"><a class="link"   href="https://github.com/lionsoul2014" >Lion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
<tr>
<td align="left">:white_check_mark:</td>
<td align="left">已完成</td>
<td align="left"><a href="maker/python">python</a></td>
<td align="left">python xdb 生成程序实现</td>
<td align="left"><a class="link"   href="https://github.com/leolin49" >leolin49 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></td>
</tr>
</tbody></table>
<h1 id="并发查询必读"><a href="#并发查询必读" class="headerlink" title="并发查询必读"></a>并发查询必读</h1><p>全部查询客户端的 search 接口都 <b>不是</b> 并发安全的实现，不同进程&#x2F;线程&#x2F;协程需要通过创建不同的查询对象来安全使用，并发量很大的情况下，基于文件查询的方式可能会导致打开文件数过多的错误，请修改内核的最大允许打开文件数(fs.file-max&#x3D;一个更高的值)，或者将整个xdb加载到内存进行安全并发使用。</p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加Twikoo插件</title>
    <url>/2023/03/07/Hexo%E6%B7%BB%E5%8A%A0Twikoo%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Hexo添加Twikoo插件"><a href="#Hexo添加Twikoo插件" class="headerlink" title="Hexo添加Twikoo插件"></a>Hexo添加Twikoo插件</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>如果你的hexo博客支持Twikoo评论插件，不妨试着配置一下，它支持邮件提醒、甚至微信提醒等。可以说是目前最好的评论系统，并且长期免费。本博客未来将会采用此插件！</p>
<h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><h4 id="1-申请MongoDB数据库账号"><a href="#1-申请MongoDB数据库账号" class="headerlink" title="1.申请MongoDB数据库账号"></a>1.申请MongoDB数据库账号</h4><p>这里我们选择申请一个MongoDB账号，进入之后注册一个账号，这里省略注册过程。</p>
<img src = "/asset_img/Twikoo/img1.png">

<h4 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2.创建数据库"></a>2.创建数据库</h4><p>选择免费的数据库，类型选择Shared，区域选择aws，N.Virginia，选择美国东部，因为后面要用到vercel，节点会靠近一些。</p>
<img src = "/asset_img/Twikoo/img2.png">

<img src = "/asset_img/Twikoo/img3.png">

<h4 id="3-配置数据库"><a href="#3-配置数据库" class="headerlink" title="3.配置数据库"></a>3.配置数据库</h4><p>创建完数据库之后就是这个样子，点击connect</p>
<img src = "/asset_img/Twikoo/img4.png">

<p>这里我选择的是第二个Connect you application</p>
<img src = "/asset_img/Twikoo/img5.png">

<p>然后记住这个连接字符串，后面会用到，其中的<password>为刚刚设置的数据库的账户密码。</p>
<img src = "/asset_img/Twikoo/img6.png">

<h4 id="4-vercel"><a href="#4-vercel" class="headerlink" title="4.vercel"></a>4.vercel</h4><p>vercel算是我用过最好的网站托管服务，它类似于github page，但是比github page要强大，速度也要快的多，最重要的是它免费！另外vercel也支持自动配置https，不用你自己去SSL申请证书，所以真的是懒人必备，目前vercel也支持模板部署，其中就有hexo的很多模板。</p>
<p>那么下面我们来注册一个vercel账号，可以选择Github登录也可以选择邮箱注册。</p>
<img src = "/asset_img/Twikoo/img7.png">

<p>那么登录之后就是这个样子，这个是我已经创建的一个</p>
<img src = "/asset_img/Twikoo/img8.png">

<p>新建一个project</p>
<img src = "/asset_img/Twikoo/img9.png">

<p>等待创建完毕，可以点击DOMAINS查看云函数运行是否正常，另外这个网址就是你的环境ID</p>
<img src = "/asset_img/Twikoo/img10.png">

<img src = "/asset_img/Twikoo/img11.png">

<p>另外还需要配置连接mongodb的URI，点击settings，选择Environment Variables，左边是uri，右边是刚刚在mongodb的连接字符串</p>
<img src = "/asset_img/Twikoo/img12.png">

<p>注意：因为vercel的服务器在国外，所以在国内可能会被墙，这个时候就需要用到我们自己的域名。</p>
<h4 id="5-解决vercel被墙"><a href="#5-解决vercel被墙" class="headerlink" title="5.解决vercel被墙"></a>5.解决vercel被墙</h4><p>看到vercel的settings界面，选择Domains，这个就是可以添加我们自己的域名上去，然后这里的建议是我们添加一个自定义的二级域名（这样就可以防止抢占我们的博客主域名，防止404的情况出现）例如xxx.wangyoustudio.cn，前面的xxx就是自定义的内容</p>
<p>添加之后会出现这个，我们复制CNAME，添加一个二级域名，前面是自定义的内容，线路类型选择CName，然后复制进去</p>
<img src = "/asset_img/Twikoo/img13.png">

<img src = "/asset_img/Twikoo/img14.png">

<p>也可以用我我的方式添加，可能需要等待10分钟的解析</p>
<table>
<thead>
<tr>
<th>主机记录</th>
<th>记录类型</th>
<th>解析请求来源(isp)</th>
<th>记录值</th>
<th>TTL</th>
</tr>
</thead>
<tbody><tr>
<td>twikoo</td>
<td>CNAME</td>
<td>默认</td>
<td>cname.vercel-dns.com</td>
<td>10 分钟</td>
</tr>
<tr>
<td>@</td>
<td>A</td>
<td>默认</td>
<td>76.76.21.21</td>
<td>10 分钟</td>
</tr>
</tbody></table>
<p>首先以腾讯云服务器为例子，本网站的服务器是在腾讯云购买的，我们进入腾讯云主页选择DNS解析</p>
<img src = "/asset_img/Twikoo/img15.png">

<p>可以看到我已经是有一个域名的，我们直接选择解析</p>
<img src = "/asset_img/Twikoo/img16.png">

<p>成功之后就会显示蓝色的勾，像下面这样。这就是能加速到国内防止被墙的方法啦！</p>
<img src = "/asset_img/Twikoo/img17.png">

<h4 id="6-hexo配置"><a href="#6-hexo配置" class="headerlink" title="6.hexo配置"></a>6.hexo配置</h4><p>最后我们打开hexo的博客目录，找到config.yml文件，找到评论配置，不同的主题地方不一样，所以给个图片给大家参考：</p>
<img src = "/asset_img/Twikoo/img18.png">

<p>将我们之前的环境ID复制进去就可以使用啦！</p>
<p>最后我们来看看效果：</p>
<img src = "/asset_img/Twikoo/img19.png">

<p>本次就是Hexo添加Twikoo插件的教程了，如果还有什么不会的话欢迎评论区进行讨论！</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>Hexo插件</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入门</title>
    <url>/2022/09/02/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>此篇为C语言基础入门，适合C语言初学者</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>一、C语言简介</p>
<p>​	1、程序语言基础</p>
<p>​		1.1、程序设计语言概述</p>
<p>​			1.1.1、什么是计算机程序？</p>
<p>​			1.1.2、什么是计算机语言？</p>
<p>​			1.1.3、程序设计语言的基本概念</p>
<p>​		1.2、语言处理程序</p>
<p>​		1.3、程序设计语言的基本成分</p>
<p>​			1.3.1、程序设计语言的数据成分</p>
<p>​			1.3.2、程序设计语言的运算成分</p>
<p>​			1.3.3、程序设计语言的控制成分</p>
<p>​			1.3.4、程序设计语言的传输成分</p>
<p>​	2、什么是C语言</p>
<p>​	3、C语言的发展历程</p>
<p>​	4、C语言的特点</p>
<p>二、基本数据类型</p>
<p>​	1、数据的表现形式</p>
<p>​		1.1、常量</p>
<p>​		1.2、变量</p>
<p>​			1.2.1、变量的基本概念</p>
<p>​			1.2.2、标识符的命名规则</p>
<p>​			1.2.3、变量的定义</p>
<p>​	2、基本数据类型</p>
<p>​		2.1、数据类型的基本概念</p>
<p>​		2.2、基本数据类型简介</p>
<p>​		2.3、确定常量的类型</p>
<p>​	3、格式化输入输出函数</p>
<p>​		3.1、有关数据输入和输出的概念</p>
<p>​		3.2、用printf函数输出数据（格式化输出函数）</p>
<p>​		3.3、用scanf函数输入数据（格式化输入函数）</p>
<p>三、运算符和表达式</p>
<p>​	1、C语言运算符</p>
<p>​		1.1、C运算符的分类</p>
<p>​		1.2、运算符的操作数以及目数</p>
<p>​		1.3、运算符的优先级</p>
<p>​	2、算术运算符</p>
<p>​		2.1、基本的算术运算符</p>
<p>​		2.2、自增、自减运算符</p>
<p>​		2.3、算术表达式与运算符的优先级和结合性</p>
<p>​		2.4、不同类型数据间的混合运算</p>
<p>​	3、强制类型转换运算符</p>
<p>​	4、关系运算符</p>
<p>​	5、逻辑运算符</p>
<p>​	6、条件运算符</p>
<p>​	7、位运算符</p>
<p>​	8、表达式和C语句</p>
<p>​		8.1、表达式和语句的基本概念</p>
<p>​		8.2、逗号表达式</p>
<p>​		8.3、最基本的语句——赋值语句</p>
<p>​		8.4、C语句的分类</p>
<p>四、选择结构和循环结构</p>
<p>​	1、选择结构</p>
<p>​		1.1、if语句</p>
<p>​		1.2、switch语句</p>
<p>​	2、循环结构</p>
<p>​		2.1、for循环</p>
<p>​		2.2、while循环</p>
<p>​		2.3、do while循环</p>
<p>​		2.4、循环结构的分类</p>
<p>​	3、跳转语句</p>
<p>​		3.1、break语句</p>
<p>​		3.2、continue语句</p>
<p>​		3.3、goto跳转语句</p>
<p>五、数组</p>
<p>​	1、什么是数组？</p>
<p>​	2、一维数组的定义和引用</p>
<p>​		2.1、定义一维数组</p>
<p>​		2.2、使用数组及引用数组元素</p>
<p>​		2.3、一维数组的初始化</p>
<p>​		2.4、一维数组的输入输出</p>
<p>​	3、二维数组</p>
<p>​		3.1、二维数组的定义</p>
<p>​		3.2、二维数组的初始化</p>
<p>​		3.3、二维数组元素的访问</p>
<p>​		3.4、二维数组的输入输出</p>
<p>​	4、字符数组</p>
<p>​		4.1、字符数组的定义及初始化</p>
<p>​		4.2、引用字符数组中的元素</p>
<p>​		4.3、字符数组的输入和输出</p>
<p>​		4.4、二维字符数组</p>
<p>​		4.5、字符串处理函数</p>
<p>六、函数</p>
<p>​	1、函数的基本概念</p>
<p>​	2、函数的定义</p>
<p>​		2.1、定义无参无返回值函数</p>
<p>​		2.2、定义有参无返回值函数</p>
<p>​		2.3、定义有参数有返回值函数</p>
<p>​		2.4、定义无参数有返回值函数</p>
<p>​	3、函数的调用</p>
<p>​		3.1、函数调用语句</p>
<p>​		3.2、函数参数</p>
<p>​		3.3、实参和形参之间的数据传递</p>
<p>​		3.4、函数的返回值</p>
<p>​	4、函数的声明</p>
<p>​	5、局部变量和全局变量</p>
<p>​		5.1、局部变量</p>
<p>​		5.2、全局变量</p>
<p>​		5.3、静态变量与动态变量</p>
<p>​	6、函数的嵌套调用</p>
<p>​	7、函数的递归调用</p>
<p>​	8、数组作为函数参数传递</p>
<p>七、预处理</p>
<p>​	1、预定义符号</p>
<p>​	2、宏定义</p>
<p>​		2.1、无参宏定义</p>
<p>​		2.2、带参宏定义</p>
<p>​		2.3、常量的定义</p>
<p>​	3、文件包含</p>
<p>​		3.1、包含头文件</p>
<p>​		3.2、头文件的重复包含</p>
<p>​	4、条件编译</p>
<p>​		4.1、#if……#else的使用</p>
<p>​		4.2、#ifdef……#endif的使用</p>
<p>​		4.3、#ifndef……#endif的使用</p>
<p>八、构造数据类型</p>
<p>​	1、结构体</p>
<p>​		1.1、什么是结构体？</p>
<p>​		1.2、为什么要用结构体？</p>
<p>​		1.3、结构体类型的声明和结构体变量的定义</p>
<p>​		1.4、结构体变量的初始化和引用</p>
<p>​		1.5、使用typedef关键字自定义类型名</p>
<p>​		1.6、结构体的嵌套定义</p>
<p>​		1.7、结构体数组</p>
<p>​	2、共用体</p>
<p>​		2.1、什么是共用体？</p>
<p>​		2.2、共用体类型的声明和共用体变量的定义</p>
<p>​		2.3、共用体类型所占内存</p>
<p>​	3、枚举类型</p>
<p>​		3.1、枚举类型的概念</p>
<p>​		3.2、枚举类型的声明</p>
<p>​		3.3、枚举变量的定义</p>
<p>​		3.4、枚举类型应用举例</p>
<p>九、C语言文件操作</p>
<p>​	1、什么是文件？</p>
<p>​		1.1、文件的概念</p>
<p>​		1.2、文件的分类</p>
<p>​		1.3、文件存储方法的区别</p>
<p>​	2、指向文件的指针</p>
<p>​		2.1、文件指针的定义</p>
<p>​		2.2、打开与关闭文件</p>
<p>​	3、顺序读写文件</p>
<p>​		3.1、字符输入和输出函数</p>
<p>​		3.2、字符串输入和输出函数</p>
<p>​		3.3、文件格式化输入和输出函数</p>
<p>​		3.4、以二进制的形式读写数据</p>
<p>​	4、随机读写文件</p>
<p>​		4.1、强制使文件指针指向文件开头</p>
<p>​		4.2、使文件指针指向文件中的任意位置</p>
<p>​	5、文件的出错检测</p>
<p>​		5.1、文件读写出错检测</p>
<p>​		5.2、文件末尾判断</p>
<p>​		5.3、文件错误标志</p>
<p>十、C语言的灵魂——指针</p>
<p>​	1、什么是指针？</p>
<p>​	2、指针常量与指针变量</p>
<p>​		2.1、指针常量</p>
<p>​		2.2、指针变量</p>
<p>​	3、指针变量作为函数参数</p>
<p>​		3.1、函数参数为指针类型的函数</p>
<p>​		3.2、指针函数</p>
<p>​	4、通过指针引用数组</p>
<p>​		4.1、数组元素的地址</p>
<p>​		4.2、指针指向数组元素</p>
<p>​		4.3、指针指向的移动（指针的偏移）</p>
<p>​		4.4、指针指向字符串</p>
<p>​	5、指向函数的指针（函数指针）</p>
<p>​		5.1、什么是函数指针？</p>
<p>​		5.2、函数指针的定义</p>
<p>​		5.3、函数指针的初始化及使用</p>
<p>​		5.4、使用函数指针作为函数参数（回调函数）</p>
<p>​		5.5、使用typedef给函数指针取别名</p>
<p>​		5.6、指针函数和函数指针的区别</p>
<p>​	6、指针数组和数组指针</p>
<p>​		6.1、指针数组</p>
<p>​		6.2、数组指针</p>
<p>​	7、指针常量和常量指针</p>
<p>​	8、动态内存分配</p>
<p>​		8.1、什么是动态内存分配</p>
<p>​		8.2、怎样建立内存的动态分配</p>
<p>​	9、结构体指针</p>
<p>​		9.1、指向结构体变量的指针</p>
<p>​		9.2、结构体指针的定义</p>
<p>​		9.3、通过结构体指针引用结构体成员</p>
<p>​	10、多重指针（多级指针）</p>
<p>​		10.1、什么是多重指针</p>
<p>​		10.2、多重指针的定义</p>
<p>​		10.3、多重指针的使用</p>
<p>​		10.4、双重指针作为函数形参</p>
<p>​	11、内存四区</p>
<p>十一、排序算法</p>
<p>​	1、排序的基本概念</p>
<p>​		1.1、什么是排序？</p>
<p>​		1.2、排序的稳定性</p>
<p>​		1.3、排序的分类</p>
<p>​		1.4、排序的过程</p>
<p>​		1.5、排序算法</p>
<p>​	2、冒泡排序</p>
<p>​	3、简单选择排序</p>
<p>​	4、直接插入排序</p>
<p>十二、顺序表</p>
<p>​	1、顺序表的基本概念</p>
<p>​	2、顺序表的定义</p>
<p>​	3、顺序表的功能实现</p>
<p>十三、链表</p>
<p>​	1、链表的基本概念</p>
<p>​		1.1、什么是链表</p>
<p>​		1.2、链表的特点</p>
<p>​		1.3、链表和数组的区别</p>
<p>​	2、链表的结构</p>
<p>​		2.1、链表的结构体示意图</p>
<p>​		2.2、单链表节点的插入和删除结构示意图</p>
<p>​	3、单链表</p>
<p>​		3.1、单链表结构的声明</p>
<p>​		3.2、单链表的创建与功能实现</p>
<p>十四、栈和队列</p>
<p>​	1、栈和队列的基本概念</p>
<p>​	2、数据结构中的栈和队列</p>
<p>​		2.1、栈（stack）</p>
<p>​		2.2、队列（queue）</p>
<p>​	3、栈和队列的基本结构</p>
<p>​		3.1、栈和队列的结构示意图</p>
<p>​		3.2、栈和队列中数据的插入和删除</p>
<p>​	4、栈和队列的实现</p>
<p>​		4.1、栈功能的实现</p>
<p>​		4.2、队列功能的实现</p>
<p>附录：C语言常用基础知识</p>
<p>​	1、C语言中的关键字</p>
<p>​	2、ASCII码表</p>
<p>​	3、运算符的优先级</p>
<p>​	4、C语言常用头文件和库函数</p>
<p>​		4.1、数学函数</p>
<p>​		4.2、字符函数</p>
<p>​		4.3、字符串函数</p>
<p>​		4.4、输入输出函数</p>
<p>​		4.5、动态分配函数和随机函数</p>
<h1 id="一、C语言简介"><a href="#一、C语言简介" class="headerlink" title="一、C语言简介"></a>一、C语言简介</h1><h2 id="1、程序语言基础"><a href="#1、程序语言基础" class="headerlink" title="1、程序语言基础"></a>1、程序语言基础</h2><h3 id="1-1、程序设计语言概述"><a href="#1-1、程序设计语言概述" class="headerlink" title="1.1、程序设计语言概述"></a>1.1、程序设计语言概述</h3><h4 id="1-1-1、什么是计算机程序？"><a href="#1-1-1、什么是计算机程序？" class="headerlink" title="1.1.1、什么是计算机程序？"></a>1.1.1、什么是计算机程序？</h4><p>所谓程序，就是一组计算机能识别和执行的指令。每一条指令能使计算机执行特定的操作。</p>
<h4 id="1-1-2、什么是计算机语言？"><a href="#1-1-2、什么是计算机语言？" class="headerlink" title="1.1.2、什么是计算机语言？"></a>1.1.2、什么是计算机语言？</h4><p>人与人之间交流需要通过语言，我们中国人之间交流用普通话，英国人用英语，俄国人用俄语等。</p>
<p>那人和计算机之间交流当然也要使用一种语言了，所以我们创造了一种计算机和人都能识别的语言，这就是计算机语言。</p>
<h4 id="1-1-3、程序设计语言的基本概念"><a href="#1-1-3、程序设计语言的基本概念" class="headerlink" title="1.1.3、程序设计语言的基本概念"></a>1.1.3、程序设计语言的基本概念</h4><p>计算机语言是为了编写计算机程序而设计的符号语言，是用于对计算过程进行描述、组织和推导，方便人机交互的一种语言。我们需要简单了解一下从低级语言到高级语言。</p>
<p>（1）机器语言</p>
<p>由于计算机工作基于二进制，计算机硬件只能识别由0、1字符串组成的机器指令序列，也就是机器指令程序，我们把它称为机器语言，所以机器语言是最基本的计算机语言。用机器语言编制程序，编写的效率低、可读性差，也难以理解、修改和维护。</p>
<p>（2）汇编语言</p>
<p>由于使用机器语言对于人类来说太不友好了，所以人们设计了汇编语言，用一些容易记忆的符号代替0、1序列，来表示机器指令中的操作码和操作数。例如：用ADD表示加法、SUB表示减法等。相对于机器语言，使用汇编语言编写程序的效率和程序可读性有所提高，但汇编语言是面向机器的语言，其书写格式在很大程度上取决于特定计算机指令。<br>由于它比较“贴近”于计算机，或者说“偏向”于计算机，对计算机比较友好，所以机器语言和汇编语言被称为低级语言。</p>
<p>（3）高级语言</p>
<p>随着计算机的发展，人们开发了功能更强、可读性更高、更加“偏向”于人们逻辑思维的语言，为了更好的支持程序设计，因此产生了面向各类应用的程序设计语言，即高级语言。高级语言更接近于人们习惯使用的自然语言和数学语言，程序中用到的语句和指令是用英文单词来表示的，用到的运算符和表达式和我们日常用的数学算式差不多，比较容易理解。</p>
<p>我们常用的高级语言有C、C++、Java、PHP、Python等，这类语言与人们使用的自然语言比较接近，能够大大的提高程序设计的效率。</p>
<h3 id="1-2、语言处理程序"><a href="#1-2、语言处理程序" class="headerlink" title="1.2、语言处理程序"></a>1.2、语言处理程序</h3><p>编译程序和解释程序</p>
<p>尽管人们可以借助高级语言与计算机进行交互，但是计算机仍然只能理解和执行由0、1序列构成的机器语言，所以高级程序设计语言需要翻译成计算机能够识别的机器语言，担负这一任务的程序称为“语言处理程序”。由于应用程序设计语言不同，语言之间的翻译也是多种多样的，它们大致可以分为汇编程序、解释程序和编译程序。</p>
<p>用某种高级语言或汇编语言编写的程序称为源程序，源程序不能直接在计算机上执行。如果源程序是用汇编语言编写的，就需要汇编程序来把它翻译成目标程序才能执行；如果源程序是用某种高级语言编写的，就需要对应的解释程序或者编译程序进行翻译才能执行。</p>
<p>（1）编译程序：计算机是不能直接识别高级语言程序的，需要用一种称为编译程序的软件把用高级语言写的程序（源程序）转换成为机器指令的程序（目标程序），计算机才能够执行，最后才能得到结果。高级语言的一个语句往往对应多条机器指令。</p>
<p>C语言是编译型语言，从C语言源程序到可执行的目标程序需要经过预处理、编译和连接三个步骤。</p>
<p>（2）解释程序：也称为解释器，它可以直接解释执行源程序，或者将源程序翻译某种中间表示形式后再加以执行，不生成独立的目标程序。</p>
<h3 id="1-3、程序设计语言的基本成分"><a href="#1-3、程序设计语言的基本成分" class="headerlink" title="1.3、程序设计语言的基本成分"></a>1.3、程序设计语言的基本成分</h3><p>程序设计语言的基本成分包括数据、运算、控制和传输等。</p>
<h4 id="1-3-1、程序设计语言的数据成分"><a href="#1-3-1、程序设计语言的数据成分" class="headerlink" title="1.3.1、程序设计语言的数据成分"></a>1.3.1、程序设计语言的数据成分</h4><p>程序设计语言的数据成分是指程序设计语言所支持的数据类型。数据是程序操作的对象，具有类型、名称、作用域、存储类别和生存期等属性，在程序运行过程中要为他分配内存空间。</p>
<p>数据名称可以由用户通过标识符命名；数据类型说明数据占用内存的大小和存放形式；作用域则说明这个数据的使用范围；存储类别说明数据在内存中的位置；生存期说明数据占用内存的时间范围。</p>
<p>从不同的角度来看，可以将数据进行分类。</p>
<p>（1）根据程序运行时数据的值能否被改变可分为常量和变量。在程序中数据可以具有左值和右值，左值是指数据的存储空间（内存地址），右值是指数据的内容（值）。在程序运行中，数据的左值是不可被改变的，也就是常量，右值是可以被改变的，也就是变量。也有一些符号和数值类型等，只有右值，在程序运行过程中其右值不可被改变，所以也将他们称为字符常量和数值常量。</p>
<p>（2）按照数据类型不同可分为基本类型、特殊类型、用户自定义类型、构造类型及其它类型等。</p>
<p>（3）按照作用域的不同可分为全局量和局部量。全局量的作用域为整个程序，所以它在整个程序中都是可用的，在程序运行中其存储空间一般不可改变；而局部量的作用域为一条语句或者一个函数中，它在其他语句或者函数中是不可用的。</p>
<h4 id="1-3-2、程序设计语言的运算成分"><a href="#1-3-2、程序设计语言的运算成分" class="headerlink" title="1.3.2、程序设计语言的运算成分"></a>1.3.2、程序设计语言的运算成分</h4><p>运算成分指明允许使用的运算符号及运算规则。大多数高级程序设计语言的基本运算可分为算术运算、关系运算和逻辑运算等类型，有些语言还提供了位运算（如C、C++），运算符和数据类型密切相关，为了得到明确的运算结果，运算符号要规定优先级和结合性，必要时需要使用圆括号来改变其运算顺序。</p>
<h4 id="1-3-3、程序设计语言的控制成分"><a href="#1-3-3、程序设计语言的控制成分" class="headerlink" title="1.3.3、程序设计语言的控制成分"></a>1.3.3、程序设计语言的控制成分</h4><p>控制成分是指程序设计语言允许使用的控制结构，程序员可以使用控制成分来构造程序中的控制逻辑。控制结构可分为顺序、选择和循环这三种。</p>
<p>（1）顺序结构：用来表示一个计算操作序列的计算过程是按照所描述的第一个操作开始执行，按顺序依次执行后续操作，直到执行完最后一个操作。</p>
<p>（2）选择结构：也称为分支结构，它提供了在两个或多个分支中选择其中一个的逻辑。首先选择结构指定一个条件，然后根据条件是否成立来决定程序的走向，能从两个或多个分支中选择一个满足条件的来执行。</p>
<p>（3）循环结构：描述了重复计算的过程。通常由初始化、需要重复计算的部分和重复计算的条件组成。</p>
<h4 id="1-3-4、程序设计语言的传输成分"><a href="#1-3-4、程序设计语言的传输成分" class="headerlink" title="1.3.4、程序设计语言的传输成分"></a>1.3.4、程序设计语言的传输成分</h4><p>传输成分是指程序设计语言的输入和输出等数据传输。</p>
<p>比如：格式化输出函数、格式化输入函数</p>
<h2 id="2、什么是C语言"><a href="#2、什么是C语言" class="headerlink" title="2、什么是C语言"></a>2、什么是C语言</h2><p>C语言是一门面向过程的计算机编程语言，与C++、Java等面向对象编程语言有所不同。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、仅产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C语言描述问题比汇编语言迅速、工作量小、可读性好、易于调试、修改和移植，而代码质量与汇编语言相当。C语言一般只比汇编语言代码生成目标程序的效率低个10%～20%左右。所以，C语言可以编写系统软件。 </p>
<p>在编程领域中，C语言的运用非常之多，它兼顾了汇编语言和高级语言的优点，相对于其它编程语言而言，其具有较大的优势。C语言的普遍性较强，能够适用于许多计算机操作系统中，并且执行效率高。计算机系统的设计以及应用程序的编写是C语言应用的两大领域。 </p>
<p>C语言经过了漫长的发展历史，其拥有一套完整的理论体系，在编程语言中具有举足轻重的地位。</p>
<h2 id="3、C语言发展历程"><a href="#3、C语言发展历程" class="headerlink" title="3、C语言发展历程"></a>3、C语言发展历程</h2><p>怎样利用C语言作为工具进行程序设计？为什么要选择C语言呢?</p>
<p>首先有必要对C语言的发展和特点有一定的了解。<br>C语言是在国际上广泛流行的高级计算机语言，其是BCPL语言发展而来的。</p>
<p>1967年英国剑桥大学的Martin Richards推出了没有类型的BCPL( Basic Combined Programming Language)语言。</p>
<p>1970 年美国AT&amp;.T贝尔实验室的Ken Thompson以BCPL语言为基础，设计出了很简单且很接近硬件的B语言(取BCPL的第一个字母)。但B语言过于简单，功能有限。</p>
<p>1972- 1973年间,美国贝尔实验室的D.M.Ritchie在B语言的基础上设计出了C语言。C语言既保持了BCPL和B语言的优点(精练,接近硬件),又克服了它们的缺点(过于简单、无数据类型等),C语言的新特点主要表现在具有多种数据类型(如字符、数值、数组、结构体和指针等)。开发C语言的目的在于尽可能降低用它所写的软件对硬件平台的依赖程度,使之具有可移植性。<br>最初的C语言只是为描述和实现UNIX操作系统提供一种工作语言 而设计的。</p>
<p>1973年，Ken Thompson和D. M. Ritchie合作把UNIX的90%以上用C语言改写,即UNIX第5版。随着UNIX的广泛使用，C语言也迅速得到推广。</p>
<p>1978年，在Brian W.Kernighan和D. M. Ritchie合著的《The C programming Language》一书中介绍了C语言，这可以说是C语言的第一个标准，其后来成为了广泛使用的C语言基础版本。</p>
<p>1983年，美国国家标准协会（ANSI）成立了一个委员会，根据C语言之前的各个版本对C语言的发展和扩充制定了第一个C语言标准草案，在之前C语言的版本之上有了很大的发展。</p>
<p>在之后的十几年间，国际标准化组织ISO对C语言做了一些修订，直到1999年，ISO又对C语言标准进行修订，针对于应用的需要，在保留以前版本的C语言特征的基础上，新增了一些功能，此次修正被称为C语言的C99版本。之后的几年又先后进行了两次技术的修正。</p>
<h2 id="4、C语言的特点"><a href="#4、C语言的特点" class="headerlink" title="4、C语言的特点"></a>4、C语言的特点</h2><p>C语言原本是专用于编写系统软件而设计的，许多大型软件基本都是用的C语言进行编写，其具有以下特点：</p>
<p>①C语言语法简洁、结构紧凑，使用较为灵活、方便，程序编写格式较为自由。<br>②数据类型丰富，包括整型、浮点型、字符型、数组类型指针类型和共用体类型等，C99又扩充了复数浮点型、超长整型和布尔类型等。特别是指针类型，丰富多样，使用非常灵活，可以用来实现多种复杂的数据结构。<br>③运算符类型极其丰富，包含的范围很广泛，表达式类型多样化，灵活使用运算符能够实现许多复杂的运算。<br>④C语言是结构化和模块化的编程语言。具有结构化控制语句，以函数为基本单位，易于实现模块化编程。<br>⑤语法限制不太严格，程序设计自由度大。如：对数组的下标越界不会进行检查，由程序员自己保证程序的正确。<br>⑥C语言能允许直接访问物理地址，能进行位(bit)操作，能实现汇编语言的大部分功能，可以直接对硬件进行操作。<br>⑦用C语言编写的程序可移植性好，C编译系统比较简洁，几乎在所有计算机系统中都可以使用C语言。<br>⑧生成目标代码质量高，程序执行效率高，是最接近于汇编语言执行效率的高级语言。</p>
<p>由于C语言具备以上特点，使得C语言得到了广泛的应用，除了编写系统软件以外，许多应用软件也是用的C语言进行编写。</p>
<h1 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h1><h2 id="1、数据的表现形式"><a href="#1、数据的表现形式" class="headerlink" title="1、数据的表现形式"></a>1、数据的表现形式</h2><p> 在计算机高级语言中，数据有两种表现形式：常量和变量。</p>
<h3 id="1-1、常量"><a href="#1-1、常量" class="headerlink" title="1.1、常量"></a>1.1、常量</h3><p>在程序运行过程中，其值不能被改变的量称为常量。例如：数字1、2、3、0.1、3.14和字母’a’、’b’等。数值常量就是数学中的常数。</p>
<p>常用的常量有以下几类：</p>
<p>（1）整型常量</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">10000</span> , <span class="number">0</span> , <span class="number">-100</span> , <span class="number">056</span> , <span class="number">0xAB</span>;	<span class="comment">//整型常量</span></span><br></pre></td></tr></table></figure></div>

<p>（2）实型常量</p>
<p>有两种表示形式：</p>
<p>①十进制小数形式</p>
<p>由数字和小数点组成。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">123.456</span> , <span class="number">0.789</span> , <span class="number">-12.34</span> , <span class="number">0.0</span> , <span class="number">10.0</span></span><br></pre></td></tr></table></figure></div>

<p>②指数形式</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">12.34e3</span>;	<span class="comment">//表示12.34*10^3，也就是12.34乘以10的3次方</span></span><br><span class="line"><span class="number">-67.89e-6</span>;	<span class="comment">//表示-67.89*10^-6，也就是-67.89乘以10的-6次方</span></span><br></pre></td></tr></table></figure></div>

<p>由于计算机输入或输出时无法表示上标和下标，所以规定以字母e或E代表以10为底的指数，需要注意的是e和E之前必须要有数字，且e和E后面必须为整数，不能写成e4、12e2.5等这种形式。</p>
<p>（3）字符常量：有两种形式的字符常量</p>
<p>①普通字符常量：用单引号括起来的一个字符。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">’a’ , ’B’ , ’<span class="number">3</span>’ , ’@’ , ’#’;</span><br></pre></td></tr></table></figure></div>

<p>不能写成’ab’或’12’，一个单引号内只会包含一个有效字符。注意单引号只是个界限符，字符是指用单引号括起来的符号，不包括单引号。字符型在内存中是以ASCII码形式存储的，例如字符’a’的ASCII码的十进制为97，在存储单元中存放的是97的二进制补码形式。</p>
<p>②转义字符：C语言中还有一种特殊形式的字符常量，是以字符\开头的字符序列。例如：’\n’换行、’\t’水平制表符（tab）、’\’’单引号、’\”’双引号、’?’问号、’\’斜杠、’\a’警告声音提示、’\b’退格删除符、’\f’换页符、’\r’回车、’\v’垂直制表符、’\o’八进制形式、’\x’十六进制形式等。转义字符的意思是将’\’后面的字符转换成另外的意义。如’\n’中的n不代表字母n，而是作为换行符。</p>
<p>（4）字符串常量：如”ABC”、”123”等，用双引号把若干个字符括起来，字符串不包括双引号。注意不能写成’abc’、’123’，单引号内只能包含一个字符，表示字符常量；双引号内可以包含一串字符，表示字符串常量。</p>
<p>（5）符号常量：用#define指令指定用一个符号代表一个常量。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926	<span class="comment">//注意末尾不需要分号</span></span></span><br></pre></td></tr></table></figure></div>

<p>也就是用PI代替3.1415926，意思很简单，代表圆周率。</p>
<p>使用符号常量可以让常量在使用时含义更清楚，并且在需要改变程序中多处用到了同一个常量的时候，能够做到“一改全改”。</p>
<p>注意不要把符号常量误认为变量。</p>
<p>（6）地址常量：每一个常量、变量、数组和函数的地址在程序运行期间是不能够改变的，称为地址常量。</p>
<h3 id="1-2、变量"><a href="#1-2、变量" class="headerlink" title="1.2、变量"></a>1.2、变量</h3><h4 id="1-2-1、变量的基本概念"><a href="#1-2-1、变量的基本概念" class="headerlink" title="1.2.1、变量的基本概念"></a>1.2.1、变量的基本概念</h4><p>变量就是在程序运行中，值可以改变的量。</p>
<p>变量代表一个有名字的、具有特定属性的一个存储单元，可以用来存储数据，也就是变量的值。</p>
<p>变量必须先定义后使用。变量名的命名规则应符合标识符命名规则。</p>
<h4 id="1-2-2、标识符的命名规则"><a href="#1-2-2、标识符的命名规则" class="headerlink" title="1.2.2、标识符的命名规则"></a>1.2.2、标识符的命名规则</h4><p>什么是标识符？</p>
<p>标识符用来给我们所定义的变量、符号常量、函数、数组和类型名等命名，或者说标识和区分它们，标识符命名规则：只能由字母、数字、下划线’_’组成，并且只能由字母和下划线开头。同一个作用域范围内定义的标识符不允许重名，不允许是关键字。</p>
<p>如下列的合法标识符可以作为变量名：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">type,CLass,sum,student_name,day,point1_2_3,_10,n1,temp</span><br></pre></td></tr></table></figure></div>

<h4 id="1-2-3、变量的定义"><a href="#1-2-3、变量的定义" class="headerlink" title="1.2.3、变量的定义"></a>1.2.3、变量的定义</h4><p>定义变量的基本格式：数据类型名  变量名;<br>如：定义一个整型变量a</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;	<span class="comment">//int为数据类型名，a为变量名</span></span><br></pre></td></tr></table></figure></div>

<h2 id="2、基本数据类型"><a href="#2、基本数据类型" class="headerlink" title="2、基本数据类型"></a>2、基本数据类型</h2><h3 id="2-1、数据类型的基本概念"><a href="#2-1、数据类型的基本概念" class="headerlink" title="2.1、数据类型的基本概念"></a>2.1、数据类型的基本概念</h3><p> 所谓的类型，就是对数据分配存储单元的安排，包括存储单元的长度（占多少个字节）以及数据的存储形式。不同类型分配不同的长度和存储形式，我们将int、float、char等称为类型名称，或者数据类型关键字。</p>
<p>为什么在用计算机运算时，要指定数据类型呢？</p>
<p>数学运算与计算机运算的区别。</p>
<p>在数学中，数值是不分类型的，数值的运算是绝对精准的，例如1&#x2F;3的值是0.333333333……（循环小数）。数学是一门研究抽象的学科，数和数的运算都是抽象的。而在计算机中，数据是存放在存储单元中的，它是具体存在的。并且存储单元是由有限的字节构成的，每一个存储单元中存放数据的范围是有限的，不可能存放“无穷大”或者“无限”的数，也不能存放循环小数了。例如计算和输出1&#x2F;3，以%f格式输出得到的结果是0.333333，只有6位小数，而不是无限循环小数。</p>
<p>1字节&#x3D;8位（【0000 0000】）</p>
<p>C99还新增了布尔型（bool，0&#x2F;1）和双长整型（long long int）两种基本整型数据类型。</p>
<h3 id="2-2、基本数据类型简介"><a href="#2-2、基本数据类型简介" class="headerlink" title="2.2、基本数据类型简介"></a>2.2、基本数据类型简介</h3><p>各种基本数据类型所占用的存储空间和取值范围如下所示：</p>
<p>（1）整型</p>
<p>整型用于存储整数。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">大小（字节）</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td align="center">无符号整型</td>
<td align="center">unsigned int</td>
<td align="center">4</td>
<td align="center">0 ~ 2^32-1</td>
</tr>
<tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">-2^15 ~ 2^15-1</td>
</tr>
<tr>
<td align="center">无符号短整型</td>
<td align="center">unsigned short</td>
<td align="center">2</td>
<td align="center">0 ~ 2^16-1</td>
</tr>
<tr>
<td align="center">长整型</td>
<td align="center">long</td>
<td align="center">4</td>
<td align="center">-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td align="center">无符号长整型</td>
<td align="center">unsigned long</td>
<td align="center">4</td>
<td align="center">0 ~ 2^32-1</td>
</tr>
<tr>
<td align="center">双长整型</td>
<td align="center">long long</td>
<td align="center">8</td>
<td align="center">-2^63 ~ 2^63-1</td>
</tr>
<tr>
<td align="center">无符号双长整型</td>
<td align="center">unsigned long long</td>
<td align="center">8</td>
<td align="center">0 ~ 2^64-1</td>
</tr>
</tbody></table>
<p>可以用求字节运算符sizeof求出数据类型所占字节数：sizeof(数据类型);</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>);	<span class="comment">//求int类型所占字节数</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);	<span class="comment">//求unsigned long类型所占字节数</span></span><br></pre></td></tr></table></figure></div>

<p>（2）字符型</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">大小（字节）</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">1</td>
<td align="center">ASCII码表</td>
</tr>
</tbody></table>
<p>ASCII码表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/C%E8%AF%AD%E8%A8%80%E4%B9%A6%E7%B1%8D%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90%5CASCII%E7%A0%81%E8%A1%A8.jpg"
                     
                ></p>
<p>字母：大写字母A<del>Z和小写字母a</del>z；</p>
<p>数字：0~9；</p>
<p>专用字符：！	”	#	’	&amp;	%	*	(	)	+	-	&#x2F;	_	^	{	}	[	]	**	~	&lt;	&gt;	&#x3D;	,	.	?	;	:	|	~	&#96;	等；</p>
<p>空格符：空格’ ’、水平垂直制表符’\t’、换行符、换页符等。</p>
<p>不能显示的字符：空（NULL）字符’\0’、警告字符’\a’、退格符’\b’、回车符’\r’等。</p>
<p>特殊情况：当字符存储其他文字字符时，其占两个或多个字节，如：char ch&#x3D;’中’；</p>
<p>中文字符实际上占2个字节，内存的补正（补齐）会把超过一个字节但不超过四个字节的，统一按照4个字节处理。</p>
<p>（3）浮点型</p>
<p>浮点型数据是用来表示具有小数点的实数。</p>
<p>为什么在C语言中把实数称为浮点数呢？</p>
<p>在C语言中，实数是以指数的形式存放在存储单元里的。一个实数表示为指数可以有不止一种形式，但它们表示同一个数值。<br>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159</span>可以表示为<span class="number">3.14159</span>*<span class="number">10</span>^<span class="number">0</span>，<span class="number">0.314159</span>*<span class="number">10</span>^<span class="number">1</span>，<span class="number">0.0314159</span>*<span class="number">10</span>^<span class="number">2</span>，<span class="number">31.4159</span>*<span class="number">10</span>^<span class="number">-1</span>，<span class="number">314.159</span>*<span class="number">10</span>^<span class="number">-2</span>，<span class="number">3141.59</span>*<span class="number">10</span>^<span class="number">-3</span>等</span><br></pre></td></tr></table></figure></div>

<p>以此看来，小数点的位置是可以在314159几个数字之间和之前或之后加0浮动的，只要在小数点浮动的同时改变指数的值，就可以保证它的大小不会被改变。由于小数点的位置可以浮动，所以实数又称为浮点数。</p>
<p>在指数形式的多种表示方式中，把小数点前的数字为0和小数点后的数字不为0的表示形式称为规范的指数形式，在程序以指数形式输出一个实数时，必然以规范化的指数形式输出，如123.456的规范形式为1.23456e+2。</p>
<p>C语言中的浮点型</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">大小（字节）</th>
<th align="center">取值范围（绝对值）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单精度浮点型</td>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">0以及1.2*10^-38 ~ 3.4 *10^38</td>
</tr>
<tr>
<td align="center">双精度浮点型</td>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">0以及1.2*10^-308 ~ 3.4 *10^308</td>
</tr>
<tr>
<td align="center">长双精度浮点型</td>
<td align="center">long double</td>
<td align="center">8</td>
<td align="center">0以及1.2*10^-308 ~ 3.4 *10^308</td>
</tr>
</tbody></table>
<h3 id="2-3、确定常量的类型"><a href="#2-3、确定常量的类型" class="headerlink" title="2.3、确定常量的类型"></a>2.3、确定常量的类型</h3><p>在C语言中，不仅变量有类型，常量也是有类型的。为什么要把常量分为不同的类型呢？在程序中出现的常量是要存放在计算机中的存储单元中的，这就必须确定分配给它多少字节，按什么方式存储。例如，程序中有整数16，在编译器中会分配给它4个字节，按补码形式存储。</p>
<p>怎样确定常量的类型呢？从常量的表示形式即可判定其类型。</p>
<p>（1）符号常量：对于符号常量来说很简单，只要看到由单引号括起来的单个字符或转义字符就是字符常量,以ACSII码值进行存储，占1个字节。</p>
<p>（2）整型常量：不带小数点的数值是整型常量，但要注意其有效范围。如果某系统中为整型数据分配2个字节，其表示范围为-32768<del>32767（-2^16</del>2^16-1），如果在程序中出现数值常量12345，则系统把它作为int型处理，用4个字节存放。如果出现数值常量45678，由于其大于32767，2个字节放不下，所以系统就会把它作为长整型（long int）进行处理，分配4个字节。以此类推，如果出现的数值常量超过4个字节的表示范围的话，系统就会把它当作双长整型（long long int）。<br>在整数的末尾加上大写字母L或小写字母l，则表示它是长整型（long int）。例如666l、123L等。在VS编译环境中int和long int数据都分配4个字节，因此没有必要用long int。如果在整数的末尾加上大写字母LL或小写字母ll，则表示它是长长整型（long long int），其在内存中占8个字节。</p>
<p>（1）浮点型常量：凡是以小数形式或指数形式出现的实数，都是浮点型常量，在内存中以指数形式存储。如：0、10为整型常量，0.0、10.0是浮点型常量。注意：对于浮点型常量，编译器默认是按双精度进行处理的。例如：float a&#x3D;3.14159；在编译时，给float变量分配4个字节，而对于浮点型常量3.14159来说，则是按double型处理，分配8个字节，编译器有时会发出“警告”。这种警告一般不会影响程序运行结果，但是会影响程序运行结果的精确度。<br>可以在常量的末尾加一个F或f，强制指定常量的类型为单精度。如果在实型常量的末尾加一个L或l，就是指定此常量为long double类型。</p>
<p>注意：区分类型与变量、变量与常量的概念</p>
<h2 id="3、格式化输入输出函数"><a href="#3、格式化输入输出函数" class="headerlink" title="3、格式化输入输出函数"></a>3、格式化输入输出函数</h2><h3 id="3-1、有关数据输入和输出的概念"><a href="#3-1、有关数据输入和输出的概念" class="headerlink" title="3.1、有关数据输入和输出的概念"></a>3.1、有关数据输入和输出的概念</h3><p>从之前的每个程序看来，几乎每一个C程序都包含输入和输出。因为程序要进行运算，就必须给出数据，而运算的结果当然也需要输出了，便于人们应用。没有输出的程序是没有意义的，输入输出是程序中最基本的操作之一。<br>讨论程序的输入和输出时首先要注意：所谓的输入输出是以计算机主机为主而言的。<br>计算机向输出设备（如显示器、打印机等）输出数据称为输出，从输入设备（如键盘、磁盘、光盘、扫描仪等）向计算机输入数据称为输入。<br>C语言函数库中提供了一批“标准输入输出函数”，它是以标准的输入输出设备（一般为终端设备）为输入输出对象的。其中有：printf,scanf,putchar,getchar,puts,gets等函数。在使用这些库函数时，要在程序文件的开头用预处理指令#include把相关头文件加载进本程序中，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、用printf函数输出数据（格式化输出函数）"><a href="#3-2、用printf函数输出数据（格式化输出函数）" class="headerlink" title="3.2、用printf函数输出数据（格式化输出函数）"></a>3.2、用printf函数输出数据（格式化输出函数）</h3><p>printf函数的一般格式为：</p>
<p>printf(格式控制,输出列表);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(“%d,%c\n”,n,c);</span><br></pre></td></tr></table></figure></div>

<p>括号内包括两个部分：</p>
<p>①格式控制</p>
<p>格式控制是用双引号括起来的一个字符串，称为“转换控制字符串”，简称“格式字符串”。</p>
<p>它包括两个信息：</p>
<p>●格式声明：由%和格式字符组成，用作将输出的数据转换为指定的格式然后输出。格式声明符总是由‘%’字符开始的。</p>
<p>常用的格式声明符有：</p>
<p>%d（十进制），%o（八进制），%x（十六进制），%u（无符号十进制），%c（单个字符），</p>
<p>%s（字符串），%f（单精度），%lf（双精度），%e（科学计数法），%i（自适应整数类型），%g（自适应浮点类型）。</p>
<p>●普通字符：即需要在输出时原样输出的字符。</p>
<p>如：\n、\t、空格、逗号等。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“a=%d\n”,a);		<span class="comment">//这里的a=和\n是原样输出的：a=1’\n’</span></span><br></pre></td></tr></table></figure></div>

<p>②输出列表</p>
<p>输出列表就是程序需要输出的一些数据，可以是常量、变量或表达式。</p>
<p>格式化输出函数printf是个函数，所以“格式控制字符串”和“输出列表”实际上都是函数的参数。</p>
<p>printf函数的一般形式可以表示为：printf(“参数1”,参数2,参数3,…,参数n);</p>
<p>参数1是格式控制字符串，参数2~参数n是所需要输出的数据。</p>
<p>我们还可以自定义输出的分隔符和输出的格式。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“%d %c %f\n”,a,b,c);</span><br><span class="line"><span class="built_in">printf</span>(“%d,%c,%f\n”,a,b,c);</span><br><span class="line"><span class="built_in">printf</span>(“%d\t%c\t%f\n”,a,b,c);</span><br></pre></td></tr></table></figure></div>

<p>%4d和%5.2f中的4和5.2是在格式声明中用来指定输出数据的域宽（所占列数）的，如%6d，是指定输出的整型数据占6列，%8.3f，是指输出的浮点型数据总共占8列，其中小数占3列，小数点占1列。还可以在域宽数字前加一个’-’号，用于使输出左对齐。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“%<span class="number">-4</span>d\t%<span class="number">5.2f</span>\n”,a,b);</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3、用scanf函数输入数据（格式化输入函数）"><a href="#3-3、用scanf函数输入数据（格式化输入函数）" class="headerlink" title="3.3、用scanf函数输入数据（格式化输入函数）"></a>3.3、用scanf函数输入数据（格式化输入函数）</h3><p>scanf函数的一般格式为：</p>
<p>scanf(格式控制,地址列表);</p>
<p>其中“格式控制”的含义与printf函数相同。“地址列表”是由若干个地址组成的列表，可以是变量的地址，或者是字符串的首地址。</p>
<p>使用格式化输入函数scanf时，需要注意以下几点：</p>
<p>①函数的地址列表是以变量的地址作为参数的时候，变量名前面必须加一个取地址符号’&amp;’，用于取此变量的地址，否则会出错。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%d %f %c”,a,b,c);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></div>

<p>②如果在“格式化控制字符串”中除了格式声明符以外还有其他字符，则应在输入数时在对应位置上输入与这些字符对应的相同的字符。</p>
<p>如有</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“a=%d,b=%f,c=%c”,&amp;a,&amp;b,&amp;c);</span><br></pre></td></tr></table></figure></div>

<p>要想输入数据1,2,3，则应输入：a&#x3D;1,b&#x3D;2,c&#x3D;3(回车)&#x2F;&#x2F;注意这里的a&#x3D;、b&#x3D;、c&#x3D;和逗号’,’</p>
<p>当然，其中的格式可以自己定义，如可以用空格’ ’隔开，还有输入时间的时分秒可以用’:’隔开等。</p>
<p>这里特别要注意字符和字符串的混合输入问题。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c%c%c&quot;</span>,&amp;a,&amp;b,&amp;c);<span class="comment">//输入x y z，则a=‘x’，b=‘ ’，c=‘y’；应连续输入xyz。</span></span><br></pre></td></tr></table></figure></div>

<p>输入输出函数数据之间的格式化间隔符（空格、TAB、回车或非法数据（“%d”，12A）等）</p>
<p>非格式间隔符（‘，’、‘！’等任意间隔符）；使用非格式间隔符时需要在输入的时候也用此间隔符分隔。</p>
<p>③在输入数值型数据时，如输入空格、回车、tab键或非法字符（除scanf格式声明中指定的）等不属于数值的字符，则认为此数据输入结束。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%d%c%f”,&amp;a,&amp;b,&amp;c);<span class="comment">//输入1234a567.8b9,a=1234,b=’a’,c=567.8 //&amp;取址符</span></span><br></pre></td></tr></table></figure></div>

<p>④scanf函数中double型数据需要使用%lf才能正常得到所输入的值，而输出可以用%f输出。</p>
<p>⑤在输入时也可以进行域宽控制</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%3d%4d&quot;</span>,&amp;a,&amp;b); <span class="comment">//输入12345678，则a=123，b=4567；</span></span><br></pre></td></tr></table></figure></div>

<p>注意各种类型的数据混合输入存在的问题</p>
<p>（1）字符型数据的输入和输出</p>
<p>①putchar字符输出函数</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>(a);<span class="comment">//输出字符型变量a的值</span></span><br><span class="line">	<span class="comment">//请区别对待putchar(&#x27;a&#x27;);</span></span><br></pre></td></tr></table></figure></div>

<p>②getchar字符输入函数</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch=getchar();	<span class="comment">//从键盘输入一个字符，存入字符变量ch中</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,getchar());	<span class="comment">//也可在格式化输出语句中直接输出所接收的字符</span></span><br></pre></td></tr></table></figure></div>

<p>由于scanf、getchar等输入函数没有从键盘接收到数据就不会继续执行，所以在程序中可以起到与system(“pause”);函数类似的暂停效果。</p>
<h1 id="三、运算符和表达式"><a href="#三、运算符和表达式" class="headerlink" title="三、运算符和表达式"></a>三、运算符和表达式</h1><h2 id="1、C语言运算符"><a href="#1、C语言运算符" class="headerlink" title="1、C语言运算符"></a>1、C语言运算符</h2><h3 id="1-1、C运算符的分类"><a href="#1-1、C运算符的分类" class="headerlink" title="1.1、C运算符的分类"></a>1.1、C运算符的分类</h3><p>C提供了各种各样不同作用的运算符，共分为以下几类：</p>
<p>（1）算术运算符			（+、-、*、&#x2F;、%、++、–）加、减、乘、除、模、自增、自减</p>
<p>（2）关系运算符			（&gt;、&lt;、&#x3D;&#x3D;、&gt;&#x3D;、&lt;&#x3D;、!&#x3D;） </p>
<p>（3）逻辑运算符			（&amp;&amp;与、||或、！非）</p>
<p>（4）位运算符				（左移&lt;&lt;、右移&gt;&gt;、按位非~、按位或|、按位异或^、按位与&amp;）</p>
<p>（5）赋值运算符			（&#x3D;及其扩展赋值运算符+&#x3D;、-&#x3D;、&#x3D;、&#x2F;&#x3D;、%&#x3D;等）等于</p>
<p>（6）条件运算符			（? :) (表达式1)?(表达式2):(表达式3) 三目运算符</p>
<p>（7）逗号运算符			（,）</p>
<p>（8）指针运算符			（*、&amp;）</p>
<p>（9）求字节数运算符	（sizeof()）</p>
<p>（10）强制类型转换符	((类型名))</p>
<p>（11）成员引用符			(.、-&gt;)结构体或共用体的成员引用符</p>
<p>（12）下标运算符			([])数组元素下标</p>
<p>（13）其他运算符			(如函数调用运算符()，复合语句符{}，语句结束符;等)</p>
<p>这一章主要讲解算术运算符、关系运算符、逻辑运算符、赋值运算符和条件运算符等常用运算符的运算规则，其他运算符待之后几章讲解相关知识点时再仔细讲解。</p>
<h3 id="1-2、运算符的操作数以及目数"><a href="#1-2、运算符的操作数以及目数" class="headerlink" title="1.2、运算符的操作数以及目数"></a>1.2、运算符的操作数以及目数</h3><p>①操作数：操作数是运算符操作的实体，是表达式的一个组成部分，它规定了运算指令中进行数值运算的量。</p>
<p>②目数：这些运算符根据其参与运算的操作数的个数不同，而分为了单目运算符、双目运算符和三目运算符。</p>
<p>有1个操作数的运算符为单目运算符，有2个操作数的运算符为双目运算符，有3个操作数的运算符为三目运算符。C语言中运算符的操作数最多为3个。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">x = <span class="number">1</span>; 	<span class="comment">//其中x和1分别是赋值运算符=的左操作数和右操作数，操作数为两个，所以=是双目运算符</span></span><br><span class="line">y = x++;	<span class="comment">//其中y和x++分别是赋值运算符=的左操作数和右操作数，而x又是自增运算符++的左操作数，所以++是单目运算符</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-3、运算符的优先级"><a href="#1-3、运算符的优先级" class="headerlink" title="1.3、运算符的优先级"></a>1.3、运算符的优先级</h3><p>C运算符的优先级及相关内容如下表所示：</p>
<p>通常意义上来说（广义）运算符的优先级大致为：单目&gt;双目&gt;三目。</p>
<p>优先级详细划分为：算术运算符&gt;关系运算符&gt;逻辑运算符&gt;条件运算符&gt;赋值运算符&gt;逗号运算符</p>
<h2 id="2、算术运算符"><a href="#2、算术运算符" class="headerlink" title="2、算术运算符"></a>2、算术运算符</h2><h3 id="2-1、基本的算术运算符"><a href="#2-1、基本的算术运算符" class="headerlink" title="2.1、基本的算术运算符"></a>2.1、基本的算术运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">举例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">正号运算符（单目运算符）</td>
<td align="center">+a</td>
<td align="center">a的值</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">负号运算符（单目运算符）</td>
<td align="center">-a</td>
<td align="center">a的算术负值</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘法运算符（双目运算符）</td>
<td align="center">a*b</td>
<td align="center">a和b的乘积</td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除法运算符（双目运算符）</td>
<td align="center">a&#x2F;b</td>
<td align="center">a除以b的商</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余运算符（双目运算符）</td>
<td align="center">a%b</td>
<td align="center">a除以b的余数</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">加法运算符（双目运算符）</td>
<td align="center">a+b</td>
<td align="center">a与b的和</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减法运算符（双目运算符）</td>
<td align="center">a-b</td>
<td align="center">a与b的差</td>
</tr>
</tbody></table>
<p>说明：</p>
<p>①由于键盘没有×号，运算符×以*代替。</p>
<p>②由于键盘没有÷号，运算符÷以&#x2F;代替（反斜杠）。（注意区分\斜杠）</p>
<p>③整数相除的结果仍为整数！如：-5&#x2F;3结果为-1（向0取整，舍去小数）。（5.0&#x2F;3&#x3D;1.666666）</p>
<p>④%（求余运算符）要求参加运算的运算对象（即操作数）为整数，结果也为整数。如8%6结果为2。（思考一下8.0%6&#x3D;？）</p>
<p>⑤除%以外运算符的操作数都可以是任何算术类型。</p>
<h3 id="2-2、自增、自减运算符"><a href="#2-2、自增、自减运算符" class="headerlink" title="2.2、自增、自减运算符"></a>2.2、自增、自减运算符</h3><p>++（自增运算符）、–（自减运算符）它们都属于单目运算符。</p>
<p>例如：</p>
<p>++i；–i；（在使用i之前，先使i的值加（减）1，先加减后使用）</p>
<p>i++；i–；（在使用i之后，使i的值加（减）1，先使用后加减）</p>
<p>粗略地看，++i和i++的作用都相当于i&#x3D;i+1。但是++i和i++的不同之处在于：++i是先执行i&#x3D;i+1，再使用i的值；而i++是先使用i的值，再执行i&#x3D;i+1。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>,j;</span><br><span class="line">j=++i;	<span class="comment">//i的值先+1变成2，再赋值给j，j的值为2</span></span><br><span class="line">j=i++;	<span class="comment">//先将i的值赋值给j，j的值为2，然后再将i的值+1变成3</span></span><br></pre></td></tr></table></figure></div>

<p>又例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">3</span>；</span><br><span class="line"><span class="built_in">printf</span>(“%d”,++i);	<span class="comment">//输出4，i=4</span></span><br><span class="line"><span class="built_in">printf</span>(“%d”,i++);	<span class="comment">//输出4，i=5</span></span><br></pre></td></tr></table></figure></div>

<p>注意：++和–运算符只能用于变量，而不能用于常量或表达式，如5++或–(i+j)等。</p>
<p>使用++和–的时候，会出现一种情况，如i+++j，是理解成(i++)+j呢？还是理解成i+(++j)呢？为了避免二义性，可以加一些“不必要的括号”，如(i++)+j。</p>
<h3 id="2-3、算术表达式与运算符的优先级和结合性"><a href="#2-3、算术表达式与运算符的优先级和结合性" class="headerlink" title="2.3、算术表达式与运算符的优先级和结合性"></a>2.3、算术表达式与运算符的优先级和结合性</h3><p>什么叫算术表达式呢？</p>
<p>用算术运算符和括号将运算对象（操作数）连接起来的、符合C语法规则的式子，就称为C语言算术表达式。运算对象包括常量、变量、函数等。例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">（a+b）*c/d<span class="number">-1.5</span>+<span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>C语言规定了运算符的优先级和结合性。</p>
<p>与数学运算符的优先级和结合性类似，乘、除、模（、&#x2F;、%）运算符的优先级要高于加减（+、-），结合方向都是“从左至右”，同一优先级的运算符，按结合性依次执行。</p>
<h3 id="2-4、不同类型数据间的混合运算"><a href="#2-4、不同类型数据间的混合运算" class="headerlink" title="2.4、不同类型数据间的混合运算"></a>2.4、不同类型数据间的混合运算</h3><p>在程序运行中，经常会遇到不同类型的数据进行运算，如6+8.8。如果一个运算符的两侧数据类型不同，则先自动进行类型转换，使二者具有同一种类型，然后进行运算。因此整型、实型、字符型数据间可以进行混合运算。</p>
<p>（1）+、-、*、&#x2F;运算的两个操作数进行运算，如果其中有一个数位float或double型，结果是double型，因为系统将所有float型数据都先转换为double型，然后进行运算的。</p>
<p>（2）如果是int型与float或double型数据进行运算，先把int型和float型数据转换为double型，然后再进行运算，结果为double型。</p>
<p>（3）字符型（char）数据与整型数据进行运算，就是把字符的ASCII码与整型数据进行运算。如：10+’A’，由于字符A的ASCII码为65，就相当于10+65，等于75，字符型数据可以直接与整型数据进行运算。如果字符型数据与实型数据进行运算，则将字符对应的ASCII码转换为double型数据，然后进行运算。</p>
<p>（4）整型（int）与无符号整型（unsigned）之间进行运算，以无符号整型为准，先把int型数据转换为unsigned型，然后再做运算。</p>
<p>以上转换是隐式类型转换，是编译系统自动完成的，用户不必过问。</p>
<p>例如：</p>
<p>以下表达式的值为多少？</p>
<p>10+’a’-3*2.5+5&#x2F;2-7%2&#x3D;107-7.5+2-1&#x3D;100.500000</p>
<p>例题：给定一个大写字母，要求输出其对应的小写字母。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>(ch+<span class="number">32</span>);</span><br></pre></td></tr></table></figure></div>



<h2 id="3、强制类型转换运算符"><a href="#3、强制类型转换运算符" class="headerlink" title="3、强制类型转换运算符"></a>3、强制类型转换运算符</h2><p>C语言中可以运用强制类型转换运算符将一个表达式转换成所需的类型。</p>
<p>强制类型转换的一般格式为：(类型名)(表达式)</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="type">double</span>)a	<span class="comment">//将变量a强制类型转换为double类型</span></span><br><span class="line">(<span class="type">int</span>)(x+y)	<span class="comment">//将表达式(x+y)的结果强制类型转换为int类型</span></span><br><span class="line">(<span class="type">float</span>)(<span class="number">5</span>%<span class="number">3</span>)<span class="comment">//将表达式(5%3)的结果强制类型转换为float类型</span></span><br><span class="line">(<span class="type">int</span>)<span class="number">6.8</span>%<span class="number">3</span>	<span class="comment">//将小数6.8强制类型转换为int类型，然后再于整数3求余</span></span><br></pre></td></tr></table></figure></div>

<p>注意：表达式应该用括号括起来。</p>
<p>如果写成：(int)x+y，则只是将x转换成整型，然后再与y相加。如果想要将表达式x+y的值转换为整型，应写成(int)(x+y)。</p>
<p>强制类型转换后的值只是临时值，不对数据本身操作。</p>
<h2 id="4、关系运算符"><a href="#4、关系运算符" class="headerlink" title="4、关系运算符"></a>4、关系运算符</h2><p>关系运算符是一个双目运算符，用于比较两个操作数之间的大小关系，其中包含大于（&gt;）、小于（&lt;）、等于（&#x3D;&#x3D;）、大于等于（&gt;&#x3D;）、小于等于（&lt;&#x3D;）、不等于（!&#x3D;）这些运算符，运算结果是一个逻辑值（真&#x2F;假）。</p>
<p>逻辑值：0为假，非0为真，如：1、2、100、-1、-10、’a’、12.3 等数据的逻辑值为真，逻辑值为真的表达式结果默认为1，也就是1代表真，只有0代表逻辑假。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关系运算符（&gt;、&lt;、==、&gt;=、&lt;=、!=）</span></span><br><span class="line"><span class="comment">//运算结果为逻辑值：0表示假，非0表示真（1）</span></span><br><span class="line"><span class="number">1</span>&lt;=<span class="number">2</span>;	<span class="comment">//结果为真（1），因为1小于等于2，条件满足</span></span><br><span class="line"><span class="number">1</span>&gt;<span class="number">3</span>	<span class="comment">//结果为假（0），因为1大于3，条件不满足</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">5</span> != <span class="number">5</span>);	<span class="comment">//结果为假（0），因为5不等于5，条件为假</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a&lt;=b);	<span class="comment">//结果为真（1），a小于b条件满足</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a==b);	<span class="comment">//结果为假（0），a等于b条件不满足</span></span><br></pre></td></tr></table></figure></div>



<h2 id="5、逻辑运算符"><a href="#5、逻辑运算符" class="headerlink" title="5、逻辑运算符"></a>5、逻辑运算符</h2><p>逻辑运算符用于连接多个条件语句，判断多个条件值联合的结果，其中包含与(&amp;&amp;)、或(||)、非(!)三种运算。</p>
<p>与、或、非运算的基本使用如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&amp;&amp;（与运算）：双目运算符，用于连接两个表达式，相当于并且的意思</span></span><br><span class="line"><span class="comment">运算规则：同真为真，否则为假</span></span><br><span class="line"><span class="comment">只有&amp;&amp;运算符两边操作数的逻辑值同时为真，整个逻辑表达式的值才为真，否则整个表达式的值为假</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">1</span>&lt;<span class="number">2</span> &amp;&amp; <span class="number">5</span>&lt;<span class="number">4</span>);	<span class="comment">//1&lt;2并且5&lt;4，其中1&lt;2为真，5&lt;4为假，整个表达式的值为假</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">1</span>&lt;<span class="number">2</span> &amp;&amp; <span class="number">5</span>!=<span class="number">4</span>);	<span class="comment">//1&lt;2并且5!=4，其中1&lt;2为真，5!=4为真，整个表达式的值为真</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*||（或运算）：双目运算符，用于连接两个表达式，相当于或者的意思</span></span><br><span class="line"><span class="comment">运算规则：同假为假，否则为真</span></span><br><span class="line"><span class="comment">只有||运算符两边的操作数的逻辑值同时为假，整个逻辑表达式的值才为假，否则整个表达式的值为真</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0</span> || <span class="number">-1</span>);	<span class="comment">//其中-1的逻辑值为真，整个表达式的结果为真（1）</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x || y);</span><br><span class="line"><span class="comment">//x和y的值都为0，也就是逻辑值都为假，所以整个逻辑表达式 x || y的值就为假，输出结果为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">!（非运算）：单目运算符，用于将之后的表达式的逻辑值取反</span></span><br><span class="line"><span class="comment">运算规则：真变假，假变真,（取反）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">-2</span>);	<span class="comment">//其中(-2)的逻辑值为真，所以(!-2)的逻辑值为假，输出结果为0</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !n);	<span class="comment">//其中n的逻辑值为假，所以(!n)的逻辑值为真，输出结果为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;&amp;和||存在的短路运算：</span></span><br><span class="line"><span class="type">int</span> g = <span class="number">1</span>, h = <span class="number">1</span>;</span><br><span class="line">++g || ++h;	<span class="comment">//||的短路运算：前一个条件为真，之后的条件不管为真还是为假都不执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>, g, h);	<span class="comment">//结果为：1	1</span></span><br><span class="line"></span><br><span class="line">g = <span class="number">1</span>, h = <span class="number">1</span>;</span><br><span class="line">--g &amp;&amp; --h;	<span class="comment">//&amp;&amp;的短路运算：前一个条件为假，之后的条件不管为真还是为假都不执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>, g, h);	<span class="comment">//结果为：0	1</span></span><br></pre></td></tr></table></figure></div>

<p>与、或、非运算的操作数可以是int、float、char等多种数据类型的表达式。</p>
<h2 id="6、条件运算符"><a href="#6、条件运算符" class="headerlink" title="6、条件运算符"></a>6、条件运算符</h2><p>条件运算符（? :）用于条件判断。</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">(表达式<span class="number">1</span>)?(表达式<span class="number">2</span>):(表达式<span class="number">3</span>);</span><br></pre></td></tr></table></figure></div>

<p>运算规则：首先判断表达式1的逻辑值，如果表达式1的逻辑值为真，则执行冒号’:‘之前的表达式2，整个条件表达式的值为表达式2的值；如果表达式1的逻辑值为假，则执行冒号’:‘之后的表达式3，整个条件表达式的值为表达式3的值。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出两个数中的最大值</span></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x &gt; y ? x : (x == y ? x : y));</span><br><span class="line">	<span class="comment">//判断表达式(x&gt;y)的逻辑值，如果为真则整个表达式的值为冒号之前的x的值</span></span><br><span class="line">	<span class="comment">//否则执行(x == y ? x : y)，这又是一个含有条件运算符的条件表达式</span></span><br><span class="line">	<span class="comment">//判断(x == y)的值，如果为真则整个表达式的值为x，否则为y</span></span><br></pre></td></tr></table></figure></div>



<h2 id="7、位运算符"><a href="#7、位运算符" class="headerlink" title="7、位运算符"></a>7、位运算符</h2><p>位运算符是针对数据的二进制进行运算的，其中包含左移”&lt;&lt;”、右移”&gt;&gt;”、按位非”~”、按位或”|”、按位异或”^”、按位与”&amp;”这六种位运算，其只能对整型数据操作，运算规则如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左移运算符&quot;&lt;&lt;&quot;，是一个双目运算符</span></span><br><span class="line"><span class="comment">基本格式：整数&lt;&lt;n</span></span><br><span class="line"><span class="comment">其用于将一个整数的二进制向左移动n个二进制位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a&lt;&lt;<span class="number">2</span>);	<span class="comment">//输出结果为：40，相当于乘以2的2次方</span></span><br><span class="line"><span class="comment">//将变量a的值左移两个二进制位并输出，a本身的值不变</span></span><br><span class="line"><span class="comment">//a等于10，10的二进制为00001010，左移2位就是00101000，转换为十进制为40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">右移运算符&quot;&gt;&gt;&quot;，是一个双目运算符，与左移类似</span></span><br><span class="line"><span class="comment">基本格式：整数&gt;&gt;n</span></span><br><span class="line"><span class="comment">用于将一个整数的二进制向右移动n个二进制位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">a&gt;&gt;=<span class="number">3</span>;	<span class="comment">//a=1,相当于a除2的3次方,</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);	<span class="comment">//输出结果为：1</span></span><br><span class="line"><span class="comment">//相当于a=a&gt;&gt;2，将变量a的值右移两个二进制位后赋值给本身，a本身的值变为40</span></span><br><span class="line"><span class="comment">//a等于10，10的二进制为00001010，右移3位就是00000001，转换为十进制为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按位非&quot;~&quot;，是一个单目运算符</span></span><br><span class="line"><span class="comment">基本格式：~整数</span></span><br><span class="line"><span class="comment">用于将一个整数的二进制各个位数取反</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">short</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,~b);	<span class="comment">//输出结果为：-21</span></span><br><span class="line"><span class="comment">//b等于20，20的二进制为：00000000 00010100，各位取反为：11111111 11101011</span></span><br><span class="line"><span class="comment">//由于计算机内是用补码做运算的，所以负数的补码转换成原码后为：10000000 00010100，结果为-21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按位或&#x27;|&#x27;，双目运算符</span></span><br><span class="line"><span class="comment">基本格式：整数|整数</span></span><br><span class="line"><span class="comment">用于将两个整数的二进制相或，遵循有1为1，否则为0的规则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a|b);	<span class="comment">//结果为30</span></span><br><span class="line">	<span class="comment">// a:	00000000 00001010</span></span><br><span class="line">	<span class="comment">// b:	00000000 00010100</span></span><br><span class="line">	<span class="comment">// a|b:	00000000 00011110</span></span><br><span class="line">	<span class="comment">// 相同二进制位相或，有1为1，否则为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按位与&#x27;&amp;&#x27;，双目运算符</span></span><br><span class="line"><span class="comment">基本格式：整数&amp;整数</span></span><br><span class="line"><span class="comment">用于将两个整数的二进制相与，遵循有0为0，否则为1的规则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a&amp;b);	<span class="comment">//结果为10</span></span><br><span class="line">	<span class="comment">// a:	00000000 00001010</span></span><br><span class="line">	<span class="comment">// b:	00000000 00011110</span></span><br><span class="line">	<span class="comment">// a&amp;b:	00000000 00001010</span></span><br><span class="line">	<span class="comment">// 相同二进制位相与，有0为0，否则为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按位异或&#x27;^&#x27;</span></span><br><span class="line"><span class="comment">基本格式：整数^整数</span></span><br><span class="line"><span class="comment">用于将两个整数的二进制相异或，遵循相同为0，相异为1的规则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a^b);	<span class="comment">//结果为20</span></span><br><span class="line">	<span class="comment">// a:	00000000 00001010</span></span><br><span class="line">	<span class="comment">// b:	00000000 00011110</span></span><br><span class="line">	<span class="comment">// a^b:	00000000 00010100</span></span><br><span class="line">	<span class="comment">// 相同二进制位相异或，相同为0，相异为1</span></span><br></pre></td></tr></table></figure></div>



<h2 id="8、表达式和C语句"><a href="#8、表达式和C语句" class="headerlink" title="8、表达式和C语句"></a>8、表达式和C语句</h2><h3 id="8-1、表达式和语句的基本概念"><a href="#8-1、表达式和语句的基本概念" class="headerlink" title="8.1、表达式和语句的基本概念"></a>8.1、表达式和语句的基本概念</h3><p>一个C语言程序由若干个源程序文件组成，一个源文件由若干个函数和预处理指令以及全局变量声明部分组成。如一个函数有数据声明部分和执行语句，其都是由语句组成的。语句的作用使向计算机系统发出操作指令，要求执行相应的操作。一个C语句经过编译后产生若干条机器指令。<br>C程序的基本组成单位是函数，函数又由一条或多条C语句构成，而C语句又是多个表达式的组合。</p>
<h3 id="8-2、逗号表达式"><a href="#8-2、逗号表达式" class="headerlink" title="8.2、逗号表达式"></a>8.2、逗号表达式</h3><p>逗号表达式是一类特殊的表达式，其是由逗号运算符隔开的多个表达式的组合，逗号起到分隔的作用。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,c=<span class="number">30</span>;</span><br><span class="line">	<span class="comment">//逗号隔开的多个相同类型变量的定义个初始化赋值</span></span><br></pre></td></tr></table></figure></div>

<p>逗号分隔的多个表达式是依次从左至右执行的，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">a=<span class="number">1</span>,b=<span class="number">2</span>,c=a+b;</span><br><span class="line">	<span class="comment">//这里是先执行a=1，再执行b=2，最后才执行c=a+b,c的值为3</span></span><br></pre></td></tr></table></figure></div>

<p>整个逗号表达式的值以逗号分隔的最后一个表达式为准，如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a,b,c,d;</span><br><span class="line">d=(a=1,b=2,c=a+b);</span><br><span class="line">	//这里d的值为逗号分隔的最后一个表达式的值，也就是c=a+b的值，相当于d=c，d的值为3</span><br><span class="line"></span><br><span class="line">d=a=1,b=2,c=a+b;</span><br><span class="line">	//这里d的值为第一个表达式的值，d的值为1</span><br></pre></td></tr></table></figure></div>



<h3 id="8-3、最基本的语句——赋值语句"><a href="#8-3、最基本的语句——赋值语句" class="headerlink" title="8.3、最基本的语句——赋值语句"></a>8.3、最基本的语句——赋值语句</h3><p>在C语言中最常用的语句就是赋值语句和输入输出语句了。其中最基本的就是赋值语句，程序中的计算功能大部分是由赋值语句实现的，几乎每个有实用价值的程序都包括赋值语句。</p>
<p>（1）赋值运算符’&#x3D;’</p>
<p>与数学中的’&#x3D;’不同的是，在C语言中，’&#x3D;’为赋值运算符，它是用来将一个数据赋值给一个变量的。如a&#x3D;1;的作用是执行一次赋值操作（赋值运算），把1赋值给变量a。也可以将一个表达式的值赋值给一个变量，如a&#x3D;1+2;a&#x3D;b+c+1;等。</p>
<p>（2）复合的赋值运算符</p>
<p>在赋值运算符&#x3D;之前加上其他运算符，可以构成复合的运算符。</p>
<p>主要有：+&#x3D;、-&#x3D;、&#x3D;、&#x2F;&#x3D;、%&#x3D;这几种复合赋值运算符。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">x+=y;	<span class="comment">//相当于：x=x+y;</span></span><br><span class="line">x=y;	<span class="comment">//相当于：x=x*y;</span></span><br><span class="line">x+=y+<span class="number">1</span>;	<span class="comment">//相当于x+=(y+1);	x=x+(y+1);</span></span><br><span class="line">x=y+<span class="number">1</span>;	<span class="comment">//相当于x=(y+1);	x=x(y+1);</span></span><br></pre></td></tr></table></figure></div>

<p>（3）赋值表达式和赋值语句</p>
<p>右值和左值</p>
<p>左值应该为可修改的变量，右值可以为任意符合规范且赋值有效的表达式。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span>；</span><br><span class="line">a=b=c=<span class="number">1</span>;		<span class="comment">//a=1;b=1;c=1;</span></span><br><span class="line">a=(b=<span class="number">1</span>)+(c=<span class="number">2</span>);	<span class="comment">//a=3;b=1;c=2;</span></span><br><span class="line">a=(b=<span class="number">1</span>)(c=<span class="number">2</span>);</span><br></pre></td></tr></table></figure></div>

<p>赋值运算符是按照“从右至左”的结合顺序运行的。</p>
<p>（4）变量赋初值</p>
<p>在变量定义时对变量赋值就称为变量赋初值，也称为变量的初始化赋值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="8-4、C语句的分类"><a href="#8-4、C语句的分类" class="headerlink" title="8.4、C语句的分类"></a>8.4、C语句的分类</h3><p>C语句分为以下5类：</p>
<p>（1）表达式语句</p>
<p>表达式语句是由一个表达式加一个分号构成，最典型的是由赋值表达式构成的赋值语句，例如：a&#x3D;3是赋值表达式，而a&#x3D;3;是赋值语句。还有由逗号表达式构成语句，的由条件表达式构成的条件表语句，和逻辑表达式构成的逻辑语句等。</p>
<p>（2）控制语句</p>
<p>控制语句是由流程控制表达式组成的语句，用于完成一定的流程控制功能。</p>
<p>C语言提供9种控制结构语句，它们分别为：</p>
<p>①if()…else…	（选择结构）</p>
<p>②for(;;)…		 （循环结构）</p>
<p>③while()…	   （循环结构）</p>
<p>④do…while(); （循环结构）</p>
<p>⑤break;		  （结束整个循环）</p>
<p>⑥continue;	 （结束本次循环，执行下次循环）</p>
<p>⑦switch		  （多分支选择结构）</p>
<p>⑧return		  （函数返回语句）</p>
<p>⑨goto			 （跳转语句，在结构化程序中最好不要用goto语句）</p>
<p>（3）函数调用语句</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这是一个简单的调用输出函数的语句。其中printf(“hello world!”)是一个函数调用，加一个分号’;’就是函数调用语句了。</p>
<p>（4）空语句</p>
<p>空语句就是：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">;	<span class="comment">//只有一个分号的语句，什么都不做</span></span><br></pre></td></tr></table></figure></div>

<p>（5）复合语句</p>
<p>在C语言中可以用{}把一些语句括起来，形成一条复合语句（又称为语句块）。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&#123;	<span class="comment">//这是一个复合语句（语句块）</span></span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	a=<span class="number">1</span>;</span><br><span class="line">	b=<span class="number">2</span>;</span><br><span class="line">	c=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>复合语句需要注意变量的作用域问题，其常用于选择分支结构和循环结构等控制语句中，其目的是让控制语句可以控制多条语句，达到我们想要的效果。</p>
<h1 id="四、选择结构和循环结构"><a href="#四、选择结构和循环结构" class="headerlink" title="四、选择结构和循环结构"></a>四、选择结构和循环结构</h1><p>C语言中的基本控制结构分为顺序结构、选择结构和循环结构，它们控制着程序的执行。</p>
<h2 id="1、选择结构"><a href="#1、选择结构" class="headerlink" title="1、选择结构"></a>1、选择结构</h2><p>在很多情况下，需要根据某个条件是否满足来决定是否执行指定的操作任务，或者从给定的两个或多个操作选择其中一个执行，这就需要用到我们的选择结构了。</p>
<p>C语言提供了两种选择结构：if语句和switch语句。</p>
<h3 id="1-1、if语句"><a href="#1-1、if语句" class="headerlink" title="1.1、if语句"></a>1.1、if语句</h3><p>If语句的一般形式：</p>
<p>if（表达式）语句1;</p>
<p>[else 语句2;]</p>
<p>根据if语句的一般形式，可以写成不同的形式，最常用的有以下三种形式：</p>
<p>（1）if(表达式)语句1;	&#x2F;&#x2F;单独的一个if语句，用于实现两个分支的判断选择</p>
<p>（2）if(表达式)语句1;	&#x2F;&#x2F;if和else组合，用于实现两个分支的判断选择</p>
<p>​		  else 语句2;</p>
<p>（3）if(表达式)语句1;	&#x2F;&#x2F;if else嵌套，用于实现多分支结构</p>
<p>​		  else if(表达式)语句2;	&#x2F;&#x2F;if和else的配对问题，就近原则</p>
<p>​		  else if(表达式)语句3;	&#x2F;&#x2F;else和前面最近的没有配对的if配对</p>
<p>​		  else语句4；……</p>
<p>例题1：从键盘输入一个年份，判断其是否为闰年。</p>
<p>提示：闰年是指能被4整除并且不能被100整除（普通闰年），或者能被400整除的年份（世纪闰年），否则就为平年。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一个年份：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d年是世纪闰年。\n&quot;</span>, year);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d年是普通闰年。\n&quot;</span>, year);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d年是平年。\n&quot;</span>, year);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="1-2、switch语句"><a href="#1-2、switch语句" class="headerlink" title="1.2、switch语句"></a>1.2、switch语句</h3><p>switch语句的一般形式：</p>
<p>switch(判断条件)</p>
<p>{</p>
<p>case 常量1：语句1；</p>
<p>case 常量2：语句2；</p>
<p>case 常量3：语句3；</p>
<p>……</p>
<p>case 常量n：语句n；</p>
<p>default：语句n+1;</p>
<p>}</p>
<p>例题2：从键盘输入的学生成绩（0~100分），给学生的成绩评定等级。优秀（成绩&gt;&#x3D;90）、良好（90&gt;成绩&gt;&#x3D;80）、及格（80&gt;成绩&gt;&#x3D;60）和不及格（成绩&lt;60）。</p>
<p>（1）用if语句实现</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一个成绩（1~100分）：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成绩等级：&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (score &gt;= <span class="number">90</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;优秀\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;良好\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;及格\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不及格\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成绩输入错误！\n输入的成绩应该在1~100之间！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（2）用switch语句实现</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一个成绩（1~100分）：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成绩等级：&quot;</span>);</span><br><span class="line">		<span class="keyword">switch</span> (score / <span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">&quot;优秀\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>: <span class="built_in">printf</span>(<span class="string">&quot;良好\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;及格\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;不及格\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成绩输入错误！\n输入的成绩应该在1~100之间！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2、循环结构"><a href="#2、循环结构" class="headerlink" title="2、循环结构"></a>2、循环结构</h2><p>在程序所处理的问题中，我们常常会需要重复处理同一类操作，这样我们就需要循环控制它们的执行了。</p>
<h3 id="2-1、for循环"><a href="#2-1、for循环" class="headerlink" title="2.1、for循环"></a>2.1、for循环</h3><p>for循环的一般格式为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>) 		<span class="comment">//注意：表达式之间的分隔符‘;’不能少</span></span><br><span class="line">&#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式1：条件的初始化语句</span></span><br><span class="line"><span class="comment">//表达式2：循环继续的条件</span></span><br><span class="line"><span class="comment">//表达式3：改变循环条件的语句</span></span><br></pre></td></tr></table></figure></div>

<p>如：循环输出整数0~9</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">10</span>;a++)</span><br><span class="line">	<span class="built_in">printf</span>(“a=%d\t”,a);</span><br></pre></td></tr></table></figure></div>

<h3 id="2-2、while循环"><a href="#2-2、while循环" class="headerlink" title="2.2、while循环"></a>2.2、while循环</h3><p>while循环的一般格式为：</p>
<p>while(表达式)</p>
<p>{</p>
<p>​	循环体;</p>
<p>}</p>
<h3 id="2-3、do-while循环"><a href="#2-3、do-while循环" class="headerlink" title="2.3、do  while循环"></a>2.3、do  while循环</h3><p>do  while循环的一般格式：</p>
<p>do</p>
<p>{</p>
<p>​	循环体;</p>
<p>}while(表达式);</p>
<h3 id="2-4、循环结构的分类"><a href="#2-4、循环结构的分类" class="headerlink" title="2.4、循环结构的分类"></a>2.4、循环结构的分类</h3><p>（1）当型循环</p>
<p>当循环条件满足时才执行循环体中的语句。</p>
<p>（2）直到型循环</p>
<p>直到条件不满足时才结束循环，至少会执行一次循环体。 </p>
<p>例题：输出以下图案：</p>
<p>（1）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">***</span><br><span class="line">***</span><br><span class="line">***</span><br><span class="line">***</span><br></pre></td></tr></table></figure></div>

<p>C语言代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>i++)	<span class="comment">//for循环</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;***\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">where(i--)	<span class="comment">//where循环</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;***\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">do</span>	<span class="comment">//do where循环</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;***\n&quot;</span>);</span><br><span class="line">&#125;where(--i);</span><br></pre></td></tr></table></figure></div>



<h2 id="3、跳转语句"><a href="#3、跳转语句" class="headerlink" title="3、跳转语句"></a>3、跳转语句</h2><h3 id="3-1、break语句"><a href="#3-1、break语句" class="headerlink" title="3.1、break语句"></a>3.1、break语句</h3><p>break语句用于switch分支结构和循环结构中，起到跳出switch分支结构或者跳出整个循环结构的作用。</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、continue语句"><a href="#3-2、continue语句" class="headerlink" title="3.2、continue语句"></a>3.2、continue语句</h3><p>continue语句用于循环语句中，起到跳出本次循环，继续执行下次循环的作用。</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3、goto跳转语句"><a href="#3-3、goto跳转语句" class="headerlink" title="3.3、goto跳转语句"></a>3.3、goto跳转语句</h3><p>goto语句支持跳转到指定的位置。</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">标记:	<span class="comment">//标记的命名需要符合标识符的命名规则</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">goto</span> 标记;	<span class="comment">//执行goto语句后，会跳转到指定标记的位置</span></span><br></pre></td></tr></table></figure></div>

<p>由于goto语句使程序执行的流程变复杂，不利于结构化程序的结构控制和意义的理解，所以一般不使用goto语句。</p>
<h1 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h1><p>在之前的程序中使用的变量都属于基本类型，如整型、字符型、浮点型数据，这些都是简单的数据类型。对于简单的问题，使用这些简单的数据类型就可以了。</p>
<p>由于程序有时候需要处理大批量的数据，如：一个班有60个学生，每个学生都有一个成绩，求这些学生的平均成绩，我们怎么实现呢？按照之前定义变量的方法，需要定义60个float类型的变量才能保存下所有学生的成绩。</p>
<p>只用简单的数据类型虽然也可以实现，但是会太过麻烦。所以人们就想出了一个办法：既然它们都是同一类性质的数据，就可以用同一个名字来代表它们，而在名字后加一个数字来表示是第几个数值。如：用S代表这些学生，那就可以用S1、S2、S3、…、S60代表学生1、学生2、学生3、…、学生60等60个学生的成绩，和数学中的数列类似，这样就产生了数组这样一个概念。</p>
<h2 id="1、什么是数组？"><a href="#1、什么是数组？" class="headerlink" title="1、什么是数组？"></a>1、什么是数组？</h2><p>数组的定义可以用以下3点来说明：</p>
<p>（1）数组是一组有序数据的集合。<br>数组中各数据的排列是有一定规律的，下标代表数据在数组中的序号。</p>
<p>（2）用一个数组名和下标来唯一地标识确定数组中的元素。<br>如：S10就代表第十个学生的成绩。</p>
<p>（3）数组中的每一个元素都是属于同一数据类型。<br>规定不能把不同数据类型的数据放在同一个数组中。</p>
<h2 id="2、一维数组的定义和引用"><a href="#2、一维数组的定义和引用" class="headerlink" title="2、一维数组的定义和引用"></a>2、一维数组的定义和引用</h2><h3 id="2-1、定义一维数组"><a href="#2-1、定义一维数组" class="headerlink" title="2.1、定义一维数组"></a>2.1、定义一维数组</h3><p>基本格式：数据类型 数组名[数组大小];</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> S[<span class="number">60</span>]; </span><br><span class="line"><span class="comment">//定义一个浮点型数组，取名为S，大小为60，用于保存60个学生的成绩。</span></span><br></pre></td></tr></table></figure></div>

<p>其中，flost为数据类型（int、char、double），S为数组名，60为数组下标，也就是数组的大小。</p>
<h3 id="2-2、使用数组及引用数组元素"><a href="#2-2、使用数组及引用数组元素" class="headerlink" title="2.2、使用数组及引用数组元素"></a>2.2、使用数组及引用数组元素</h3><p>基本格式：数组名[下标];</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">S[<span class="number">0</span>]=<span class="number">1</span>; </span><br><span class="line">S[<span class="number">1</span>]=S[<span class="number">0</span>];</span><br><span class="line">S[<span class="number">10</span>]=S[<span class="number">0</span>]+S[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></div>

<p>注意：</p>
<p>（1）数组名的命名规则和变量名相同，要遵循标识符的命名规则。</p>
<p>（2）在定义数组时，需要指定数组中元素的个数，也就是数组的大小，在定义数组时[]方括号中必须是常量表达式，可以包括数值常量和符号常量。如：int a[6+8]; char b[‘a’];</p>
<p>（3）在C语言中数组下标是从0开始的，如：S[0]代表第一个数组元素。</p>
<p>思考一下数组的最后一个元素是多少？</p>
<p>（4）整个数组的内存大小为元素个数*单个元素类型所占字节数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(数组名);	<span class="comment">//求数组内存大小</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3、一维数组的初始化"><a href="#2-3、一维数组的初始化" class="headerlink" title="2.3、一维数组的初始化"></a>2.3、一维数组的初始化</h3><p>为了使程序简洁，常在定义数组的同时，给个数组元素赋值，这称为数组的初始化。</p>
<p>可以用“初始化列表”的方法实现数组的初始化。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<p>可以只给数组的部分元素赋初值。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<p>那未赋值的元素初始值是多少呢？ 没有赋初值的元素初始值默认为0</p>
<p>也可以不给数组的大小，利用数据初始化赋值决定数组大小。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//此时数组大小根据初始化时元素的多少来决定，这里的数组大小为7</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-4、一维数组的输入输出"><a href="#2-4、一维数组的输入输出" class="headerlink" title="2.4、一维数组的输入输出"></a>2.4、一维数组的输入输出</h3><p>可以使用循环输入&#x2F;输出每一个数组元素的值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(“%d”,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%d”,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="3、二维数组"><a href="#3、二维数组" class="headerlink" title="3、二维数组"></a>3、二维数组</h2><p>二维数组就是多个相同类型相同大小的一维数组的组合。</p>
<p>如果把一维数组看成一行数据的话，二维数组就像一个Excel表格一样，可以写成行和列的排列形式。</p>
<h3 id="3-1、二维数组的定义"><a href="#3-1、二维数组的定义" class="headerlink" title="3.1、二维数组的定义"></a>3.1、二维数组的定义</h3><p>基本格式：数据类型 数组名 数组行数 数组列数;</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure></div>

<p>此二维数组有3行4列，如下图所示：</p>
<p>二维数组的内存：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">行数*列数*单个元素类型所占字节数</span><br></pre></td></tr></table></figure></div>



<h3 id="3-2、二维数组的初始化"><a href="#3-2、二维数组的初始化" class="headerlink" title="3.2、二维数组的初始化"></a>3.2、二维数组的初始化</h3><p>（1）给全部元素赋值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">//定义一个3行4列的二维数组，并给它的元素初始化赋值</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#125;;<span class="comment">//全部赋值为0</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//全部赋值为0</span></span><br></pre></td></tr></table></figure></div>

<p>（2）给每一行元素赋值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></div>

<p>（3）给部分元素赋值</p>
<p>可以不指定数组行大小，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//给数组前两个元素赋值，数组行数为1，此行最后一个元素默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//给数组前四个元素赋值，数组行数为2，第二行最后两个元素默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//给数组每行的前两个元素赋值，数组行数为2，每行最后一个元素默认为0</span></span><br></pre></td></tr></table></figure></div>

<p>虽然可以不给定数组行的大小，但是必须给定数组列的大小，也必须初始化赋值，因为数组行的大小是由初始化列表中数据的个数决定。</p>
<h3 id="3-3、二维数组元素的访问"><a href="#3-3、二维数组元素的访问" class="headerlink" title="3.3、二维数组元素的访问"></a>3.3、二维数组元素的访问</h3><p>二维数组与一维数组类似，通过数组名带下标的形式访问数组元素，由于是二维数组，所以需要带两个下标。</p>
<p>如有以下定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>];	<span class="comment">//访问数组第1行第1个元素</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>];	<span class="comment">//访问数组第2行第1个元素</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>];	<span class="comment">//访问数组第3行2个元素</span></span><br></pre></td></tr></table></figure></div>



<h3 id="3-4、二维数组的输入输出"><a href="#3-4、二维数组的输入输出" class="headerlink" title="3.4、二维数组的输入输出"></a>3.4、二维数组的输入输出</h3><p>可以使用双重循环输入&#x2F;输出每一个二维数组元素的值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(“%d”,&amp;a[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(“%d”,a[i][j]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="4、字符数组"><a href="#4、字符数组" class="headerlink" title="4、字符数组"></a>4、字符数组</h2><p>字符数组简单的来说就是char类型的数组。</p>
<p>为什么要把字符数组分开讲呢？<br>字符数组是一类特殊的数组，由于C语言中没有字符串类型，所以字符串是存放在字符型数组中的。</p>
<h3 id="4-1、字符数组的定义及初始化"><a href="#4-1、字符数组的定义及初始化" class="headerlink" title="4.1、字符数组的定义及初始化"></a>4.1、字符数组的定义及初始化</h3><p>用来存放字符数据的数组就是字符数组。字符数组中的一个元素存放一个字符。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">6</span>]=&#123;‘a’,’b’,’c’,’d’,’e’,’f’&#125;; 	<span class="comment">//定义一个字符数组c，并以单个字符初始化赋值</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">8</span>]=”abcdefg”;	<span class="comment">//定义一个字符数组c，并以字符串初始化赋值</span></span><br></pre></td></tr></table></figure></div>

<p>注意：以字符串的形式初始化赋值时，字符串的结尾有一个字符串结束标志’\0’，所以定义的数组大小至少要比字符串的长度大一个。</p>
<h3 id="4-2、引用字符数组中的元素"><a href="#4-2、引用字符数组中的元素" class="headerlink" title="4.2、引用字符数组中的元素"></a>4.2、引用字符数组中的元素</h3><p>通过数组名带下表的形式访问数组元素，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>]; <span class="comment">//定义一个字符数组</span></span><br><span class="line">s[<span class="number">0</span>]=’a’;	<span class="comment">//引用字符数组s的第一个元素s[0]并赋值</span></span><br><span class="line">s[<span class="number">1</span>]=’b’;	<span class="comment">//引用字符数组s的第二个元素s[1]并赋值</span></span><br></pre></td></tr></table></figure></div>



<h3 id="4-3、字符数组的输入和输出"><a href="#4-3、字符数组的输入和输出" class="headerlink" title="4.3、字符数组的输入和输出"></a>4.3、字符数组的输入和输出</h3><p>如有定义以下字符数组：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>

<p>方法一：以%c的格式循环输入&#x2F;输出字符数组中的每个数组元素的值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(“%c”,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%c”,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>方法二：以%s的格式输入&#x2F;输出字符串</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%s”,a);</span><br><span class="line"><span class="built_in">printf</span>(“%s”,a);</span><br></pre></td></tr></table></figure></div>



<h3 id="4-4、二维字符数组"><a href="#4-4、二维字符数组" class="headerlink" title="4.4、二维字符数组"></a>4.4、二维字符数组</h3><p>二维字符数组与普通数组的定义方式一致。如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">3</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>

<p>二维字符数组的每一行都可以存储一个字符串。</p>
<p>如：二维字符数组的输入输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(“%s”,s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">	printf(“%s”,s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="4-5、字符串处理函数"><a href="#4-5、字符串处理函数" class="headerlink" title="4.5、字符串处理函数"></a>4.5、字符串处理函数</h3><p>常用的字符串处理函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(字符数组);</span><br><span class="line">	<span class="comment">//字符串的输出函数</span></span><br><span class="line"></span><br><span class="line">gets(字符数组);</span><br><span class="line">	<span class="comment">//字符串的输入函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strlen</span>(字符串);</span><br><span class="line">	<span class="comment">//测字符串长度函数，只计算有效字符，不包括’\0’</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//字符串连接函数,将字符串2连接到字符串1的末尾，并返回字符串1的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//字符串复制函数，将字符串2复制到字符串1中，并返回字符串1的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>(字符串<span class="number">1</span>,字符串<span class="number">2</span>);</span><br><span class="line">	<span class="comment">/*字符串比较函数</span></span><br><span class="line"><span class="comment">	比较字符串1和字符串2的大小，从两个字符串的第一个字符开始，按照各字母的ASCII码比较各个字符的大小，</span></span><br><span class="line"><span class="comment">	如果字符串1比字符串2大，则返回1，如果字符串1比字符串2小，则返回-1，如果相等则返回0</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strstr</span>(字符串<span class="number">1</span>,字符串<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//求子串函数，求字符串1（父串）中字符串2（子串）首次出现的位置（地址）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>使用字符串处理函数需要包含头文件：#include&lt;string.h&gt;</p>
<h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><h2 id="1、函数的基本概念"><a href="#1、函数的基本概念" class="headerlink" title="1、函数的基本概念"></a>1、函数的基本概念</h2><p>什么是函数？<br>所谓“函数”是从英文function翻译过来的，其意思既是“函数”，也是“功能”。从本质意义上来说明函数就是用来完成一定功能的，是把实现功能的代码封装起来，给这些封装起来的代码取个名字就是函数名，每一个函数用来实现一个特定的功能，函数的名字对应其代表的功能。</p>
<p>为什么要使用函数呢？<br>函数就是为了提高代码的复用性，提高程序的可读性，在使用过程中比较灵活，更加方便了程序代码的编写。</p>
<h2 id="2、函数的定义"><a href="#2、函数的定义" class="headerlink" title="2、函数的定义"></a>2、函数的定义</h2><p>C语言要求，在程序中用到的所有函数，必须“先定义，后使用”。</p>
<p>定义函数应包括以下几个内容：</p>
<p>（1）指定函数的名字，以便后续按名调用。<br>（2）指定函数的类型，即函数返回值的类型。<br>（3）指定函数参数的名字、数据类型和个数，以便在调用函数时向它们传递数据。（无参函数不需要这一项）<br>（4）指定函数所完成的功能，也就是规定函数要完成什么操作，说明函数是做什么的，这是最重要的一点，函数的功能都是写在函数体中的。</p>
<p>函数定义的一般格式如下：</p>
<h3 id="2-1、定义无参无返回值函数"><a href="#2-1、定义无参无返回值函数" class="headerlink" title="2.1、定义无参无返回值函数"></a>2.1、定义无参无返回值函数</h3><p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> 函数名()	<span class="comment">//void为空类型</span></span><br><span class="line">&#123;</span><br><span class="line">	函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在函数体里描述函数实现的功能。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“--------------------------------------------------\n”);</span><br><span class="line">&#125;<span class="comment">//这里定义了一个函数，函数名为fun，无返回值，完成打印分隔线的功能。</span></span><br></pre></td></tr></table></figure></div>



<h3 id="2-2、定义有参数无返回值函数"><a href="#2-2、定义有参数无返回值函数" class="headerlink" title="2.2、定义有参数无返回值函数"></a>2.2、定义有参数无返回值函数</h3><p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> 函数名(函数参数<span class="number">1</span>,函数参数<span class="number">2</span>,……)</span><br><span class="line">&#123;</span><br><span class="line">	函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如：求两个数据的和并输出</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> z;</span><br><span class="line">	z=x&gt;y?x:y;</span><br><span class="line">	<span class="built_in">printf</span>(“%d\n”,,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出两个数之间的最大值</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3、定义有参数有返回值函数"><a href="#2-3、定义有参数有返回值函数" class="headerlink" title="2.3、定义有参数有返回值函数"></a>2.3、定义有参数有返回值函数</h3><p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">类型名 函数名(函数参数<span class="number">1</span>,函数参数<span class="number">2</span>,……)</span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> 值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> z;</span><br><span class="line">	z=x&gt;y?x:y;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最大值函数并返回</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-4、定义无参数有返回值函数"><a href="#2-4、定义无参数有返回值函数" class="headerlink" title="2.4、定义无参数有返回值函数"></a>2.4、定义无参数有返回值函数</h3><p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">类型名 函数名()</span><br><span class="line">&#123;</span><br><span class="line">	函数体;</span><br><span class="line">	<span class="keyword">return</span> 值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SCANF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一个整型数据：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="3、函数的调用"><a href="#3、函数的调用" class="headerlink" title="3、函数的调用"></a>3、函数的调用</h2><h3 id="3-1、函数调用语句"><a href="#3-1、函数调用语句" class="headerlink" title="3.1、函数调用语句"></a>3.1、函数调用语句</h3><p>函数调用的基本格式：函数名(实参列表);</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,c;</span><br><span class="line">c=max(a,b);	<span class="comment">//函数调用语句，调用max函数求a和b两个数中的最大值赋值给c</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、函数参数"><a href="#3-2、函数参数" class="headerlink" title="3.2、函数参数"></a>3.2、函数参数</h3><p>函数的参数分为实参和形参。</p>
<p>在调函数时，我们将调用其他函数的函数称为主调函数，将被调用的函数称为被调函数。在调用有参函数时，主调函数和被调函数之间有数据传递关系。主调函数中将值传递出去的参数称为“实际参数”（简称实参），被调函数中用于接收主调函数所传递过来值的参数称为“形式参数”或“虚拟参数”（简称形参）。</p>
<h3 id="3-3、实参和形参之间的数据传递"><a href="#3-3、实参和形参之间的数据传递" class="headerlink" title="3.3、实参和形参之间的数据传递"></a>3.3、实参和形参之间的数据传递</h3><p>在调用函数的过程中，系统会把实参的值传递给被调函数的形参，或者说形参从实参得到一个值。</p>
<p>函数调用过程中需要注意以下几点：</p>
<p>（1）实参可以是常量、变量或表达式。如：max(3,a+b);</p>
<p>（2）实参与形参的数据类型应相同或者赋值兼容，并且实参在实参列表中的位置与形参在形参列表中的位置必须对应。</p>
<p>（3）函数遇到return返回语句返回过后，不再继续执行return之后的语句了。</p>
<p>（4）形参在其所在函数的调用期间有效，可以参加此函数中的运算，但是不能用于其他函数中。</p>
<p>（5）函数的形参和实参是两个不同的变量，所以，一般情况下形参值的改变不影响实参的值，除非在函数参数的传递类型为引用传递（地址传递）。在未调用函数时，形参并不占用存储单元，开始函数调用时，才给形参开辟存储空间，函数调用结束后，形参的存储单元就会被释放。</p>
<h3 id="3-4、函数的返回值"><a href="#3-4、函数的返回值" class="headerlink" title="3.4、函数的返回值"></a>3.4、函数的返回值</h3><p>函数通过return语句带回返回值，应注意返回值类型应与函数类型一致，即函数类型决定返回值的类型。函数的返回值可以根据函数的功能拟定，并不固定。</p>
<h2 id="4、函数的声明"><a href="#4、函数的声明" class="headerlink" title="4、函数的声明"></a>4、函数的声明</h2><p>问：把某自定义函数的定义放在最后，主函数里能够调用此函数吗？<br>答：不能，函数需要先定义后使用，除非在调用函数之前有此函数的声明。</p>
<p>函数声明语句的一般格式：<br>    函数类型 函数名(参数类型1 参数名1,参数类型2 参数名2,……,参数类型n 参数名n);</p>
<p>函数声明其实就是将函数头部前置。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//max函数的声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;	<span class="comment">//函数头部</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    max(<span class="number">10</span>,<span class="number">20</span>);	<span class="comment">//函数调用在函数定义之前</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;	<span class="comment">//求最大值函数，返回两个数之间的最大值</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在一个函数中调用另一个函数（即被调函数）需要具备以下条件：</p>
<p>（1）首先被调用函数必须是已经定义好的函数（库函数或自定义的函数）。<br>（2）如果使用库函数，应该在本文件开头用#include指令将调用相关库函数时所需用到的信息“包含”到本文件中来。如：#include&lt;stdio.h&gt;。<br>（3）如果使用用户自定义的函数，在调用函数之前必须要有被调函数相关的声明语句，也就是函数需要先声明后使用。</p>
<h2 id="5、局部变量和全局变量"><a href="#5、局部变量和全局变量" class="headerlink" title="5、局部变量和全局变量"></a>5、局部变量和全局变量</h2><p>按照变量作用域的不同，我们将变量分为局部变量和全局变量。</p>
<h3 id="5-1、局部变量"><a href="#5-1、局部变量" class="headerlink" title="5.1、局部变量"></a>5.1、局部变量</h3><p>局部变量的作用范围只在一定范围内有效</p>
<p>局部变量的定义可能有以下几种情况：</p>
<p>（1）在函数开头定义；</p>
<p>（2）在函数内部的复合语句中定义；</p>
<h3 id="5-2、全局变量"><a href="#5-2、全局变量" class="headerlink" title="5.2、全局变量"></a>5.2、全局变量</h3><p>全局变量的作用范围相对于局部变量来说更为广泛，其在函数外部定义，也称为外部变量</p>
<h3 id="5-3、静态变量与动态变量"><a href="#5-3、静态变量与动态变量" class="headerlink" title="5.3、静态变量与动态变量"></a>5.3、静态变量与动态变量</h3><p>程序中所定义的变量默认是动态局部变量（auto）。</p>
<p>在定义变量前加一个static可定义一个静态变量。</p>
<p>静态变量在程序开始后定义，结束前才会被释放，所以其生命周期比较长，在函数调用中只会被定义一次，不会被定义多次，当再次执行到定义语句时，其值不会被重置（初始化），会保留上次改变的值。</p>
<h2 id="6、函数的嵌套调用"><a href="#6、函数的嵌套调用" class="headerlink" title="6、函数的嵌套调用"></a>6、函数的嵌套调用</h2><p>函数的定义时相互平行、独立的，在定义函数时，一个函数内不能再定义另一个函数，也就是说，函数不能嵌套定义。但是函数可以嵌套调用，也就是再调用一个函数的过程中，又调用另一个函数。</p>
<p>思考：怎么实现求三个数中的最大值的函数呢？</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">max(max(x,y),z);</span><br></pre></td></tr></table></figure></div>

<h2 id="7、函数的递归调用"><a href="#7、函数的递归调用" class="headerlink" title="7、函数的递归调用"></a>7、函数的递归调用</h2><p>在调用一个函数的过程中又出现直接或间接地调用此函数本身，称为函数的递归调用。</p>
<p>函数的递归调用演示示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归求1~n的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>&gt;=n)<span class="keyword">return</span> n; <span class="comment">//结束递归的条件</span></span><br><span class="line">	<span class="keyword">return</span> n+function(n<span class="number">-1</span>); <span class="comment">//这里在函数中调用此函数本身，实现递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：递归的函数中应有结束递归的条件，否则会和死循环一样，陷入无限递归，或者说死递归。</p>
<h2 id="8、数组作为函数参数传递"><a href="#8、数组作为函数参数传递" class="headerlink" title="8、数组作为函数参数传递"></a>8、数组作为函数参数传递</h2><p>数组名为数组的首地址，所以整个数组作为函数参数传递实际上是引用传递，传递的是地址，形参的改变会影响到实参。</p>
<p>如：字符串的输出</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PUTS</span><span class="params">(<span class="type">char</span> str[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> S[<span class="number">20</span>]=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">	PUTS(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里数组作为函数参数传递是数组的首地址，有涉及到指针的相关概念，之后讲到指针时再详细讲解。</p>
<p>注意：在函数中改变形参数组元素的值，那实参数组元素的值是否会被改变呢？</p>
<h1 id="七、预处理"><a href="#七、预处理" class="headerlink" title="七、预处理"></a>七、预处理</h1><p>预处理是在编译前所做的工作，编译器自动调用预处理程序对源码中以’#’开头的预处理部分进行处理，处理完毕后，进入源码的编译阶段。</p>
<h2 id="1、预定义符号"><a href="#1、预定义符号" class="headerlink" title="1、预定义符号:"></a>1、预定义符号:</h2><p> 常用的预定义符号：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_CRT_SECURE_NO_WARNINGS <span class="comment">//安全检查</span></span><br><span class="line"></span><br><span class="line">__FILE__	<span class="comment">//当前编译的文件名.  </span></span><br><span class="line">__FUNCTION__<span class="comment">//当前所在函数的函数名.</span></span><br><span class="line">__DATE__	<span class="comment">//当前编译日期.</span></span><br><span class="line">__TIME__	<span class="comment">//当前编译时间.</span></span><br><span class="line"><span class="comment">//注意标识符前后都有两个下划线&#x27;_&#x27;，以上格式占位符都用%s ，如：printf(&quot;%s&quot;,__FILE__);</span></span><br><span class="line"></span><br><span class="line">__LINE__	<span class="comment">//当前行数，格式占位符用%d，如：printf(&quot;%d&quot;,LINE);</span></span><br></pre></td></tr></table></figure></div>

<h2 id="2、宏定义"><a href="#2、宏定义" class="headerlink" title="2、宏定义"></a>2、宏定义</h2><p>宏定义，又称为宏替换，自定义一个宏(要符合标识符的命名规则)，用于替换任意数据、标识符或者表达式。</p>
<h3 id="2-1、无参宏定义"><a href="#2-1、无参宏定义" class="headerlink" title="2.1、无参宏定义"></a>2.1、无参宏定义</h3><p>基本格式：#define 宏名 宏替换</p>
<p>比如: </p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A 35   		<span class="comment">//用A代表数据35</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT int   	<span class="comment">//用INT代替int</span></span></span><br><span class="line"></span><br><span class="line">INT a=A;	<span class="comment">//使用宏定义别名定义int类型的变量a，并初始化赋值为35</span></span><br></pre></td></tr></table></figure></div>

<p>不能给宏定义的常量赋值</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">A = <span class="number">66</span>; <span class="comment">// 错误，不能给宏定义常量赋值</span></span><br></pre></td></tr></table></figure></div>



<h3 id="2-2、带参宏定义"><a href="#2-2、带参宏定义" class="headerlink" title="2.2、带参宏定义"></a>2.2、带参宏定义</h3><p>基本格式：#define 宏名(参数表) 宏替换</p>
<p>带参宏可以像函数一样调用，比如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M(a,b) a+b-2</span></span><br><span class="line"></span><br><span class="line">K = M(<span class="number">1</span>,<span class="number">2</span>) * <span class="number">4</span>;</span><br><span class="line"><span class="comment">//K = 1+2-2*4 = 1+2-8 = -5</span></span><br></pre></td></tr></table></figure></div>

<p>注意：宏定义是替换，其在替换完成前并不会计算。</p>
<p>宏名尽量用大写，使其在程序中容易辨别区分</p>
<h3 id="2-3、常量的定义："><a href="#2-3、常量的定义：" class="headerlink" title="2.3、常量的定义："></a>2.3、常量的定义：</h3><p>除了宏定义以外，还可以通过const关键字定义常量:</p>
<p> 定义常量的基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">&lt;cosnt&gt; &lt;数据类型&gt; &lt;常量名&gt; = &lt;常量值&gt;;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">30</span>; <span class="comment">//定义一个常量a，其值等于30</span></span><br></pre></td></tr></table></figure></div>

<p>定义成常量后，值不可被改变。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">a = <span class="number">40</span>; <span class="comment">//错误，不能给常量赋值</span></span><br></pre></td></tr></table></figure></div>



<h2 id="3、文件包含"><a href="#3、文件包含" class="headerlink" title="3、文件包含"></a>3、文件包含</h2><h3 id="3-1、包含头文件"><a href="#3-1、包含头文件" class="headerlink" title="3.1、包含头文件"></a>3.1、包含头文件</h3><p>我们想要用库函数就需要包含头文件，也就是文件包含，当然也可以编写自定义头文件，包含自己编写的头文件。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="comment">//包含系统头文件用&lt;&gt;，只会在系统头文件中找</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;name.h&quot;</span></span></span><br><span class="line">	<span class="comment">//包含自定义头文件用&quot;&quot;，在自定义头文件中找不到就会在系统头文件中找</span></span><br></pre></td></tr></table></figure></div>

<p> 文件包含允许嵌套，即在一个被包含文件中可以包含其它文件。</p>
<h3 id="3-2、头文件的重复包含"><a href="#3-2、头文件的重复包含" class="headerlink" title="3.2、头文件的重复包含"></a>3.2、头文件的重复包含</h3><p>头文件的嵌套包含可能会引起头文件的重复包含，从而出现函数和变量的重定义问题，所以需要避免头文件重复包含，某些宏定义语句可以防止头文件重复包含，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once 	<span class="comment">//不让文件被包含两次，在头文件最前面添加</span></span></span><br></pre></td></tr></table></figure></div>

<p>此预处理语句是vs独有的，有使用平台的限制，其他平台可能不存在。</p>
<h2 id="4、条件编译"><a href="#4、条件编译" class="headerlink" title="4、条件编译"></a>4、条件编译</h2><p>所谓的条件编译就是根据不同的条件编译不同的代码段。</p>
<h3 id="4-1、-if……-else的使用"><a href="#4-1、-if……-else的使用" class="headerlink" title="4.1、#if……#else的使用"></a>4.1、#if……#else的使用</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 表达式</span></span><br><span class="line"><span class="comment">//判断表达式的逻辑值(真或假),若逻辑值为真,则编译代码段1,否则编译代码段2</span></span><br><span class="line">	代码段<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	代码段<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-2、-ifdef……-endif的使用"><a href="#4-2、-ifdef……-endif的使用" class="headerlink" title="4.2、#ifdef……#endif的使用"></a>4.2、#ifdef……#endif的使用</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line"><span class="comment">//如果定义了宏&quot;宏名&quot;,则编译代码段</span></span><br><span class="line">	代码段;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line"><span class="comment">//如果定义了宏&quot;宏名&quot;,则编译代码段1,否则编译代码段2;</span></span><br><span class="line">	代码段<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	代码段<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-3、-ifndef……-endif的使用"><a href="#4-3、-ifndef……-endif的使用" class="headerlink" title="4.3、#ifndef……#endif的使用"></a>4.3、#ifndef……#endif的使用</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 宏名</span></span><br><span class="line">    <span class="comment">//如果没有定义宏&quot;宏名&quot;,则编译代码段</span></span><br><span class="line">代码段;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 宏名</span></span><br><span class="line"><span class="comment">//如果没有定义宏&quot;宏名&quot;,则编译代码段1,否则编译代码段2;</span></span><br><span class="line">	代码段<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	代码段<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>



<h1 id="八、构造数据类型"><a href="#八、构造数据类型" class="headerlink" title="八、构造数据类型"></a>八、构造数据类型</h1><h2 id="1、结构体"><a href="#1、结构体" class="headerlink" title="1、结构体"></a>1、结构体</h2><p>构造数据类型：用户自己建立的数据类型（自定义数据类型）。</p>
<p>C语言中的构造数据类型有：数组类型、结构体类型和共用体类型。</p>
<h3 id="1-1、什么是结构体？"><a href="#1-1、什么是结构体？" class="headerlink" title="1.1、什么是结构体？"></a>1.1、什么是结构体？</h3><p>C语言允许用户根据需要自己建立的由不同类型数据组成的组合型的数据类型，我们把它称之为结构体（struct）。</p>
<h3 id="1-2、为什么要用结构体？"><a href="#1-2、为什么要用结构体？" class="headerlink" title="1.2、为什么要用结构体？"></a>1.2、为什么要用结构体？</h3><p>在日常生活中有许多事物用单一的数据类型可能没办法完全表示出来，例如：学校要存储学生的学号、姓名、性别、年龄、成绩和家庭地址等信息，这些信息需要用不同的数据类型来存储，显然用我们一个普通的单一的数据类型是无法全部存储起来的，就比如说数组，我们常用它来存储一串连续的信息，但是它的数据类型单一，显然无法把学生的这些信息全部保存。</p>
<p>所以，结构体这种数据类型就诞生了，它能根据用户需要来更方便的存储各种各样的信息。</p>
<h3 id="1-3、结构体类型的声明和结构体变量的定义"><a href="#1-3、结构体类型的声明和结构体变量的定义" class="headerlink" title="1.3、结构体类型的声明和结构体变量的定义"></a>1.3、结构体类型的声明和结构体变量的定义</h3><p>（1）声明一个结构体类型的一般形式为：</p>
<p>​	struct 结构体类型名{成员列表}；</p>
<p>（2）定义一个结构体类型的变量：</p>
<p>可以在声明的时候直接定义结构体变量,也可以先声明后定义结构体变量。</p>
<p>例如：学生类结构体</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> id;				<span class="comment">//学生学号</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];		<span class="comment">//学生姓名</span></span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];		<span class="comment">//学生性别</span></span><br><span class="line">	<span class="type">int</span> age;			<span class="comment">//学生年龄</span></span><br><span class="line">	<span class="type">int</span> score;			<span class="comment">//学生成绩</span></span><br><span class="line">	<span class="type">char</span> address[<span class="number">20</span>];	<span class="comment">//学生家庭住址</span></span><br><span class="line">&#125;S1,S2,S3;	<span class="comment">//声明时定义结构体变量S1,S2,S3</span></span><br></pre></td></tr></table></figure></div>

<p>这里定义了一个结构体，其中struct为结构体关键字，srtuct student为结构体类型名，id、name、sex、age、score、address为结构体成员名，S1、S2、S3为结构体变量名。</p>
<p>注意：一定要区分清楚什么是结构体类型名、结构体成员名和结构体变量名。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">S4</span>,<span class="title">S5</span>;</span><span class="comment">//声明之后使用结构体类型名定义的结构体变量S4,S5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（3）不指定结构体类型名而直接定义结构体类型的变量</p>
<p>其一般形式为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> //这里缺省了结构体类型名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	成员列表;</span><br><span class="line">&#125;变量名列表;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">srtuct	<span class="comment">//这里没有给定结构体类型名</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">	<span class="type">char</span> address[<span class="number">20</span>]; </span><br><span class="line">&#125;t1,t2,t3;	<span class="comment">//由于没有给定类型名，所以变量只能声明时定义</span></span><br></pre></td></tr></table></figure></div>

<p>注意：以此方式定义结构体，由于没有结构体类型名，只能在声明时定义此结构体的变量，而不能再以此结构体类型名去定义其他变量了。（这种方式用得不多）</p>
<h3 id="1-4、结构体变量的初始化和引用"><a href="#1-4、结构体变量的初始化和引用" class="headerlink" title="1.4、结构体变量的初始化和引用"></a>1.4、结构体变量的初始化和引用</h3><p>（1）结构体变量的初始化：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">srtuct student&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;s1=&#123;<span class="number">666</span>,<span class="string">&quot;小李&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">30</span>,<span class="number">100</span>&#125;,t2,t3;</span><br><span class="line"><span class="comment">//这里给srtuct student类型的结构体变量s1赋初值（初始化赋值）</span></span><br><span class="line"><span class="comment">//在定义结构体变量的同时给变量赋初值，应按次序给每一个成员或部分成员赋值</span></span><br></pre></td></tr></table></figure></div>

<p>（2）结构体变量和成员的引用</p>
<p>相同结构体类型的结构体能够相互赋值：<br>    如有定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span>,<span class="title">s2</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>​	就可以有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">s1=s2;</span><br></pre></td></tr></table></figure></div>

<p>不同结构体类型的结构体不能相互赋值：<br>    如有定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> <span class="title">t</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>​	则不能有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">s=t;</span><br></pre></td></tr></table></figure></div>

<p>​	也不能有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">student = teacher;</span><br></pre></td></tr></table></figure></div>

<p>结构体成员引用符：’.’</p>
<p>结构体成员引用的一般格式：结构体变量名.成员名</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">s1.id=<span class="number">1</span>;	s2.name;	s3.score;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-5、使用typedef关键字自定义类型名"><a href="#1-5、使用typedef关键字自定义类型名" class="headerlink" title="1.5、使用typedef关键字自定义类型名"></a>1.5、使用typedef关键字自定义类型名</h3><p>typedef：简单来说就是用一个新的标识符名代替原有的类型名。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;	<span class="comment">//这里用INT代替int,之后定义整型变量就可以用INT了 </span></span><br></pre></td></tr></table></figure></div>

<p>typedef的使用方法与#define INT int 类似，相当于给数据类型关键字取别名。</p>
<p>但是需要注意的是：typedef只能用于给数据类型关键字取别名，除此之外没有其他用途。</p>
<p>使用typedef取的别名也需要遵循标识符的命名规则</p>
<p>可以给一个数据类型取多个别名(没有意义)</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT,I,inter;</span><br></pre></td></tr></table></figure></div>

<p>或者：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> I;</span><br></pre></td></tr></table></figure></div>

<p>typedef一般使用在数据类型名比较长的情况下，</p>
<p>如：声明结构体</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> id;	<span class="comment">//学生学号</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];	<span class="comment">//学生姓名</span></span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];	<span class="comment">//学生性别</span></span><br><span class="line">	<span class="type">int</span> age;	<span class="comment">//学生年龄</span></span><br><span class="line">	<span class="type">int</span> score;	<span class="comment">//学生成绩</span></span><br><span class="line">	<span class="type">char</span> address[<span class="number">20</span>];	<span class="comment">//学生家庭住址</span></span><br><span class="line">&#125;S; <span class="comment">//这里的S是代表struct student这个数据类型的别名，而不是结构体的变量名了</span></span><br></pre></td></tr></table></figure></div>

<p>我们可以用struct student定义此结构体类型的变量，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span>,<span class="title">s2</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>也可以用struct student的别名S等于此结构体类型的变量，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">S s3,s4;</span><br></pre></td></tr></table></figure></div>

<p>思考一下：结构体变量所占的内存大小怎么计算？</p>
<p>​	一般来说结构体类型所占内存大小是所有成员大小之和，但是存在内存补齐。</p>
<h3 id="1-6、结构体的嵌套定义"><a href="#1-6、结构体的嵌套定义" class="headerlink" title="1.6、结构体的嵌套定义"></a>1.6、结构体的嵌套定义</h3><p>用一个结构体类型作为另一个结构体类型的成员。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test1</span></span></span><br><span class="line"><span class="class">	&#123;</span>	<span class="comment">//结构体的嵌套定义：一个结构体类型中定义了另一个结构体类型</span></span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">	&#125;z;</span><br><span class="line">&#125;n;</span><br></pre></td></tr></table></figure></div>

<p>通过结构体变量n引用成员变量x：**n.z.x&#x3D;10;	&#x2F;&#x2F;给成员变量x赋值为10</p>
<h3 id="1-7、结构体数组"><a href="#1-7、结构体数组" class="headerlink" title="1.7、结构体数组"></a>1.7、结构体数组</h3><p>（1）结构体数组的定义</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">S</span>[3];</span></span><br></pre></td></tr></table></figure></div>

<p>这是一个struct student类型的结构体数组，此数组中有三个struct student结构体类型的元素，分别为S[0],S[1],S[2]。</p>
<p>（2）结构体数组元素的使用</p>
<p>使用结构体数组元素成员的一般格式：结构体数组名[数组下标].成员变量名;</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">S[<span class="number">0</span>].id=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//这里引用了struct student类型的结构体数组S的第1个元素S[0]的成员id，使其值等于1</span></span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,S[<span class="number">2</span>].name);</span><br><span class="line"><span class="comment">//这里是输出struct student类型的结构体数组S的第3个元素S[2]的成员name的值</span></span><br></pre></td></tr></table></figure></div>

<p>如有以下定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span>[3],<span class="title">s2</span>[3];</span></span><br></pre></td></tr></table></figure></div>

<p>那么可以有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">s1[<span class="number">0</span>]=s2[<span class="number">1</span>];	<span class="comment">//相同类型的结构体数组元素赋值</span></span><br></pre></td></tr></table></figure></div>

<p>不能有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">s1=s2;	<span class="comment">//错误，结构体数组之间不能相互赋值</span></span><br></pre></td></tr></table></figure></div>

<p>思考一下：结构体数组所占的内存大小怎么计算？</p>
<h2 id="2、共用体"><a href="#2、共用体" class="headerlink" title="2、共用体"></a>2、共用体</h2><h3 id="2-1、什么是共用体？"><a href="#2-1、什么是共用体？" class="headerlink" title="2.1、什么是共用体？"></a>2.1、什么是共用体？</h3><p>共用体关键字：union</p>
<p>有时候想用同一段内存单元存放不同类型的变量。如：把一个整型变量、浮点型变量和字符型变量放在同一个内存单元中，它们在内存中所占字节数不同，但是共用同一段内存地址，也就是共用体了。</p>
<h3 id="2-2、共用体类型的声明和共用体变量的定义"><a href="#2-2、共用体类型的声明和共用体变量的定义" class="headerlink" title="2.2、共用体类型的声明和共用体变量的定义"></a>2.2、共用体类型的声明和共用体变量的定义</h3><p>共用体类型声明和定义的一般格式为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	成员列表;</span><br><span class="line">&#125;变量列表;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line">&#125;d1=&#123;<span class="number">1</span>&#125;,d2,d3;	<span class="comment">//可以对共用体变量进行初始化，但是初始化列表中只能有一个常量。</span></span><br><span class="line">d1.a=<span class="number">10</span>;</span><br><span class="line">d1.b=<span class="number">6.6</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(d1.c,”abcdefg”);	<span class="comment">//这里分别给共用体成员赋值</span></span><br></pre></td></tr></table></figure></div>

<p>#注意：由于共用体中的每个成员共用一段内存空间，所以共用体在同一时刻只能保存一个成员的值，也就是保存最后一个赋值的成员的值。</p>
<h3 id="2-3、共用体类型所占内存"><a href="#2-3、共用体类型所占内存" class="headerlink" title="2.3、共用体类型所占内存"></a>2.3、共用体类型所占内存</h3><p>由于共用体类型中所有成员是共用一段内存的，所以整个共用体类型所占内存是最大成员所占的内存空间（也存在内存补齐）。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line">&#125;d1,d2,d3;</span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,<span class="keyword">sizeof</span>(d1));	<span class="comment">//这里输出共用体的内存大小为16（两个double的大小）</span></span><br></pre></td></tr></table></figure></div>



<h2 id="3、枚举类型"><a href="#3、枚举类型" class="headerlink" title="3、枚举类型"></a>3、枚举类型</h2><h3 id="3-1、枚举类型的概念"><a href="#3-1、枚举类型的概念" class="headerlink" title="3.1、枚举类型的概念"></a>3.1、枚举类型的概念</h3><p>如果一个变量只有几种可能的取值，就可以定义为枚举类型，所谓的“枚举”就是指吧可能的值一一列举出来，枚举变量的取值范围只限于列举出来的值的范围内，也就是只能在值的集合内选择。</p>
<p>枚举类型本质上是作为int类型数据做运算的，也可以将枚举类型看成取值范围受限的整型。</p>
<h3 id="3-2、枚举类型的声明"><a href="#3-2、枚举类型的声明" class="headerlink" title="3.2、枚举类型的声明"></a>3.2、枚举类型的声明</h3><p>枚举类型关键字：enum</p>
<p>枚举类型定义的基本格式：enum 类型名{枚举元素列表};</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span>&#123;</span>sun,mon,tue,wed,thu,fri,sat&#125;;</span><br><span class="line"><span class="comment">//以上声明了一个枚举类型的变量Weekday，用于表示星期，其变量的取值范围为星期天至星期六</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-3、枚举变量的定义"><a href="#3-3、枚举变量的定义" class="headerlink" title="3.3、枚举变量的定义"></a>3.3、枚举变量的定义</h3><p>根据以上声明我们可以定义此枚举类型的变量。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">workday</span>,<span class="title">weekend</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>其中workday和weekend是此枚举类型的变量，其每个变量的取值范围为集合{sun,mon,tue,wed,thu,fri,sat}中的一个值。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">workday=mon;</span><br><span class="line">weekend=sun; </span><br><span class="line"></span><br><span class="line">workday=abc;	<span class="comment">//错误，不存在枚举值abc</span></span><br></pre></td></tr></table></figure></div>

<p>可以在声明时同时定义变量。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span>&#123;</span>sun,mon,tue,wed,thu,fri,sat&#125;workday,weekend;</span><br></pre></td></tr></table></figure></div>

<p>声明的枚举类型也可以没有类型名，但如果需要使用此枚举类型的话，就必须在声明时同时定义变量。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>sun,mon,tue,wed,thu,fri,sat&#125;workday,weekend;</span><br></pre></td></tr></table></figure></div>

<p>说明：</p>
<p>（1）在C语言中枚举类型的枚举元素是按照常量进行处理的，所以又称为枚举常量。不要因为它们是标识符而把它们当作变量来使用，在使用时是不能对它们赋值的。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">sun=<span class="number">0</span>;	mon=<span class="number">1</span>;	sun = <span class="number">7</span>; <span class="comment">//错误，不能给枚举常量赋值</span></span><br></pre></td></tr></table></figure></div>

<p>（2）每一个枚举元素都代表一个整数，C语言编译器按照定义时的顺序默认它们的值为0，1，2，3，4，5，6……。在上面的声明中，sun的值为0，mon的值为1，tue的值为2，依次类推。</p>
<p>如果有赋值语句：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">workday=mon;</span><br></pre></td></tr></table></figure></div>

<p>就相当于：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">workday=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>枚举常量的引用和输出：</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“%d”,sun);<span class="comment">//输出整数0</span></span><br></pre></td></tr></table></figure></div>

<p>枚举变量的引用和输出：</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">workday=mon;</span><br><span class="line"><span class="built_in">printf</span>(“%d”,workday);<span class="comment">//输出整数1</span></span><br></pre></td></tr></table></figure></div>

<p>（3）我们也可以人为的指定枚举元素的数值，在声明的枚举类型的时候显式指定。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span>&#123;</span>sun=<span class="number">7</span>,mon=<span class="number">1</span>,tue,wed,thu,fri,sat&#125;workday,weekend;</span><br></pre></td></tr></table></figure></div>

<p>指定枚举常量sun的值为7，mon的值为1，之后的值顺序加1，也就是tue的值为2，sat的值为6。</p>
<p>由于枚举类型的值为整数，因此C99把枚举类型也作为整型数据的一种，即用户自己定义的整数类型。</p>
<p>（4）枚举类型可以用来比较和判断。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(workday==mon)&#123;……&#125;</span><br><span class="line"><span class="keyword">if</span>(workday&lt;=sat)&#123;……&#125;</span><br></pre></td></tr></table></figure></div>

<p>枚举类型的比较规则是按照其初始化时指定的整数大小来进行比较的。如果声明时没有人为指定，就按默认规则处理，即第一个枚举元素的值为0，第二个枚举元素的值为1，依次类推，所以mon&gt;sun,sat&gt;fri。</p>
<h3 id="3-4、枚举类型应用举例"><a href="#3-4、枚举类型应用举例" class="headerlink" title="3.4、枚举类型应用举例"></a>3.4、枚举类型应用举例</h3><p>猜拳游戏：玩家输入1、2、3进行猜拳。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">InputType</span>&#123;</span> 石头, 剪刀, 布 &#125;;	<span class="comment">//猜拳枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FingerGuessing</span><span class="params">()</span>	<span class="comment">//猜拳游戏</span></span><br><span class="line">&#123;</span><br><span class="line">	InputType computer, player;		<span class="comment">//电脑和玩家</span></span><br><span class="line">	srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));	<span class="comment">//随机种子</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		computer = (InputType)(rand() % <span class="number">3</span>);	<span class="comment">//电脑随机猜拳</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n猜拳游戏\n0、石头\n1、剪刀\n2、布\n请猜拳：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;player);</span><br><span class="line">		<span class="keyword">switch</span> (player)	<span class="comment">//比较玩家猜的拳</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> 石头:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;玩家：石头\n&quot;</span>);</span><br><span class="line">			<span class="keyword">switch</span> (computer)	<span class="comment">//比较电脑猜的拳</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> 石头:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：石头\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;平局！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 剪刀:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：剪刀\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家赢了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 布:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：布\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家输了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> 剪刀:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;玩家：剪刀\n&quot;</span>);</span><br><span class="line">			<span class="keyword">switch</span> (computer)	<span class="comment">//比较电脑猜的拳</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> 石头:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：石头\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家输了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 剪刀:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：剪刀\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;平局！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 布:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：布\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家赢了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> 布:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;玩家：布\n&quot;</span>);</span><br><span class="line">			<span class="keyword">switch</span> (computer)	<span class="comment">//比较电脑猜的拳</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> 石头:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：石头\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家赢了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 剪刀:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：剪刀\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家输了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 布:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：布\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;平局！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FingerGuessing();</span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="九、C语言文件操作"><a href="#九、C语言文件操作" class="headerlink" title="九、C语言文件操作"></a>九、C语言文件操作</h1><h2 id="1、什么是文件？"><a href="#1、什么是文件？" class="headerlink" title="1、什么是文件？"></a>1、什么是文件？</h2><p>文件有不同的类型，在程序设计中，主要用到两种文件：</p>
<p>（1）程序文件。包括源程序文件（后缀名为.c）、目标文件（后缀名为.obj）、可执行文件（后缀名为.exe）等。这一类型的文件主要用于存储程序代码。</p>
<p>（2）数据文件。此文件的内容不是程序，而是程序运行时读写的数据，比如程序运行过程中输出到磁盘或其他设备上的数据，或在程序运行过程中供程序读取的数据。</p>
<p>这里C语言的文件操作主要是对数据文件的操作。</p>
<p>在之前程序中所处理的数据的输入和输出都是以终端为对象的，都是从键盘输入数据，然后运行结果输出到终端显示器上。实际上，我们有时候需要将一些数据（程序运行的最终结果或者中间数据）保存起来，方便以后需要时再调用，而这就需要用到磁盘文件了。</p>
<h3 id="1-1、文件的概念"><a href="#1-1、文件的概念" class="headerlink" title="1.1、文件的概念"></a>1.1、文件的概念</h3><p>每一个文件都需要一个唯一的文件标识，以便用户使用，就像我们的变量名一样，同一程序中不能有相同的变量名。</p>
<p>文件标识也称为文件名，它由3部分组成：</p>
<p>①文件路径：表示文件在外存设备中的存储位置；</p>
<p>②文件名主干：表示文件的名字，可由用户自定义，命名规则应遵循标识符的命名规则。</p>
<p>③文件后缀：表示文件的性质，也称为文件的格式，用于描述文件的类型（如txt、ppt等）。</p>
<p>文件路径能唯一标识文件在外存中的位置。</p>
<p>如：D:\C++\VSproject\TEXT\text.c</p>
<h3 id="1-2、文件的分类"><a href="#1-2、文件的分类" class="headerlink" title="1.2、文件的分类"></a>1.2、文件的分类</h3><p>根据数据的组织形式，数据文件可分为ASCII文件和二进制文件。</p>
<p>数据在内存中是以二进制形式存储的，如果不加转换的输出到外存，就是二进制文件，可以认为它是存储在内存的数据的映像，所以称之为映像文件。如果要求在外存上以ASCII码形式存储，就需要在存储前进行转换。ASCII文件又称为文本文件，每一个字节存放一个字符的ACSII码。</p>
<h3 id="1-3、文件存储方法的区别"><a href="#1-3、文件存储方法的区别" class="headerlink" title="1.3、文件存储方法的区别"></a>1.3、文件存储方法的区别</h3><p>一个数据在磁盘上存储，字符一律以ASCII形式存储，数值型既可以用ASCII形式存储也可以用二进制形式存储。如整数10000，用ASCII码形式存储在磁盘上占5个字节（每个字符占一个字节），而用二进制形式存储在磁盘上只占4个字节（00000000 00000000 00100111 00010000‬）。用ASCII形式存储时字符与字节一一对应，一个字节代表一个字符，便于逐个处理，但占的存储空间较多，而且处理的时候要花费转换时间（二进制与ASCII码之间的转换）。二进制形式存储就相当于直接把内存中的内容原封不动存储在磁盘上，由于不需要转换，所以二进制文件更加方便计算机处理。</p>
<h2 id="2、指向文件的指针"><a href="#2、指向文件的指针" class="headerlink" title="2、指向文件的指针"></a>2、指向文件的指针</h2><p>C语言要想操作内存，需要用到各种数据类型的指针，而文件也是需要调用到内存中才能够使用，所以就需要用到“指向文件的指针”，就是“文件类型的指针”，简称“文件指针”。</p>
<p>每一个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的相关信息（如文件的名字、文件的状态和文件的位置等）。这些信息是保存在一个结构体变量中的，此结构体类型是由系统声明的，取名为FILE，其被包含在stdio.h头文件中。</p>
<h3 id="2-1、文件指针的定义"><a href="#2-1、文件指针的定义" class="headerlink" title="2.1、文件指针的定义"></a>2.1、文件指针的定义</h3><p>由于文件类型已经在stdio.h头文件中有声明了，所以我们不需要另外声明，直接使用就行了。</p>
<p>文件指针的定义格式为：FILE *指针类型名;</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp;</span><br></pre></td></tr></table></figure></div>

<p>定义一个指针fp用于指向FILE类型的数据，可以使fp指向某一个文件在内存中的文件信息区（结构体变量），通过此文件信息区能够访问此文件。也就是说通过文件指针变量能够找到并可以操作其指向的文件。</p>
<h3 id="2-2、打开与关闭文件"><a href="#2-2、打开与关闭文件" class="headerlink" title="2.2、打开与关闭文件"></a>2.2、打开与关闭文件</h3><p>（1）用fopen函数打开文件</p>
<p>​	C语言规定用文件标准输入输出函数fopen来实现打开文件。</p>
<p>fopen函数的调用方式为：</p>
<p>​	fopen(文件名,使用文件的方式);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fopen(<span class="string">&quot;text1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>):</span><br><span class="line">	<span class="comment">//以只读的方式打开名为“text1.txt”文件。</span></span><br></pre></td></tr></table></figure></div>

<p>此时fopen函数返回的是“text1.txt”文件的起始地址，我们通常将fopen函数的返回值赋值给一个文件指针，用文件指针指向此文件的地址。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp;<span class="comment">//定义一个文件指针fp</span></span><br><span class="line">fp=fopen(<span class="string">&quot;text1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//使fp指向文件“text1.txt”的首地址</span></span><br></pre></td></tr></table></figure></div>

<p>这样fp就与文件“text1.txt”有联系了。在打开一个文件时，给定编译系统以下3个信息：</p>
<p>①需要打开的文件名称；②文件的打开方式；③使用哪个文件指针指向被打开的文件。</p>
<p>（2）文件的打开方式</p>
<p>文件打开方式与含义如下表所示：</p>
<table>
<thead>
<tr>
<th>文件的打开方式</th>
<th>含义</th>
<th>如果指定的文件不存在</th>
</tr>
</thead>
<tbody><tr>
<td>“r”（只读）</td>
<td>为了输入数据，打开一个已存在的文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“w”（只写）</td>
<td>为了输出数据，打开一个文本文件</td>
<td>新建文件</td>
</tr>
<tr>
<td>“a”（追加）</td>
<td>向文本文件尾部添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>“rb”（只读）</td>
<td>为了输入数据，打开一个已存在的二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>“wb”（只写）</td>
<td>为了输出数据，打开一个二进制文件</td>
<td>新建文件</td>
</tr>
<tr>
<td>“ab”（追加）</td>
<td>向二进制文件尾部添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>“r+”（读写）</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“w+”（读写）</td>
<td>为了读和写，打开一个文本文件</td>
<td>新建文件</td>
</tr>
<tr>
<td>“a+”（读写）</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“rb+”（读写）</td>
<td>为了读和写，打开一个二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>“wb+”（读写）</td>
<td>为了读和写，打开一个二进制文件</td>
<td>新建文件</td>
</tr>
<tr>
<td>“ab+”（读写）</td>
<td>为了读和写，打开一个二进制文件</td>
<td>出错</td>
</tr>
</tbody></table>
<p>（3）用fclose函数关闭文件</p>
<p>在使用完一个文件之后，为了防止它被误用，应该关闭它。“关闭”就是撤销文件信息区和文件缓冲区，使指针不再指向此文件了，也无法操作此文件了，除非重新打开此文件，使指针指向此文件。</p>
<p>关闭文件用fclose函数。</p>
<p>fclose函数的基本格式为：</p>
<p>​	fclose(文件指针);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure></div>

<p>在每次程序终止之前都要养成习惯关闭所有的文件，当fclose函数成功关闭文件时，返回0；否则返回EOF（-1）。</p>
<h2 id="3、顺序读写文件"><a href="#3、顺序读写文件" class="headerlink" title="3、顺序读写文件"></a>3、顺序读写文件</h2><p>文件打开完成之后就可以对它进行读写操作了。</p>
<p>常用的文件操作函数如下所示：</p>
<h3 id="3-1、字符输入和输出函数"><a href="#3-1、字符输入和输出函数" class="headerlink" title="3.1、字符输入和输出函数"></a>3.1、字符输入和输出函数</h3><p>（1）字符读取函数<br>使用字符读取函数fgetc从文件读取一个字符</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">ch=fgetc(fp);</span><br></pre></td></tr></table></figure></div>

<p>从文件指针fp指向的位置读取一个字符存入字符变量ch中，</p>
<p>读取成功返回所读的字符，失败则返回为你文件结束标志EOF（-1）。</p>
<p>（2）字符写入函数<br>使用字符写入函数fputc向文件写入一个字符。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fputc(ch,fp);</span><br></pre></td></tr></table></figure></div>

<p>向文件指针fp指向的位置写入字符ch，写入成功返回输出的字符，失败则返回EOF（-1）</p>
<h3 id="3-2、字符串输入和输出函数"><a href="#3-2、字符串输入和输出函数" class="headerlink" title="3.2、字符串输入和输出函数"></a>3.2、字符串输入和输出函数</h3><p>（1）字符串读取函数<br>使用字符串读取函数fgets从文件读取一个字符串。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fgets(str,n,fp);</span><br></pre></td></tr></table></figure></div>

<p>从文件指针fp指向的位置读取一个长度位n-1的字符串（最后一位赋值‘\0’，用作字符串结束标志），存放在字符数组str中。</p>
<p>读取成功返回地址str，失败则返回NULL。</p>
<p>（2）字符串写入函数<br>使用字符串写入函数fputs向文件写入一个字符串。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(str，fp);</span><br></pre></td></tr></table></figure></div>

<p>把str所指向的字符串写入文件指针fp指向的位置，写入成功返回0，否则返回非0值。</p>
<h3 id="3-3、文件格式化输入和输出函数"><a href="#3-3、文件格式化输入和输出函数" class="headerlink" title="3.3、文件格式化输入和输出函数"></a>3.3、文件格式化输入和输出函数</h3><p>（1）格式化输出函数<br>使用格式化输出函数fprintf向文件写入数据：</p>
<p>​	fprintf(文件指针,”格式化字符串”,输出列表);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d,%c&quot;</span>,x,y);</span><br></pre></td></tr></table></figure></div>

<p>将变量x以整型的形式写入文件指针fp指向的位置，把变量y以字符的形式写入文件指针fp指向的位置。</p>
<p>（2）格式化输入函数<br>使用格式化输入函数fscanf从文件读取数据：</p>
<p>​	fscanf(文件指针,”格式化字符串”,输入列表);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d,%f&quot;</span>,&amp;x,&amp;y);</span><br></pre></td></tr></table></figure></div>

<p>从文件指针fp指向的位置读入一个整型数据和一个单精度型数据，分别存入变量x和变量y中。</p>
<h3 id="3-4、以二进制的形式读写数据"><a href="#3-4、以二进制的形式读写数据" class="headerlink" title="3.4、以二进制的形式读写数据"></a>3.4、以二进制的形式读写数据</h3><p>（1）二进制读取函数</p>
<p>使用fread函数以二进制的形式从文件读出数据：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fread(arr,size,count,fp);</span><br></pre></td></tr></table></figure></div>

<p>把数组arr中size个count大小的数据放入文件指针fp所指向的文件中。</p>
<p>arr是一个地址（数组），用于存储从文件读取出来的数据，size为需要读取的字节数，count为需要读取数据项的个数（每个数据项的大小为size）。</p>
<p>（2）二进制写入函数</p>
<p>使用fwrite函数以二进制的形式向文件写入数据：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fwrite(arr,size,count,fp);</span><br></pre></td></tr></table></figure></div>

<p>从文件指针fp所指向的文件中读取size个count大小的数据放入数组arr中。</p>
<h2 id="4、随机读写文件"><a href="#4、随机读写文件" class="headerlink" title="4、随机读写文件"></a>4、随机读写文件</h2><p>可以通过改变文件指针的位置标记及定位来实现文件的随机读写。</p>
<h3 id="4-1、强制使文件指针指向文件开头"><a href="#4-1、强制使文件指针指向文件开头" class="headerlink" title="4.1、强制使文件指针指向文件开头"></a>4.1、强制使文件指针指向文件开头</h3><p>使用rewind函数强制使文件指针fp指向文件开头的位置。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">rewind(fp);</span><br></pre></td></tr></table></figure></div>

<h3 id="4-2、使文件指针指向文件中的任意位置"><a href="#4-2、使文件指针指向文件中的任意位置" class="headerlink" title="4.2、使文件指针指向文件中的任意位置"></a>4.2、使文件指针指向文件中的任意位置</h3><p>使用fseek函数使文件指针指向文件中任意位置。</p>
<p>基本格式：<br>    fseek(fp,位移量,起始点);</p>
<p>起始点用0、1、2代替，0代表文件开始位置，1代表当前位置，2代表文件末尾位置。<br>位移量是指以起始点为基础，向前移动的字节数，其为long类型的参数。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">fseek(fp,<span class="number">100</span>,<span class="number">0</span>);	<span class="comment">//将文件指针fp向后移动到离文件开头100个字节处</span></span><br><span class="line">fseek(fp,<span class="number">50</span>,<span class="number">1</span>);	<span class="comment">//将文件指针fp向后移动到离当前位置50个字节处</span></span><br><span class="line">fseek(fp,<span class="number">-10</span>,<span class="number">2</span>);	<span class="comment">//将文件指针fp向前移动到离文件末尾10个字节处</span></span><br></pre></td></tr></table></figure></div>

<p>fseek一般用于二进制文件。</p>
<p>用rewind和fseek函数实现随机读写。</p>
<h2 id="5、文件的出错检测"><a href="#5、文件的出错检测" class="headerlink" title="5、文件的出错检测"></a>5、文件的出错检测</h2><h3 id="5-1、文件读写出错检测"><a href="#5-1、文件读写出错检测" class="headerlink" title="5.1、文件读写出错检测"></a>5.1、文件读写出错检测</h3><p>ferror函数用于检测文件读写出错，如果文件读写正常返回0，出错则返回非零值。</p>
<p>基本格式：</p>
<p>​	ferror(fp)；</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ferror(fp))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“文件读写失败！”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-2、文件末尾判断"><a href="#5-2、文件末尾判断" class="headerlink" title="5.2、文件末尾判断"></a>5.2、文件末尾判断</h3><p>feof函数用于检测文件指针是否读到了文件末尾，如果文件指针读到了文件末尾则返回非零值，否则返回0。</p>
<p>基本格式：</p>
<p>​	feof(fp);</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(feof(fp))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“文件读写完毕！”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-3、文件错误标志"><a href="#5-3、文件错误标志" class="headerlink" title="5.3、文件错误标志"></a>5.3、文件错误标志</h3><p>clearerr函数的作用是使文件错误标志和文件结束标志置为0。如果在文件读写出错后，ferror函数值为一个非零值，应该立即调用clearerr(fp)，使ferror(fp)的值变为0，以便进行下次检测。</p>
<p>基本格式：</p>
<p>​	clearerr(fp);</p>
<p>注意：只要出现文件读写错误标志，它就会一直保留，直到调用clearerr函数或rewind函数，或其他任何一个输入输出函数。</p>
<h1 id="十、C语言的灵魂——指针"><a href="#十、C语言的灵魂——指针" class="headerlink" title="十、C语言的灵魂——指针"></a>十、C语言的灵魂——指针</h1><h2 id="1、什么是指针？"><a href="#1、什么是指针？" class="headerlink" title="1、什么是指针？"></a>1、什么是指针？</h2><p>在了解指针之前先要弄清楚地址的概念。</p>
<p>如果在程序中定义了一个变量，在对程序进行编译时，系统就会给这个变量分配内存单元。编译系统根据城西中定义的变量类型，分配一定长度的空间。例如：整型变量分配4个字节，字符型分配1个字节，单精度分配4个字节等。内存区的每一个字节有一个编号，这就是“地址编号”，它就相当于旅馆中的房间号，每一个房间都可以看作一块内存区域，都可以用来存放东西，我们给每个房间都编一个房间门牌号，用于更好的区分每一个房间，内存中也是一样的，整个内存由很多个字节组成，每个字节都有其对应的“房间号”，这就是“地址”了。通过这个“房间号”就可以找到其对应的“房间”，然后就可以从房间里取东西，或者把东西放进房间里了。</p>
<p>理解了地址的概念之后，那所谓的指针，就是内存地址，也就是地址的编号，可以把“指针指向地址”理解成“用小本本把房间号记下来”，那这个小本本就相当于一个用于记房间号的指针了，一个变量的地址称为此变量的“指针”。</p>
<h2 id="2、指针常量与指针变量"><a href="#2、指针常量与指针变量" class="headerlink" title="2、指针常量与指针变量"></a>2、指针常量与指针变量</h2><h3 id="2-1、指针常量"><a href="#2-1、指针常量" class="headerlink" title="2.1、指针常量"></a>2.1、指针常量</h3><p>之前有了解过不同数据类型的变量所占内存字节数的这个概念，那么系统在编译时给一个变量分配的内存地址就称为此变量的“指针”，这个指针的指向是无法改变的，所以又称为指针常量，数组的地址也是指针常量（也称为地址常量）。</p>
<h3 id="2-2、指针变量"><a href="#2-2、指针变量" class="headerlink" title="2.2、指针变量"></a>2.2、指针变量</h3><p>（1）指针变量的概念</p>
<p>如果有一个变量专门用来存放另一个变量的地址，则称这个变量为“指针变量”，也就是说C语言中有一类变量是专门用来存储（指向）地址的，我们将它称为“指针变量”，指针变量的中存储的地址可以被改变，也就是可以改变指针变量的指向，就好比一张纸或一个小本本，写着一个房间的房间号，那把这个房间的房间号擦掉，写上另一个房间的房间号也是可以的，这就是指针变量和指针常量最大的区别所在了，可以改变指针变量的指向。</p>
<p>（2）指针变量的定义</p>
<p>定义指针变量的一般格式：</p>
<p>类型名 *指针变量名;</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p,*q;</span><br><span class="line"><span class="type">char</span> *p1,*q1;</span><br><span class="line"><span class="type">double</span> *p2,*q2;</span><br></pre></td></tr></table></figure></div>

<p>注意：左端的int、char等是在定义指针变量时必须指定的“基类型”。指针变量的基类型用来规定此指针变量可以指向的变量的类型。如：上面定义的p和q只能用于指向int整型变量的地址，p2和q2只能用于指向double双精度类型变量的地址。</p>
<p>（3）指针变量的引用</p>
<p>与指针和地址相关运算符：’*’（指针运算符）和’&amp;’（取地址运算符）这里的取地址运算符要区别对待位运算符&amp;</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a,*p;	p=&amp;a;	*p=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>在引用指针变量时，有以下几种情况：</p>
<p>①给指针变量赋值</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="comment">//定义一个整型指针变量p，初始化p的值为a的地址，也就是p指向a地址</span></span><br></pre></td></tr></table></figure></div>

<p>②解引用<br>解引用就是通过指针使用其所指向地址中存储的数据。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">*p=<span class="number">30</span>;	<span class="comment">//通过指针变量p引用a变量，改变a的值为30</span></span><br><span class="line">	<span class="comment">//这里的’*’为解引用符号，p引用指针变量p所指向地址中对应的值</span></span><br><span class="line"><span class="built_in">scanf</span>(“%d”,p);	<span class="comment">//scanf通过指针变量p给变量a赋值</span></span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,*p);	<span class="comment">//通过指针变量p解引用输出变量a的值</span></span><br><span class="line">*p=b;	<span class="comment">//将b的值放入指针变量p所指向的内存地址中（a的地址单元中）</span></span><br><span class="line">p=&amp;b;	<span class="comment">//改变指针p的指向，指针p不再指向a的地址了，而是指向b的地址</span></span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,*p);	<span class="comment">//输出变量b的值</span></span><br></pre></td></tr></table></figure></div>

<p>③输出内存地址编号</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“%p\n”,p);	<span class="comment">//以十六进制的格式输出指针变量p所指向地址的内存地址编号</span></span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,&amp;a);	<span class="comment">//以十进制的格式输出变量a所在的内存地址编号</span></span><br><span class="line"><span class="built_in">printf</span>(“%o\n”,&amp;b);	<span class="comment">//以八进制的格式输出变量b所在的内存地址编号</span></span><br><span class="line"><span class="built_in">printf</span>(“%p\n”,&amp;p);	<span class="comment">//以十六进制的格式输出指针变量p所在的内存地址编号</span></span><br></pre></td></tr></table></figure></div>



<h2 id="3、指针变量作为函数参数"><a href="#3、指针变量作为函数参数" class="headerlink" title="3、指针变量作为函数参数"></a>3、指针变量作为函数参数</h2><p>函数的参数不仅可以是整型、浮点型、字符型的数据，还可以是指针类型。它的作用是将一个变量的地址传递到另一个函数中。</p>
<h3 id="3-1、函数参数为指针类型的函数"><a href="#3-1、函数参数为指针类型的函数" class="headerlink" title="3.1、函数参数为指针类型的函数"></a>3.1、函数参数为指针类型的函数</h3><p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;<span class="comment">//这里定义了一个普通函数fun1</span></span><br><span class="line">	<span class="built_in">printf</span>(“x=%d\ty=%d\n”,x++,y++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> *y)</span></span><br><span class="line">&#123;<span class="comment">//这里定义了一个形参为整型指针类型函数fun2,其形参为指针类型的变量</span></span><br><span class="line">	<span class="built_in">printf</span>(“x=%d\ty=%d\n”,*x++,*y++);</span><br><span class="line">	<span class="comment">//注意：和printf(“x=%d\ty=%d\n”,x++,y++);的区别，也就是没有和有的区别</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,*p,*q;</span><br><span class="line">	fun(a,b);	<span class="comment">//调用普通函数fun1</span></span><br><span class="line">	<span class="built_in">printf</span>(“a=%d\tb=%d\n”,a,b);</span><br><span class="line">	fun2(&amp;a,&amp;b);	<span class="comment">//这里调用函数fun时，所传递的实参必须是地址</span></span><br><span class="line">	<span class="built_in">printf</span>(“a=%d\tb=%d\n”,a,b);</span><br><span class="line">	p=&amp;a;	<span class="comment">//使用整型指针变量p指向整型变量a的地址</span></span><br><span class="line">	q=&amp;b;	<span class="comment">//使用整型指针变量q指向整型变量b的地址</span></span><br><span class="line">	fun(p,q);	<span class="comment">//这里使用指针变量p和q作为实参传递</span></span><br><span class="line">	<span class="built_in">printf</span>(“p=%d\tq=%d\n”,*p,*q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、指针函数"><a href="#3-2、指针函数" class="headerlink" title="3.2、指针函数"></a>3.2、指针函数</h3><p>函数返回值为指针类型的函数称为“指针函数”，通常用来返回一个地址。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">fun3</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> y)</span><span class="comment">//这是一个指针函数，返回值类型为整型int指针类型</span></span><br><span class="line">&#123;</span><br><span class="line">	*x+=y;</span><br><span class="line">	<span class="built_in">printf</span>(“%d”,++*x);</span><br><span class="line">	<span class="keyword">return</span> x;	<span class="comment">//返回指针变量x所指向的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="4、通过指针引用数组"><a href="#4、通过指针引用数组" class="headerlink" title="4、通过指针引用数组"></a>4、通过指针引用数组</h2><h3 id="4-1、数组元素的地址"><a href="#4-1、数组元素的地址" class="headerlink" title="4.1、数组元素的地址"></a>4.1、数组元素的地址</h3><p>数组元素的地址表示：</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,*p;</span><br><span class="line">&amp;a[<span class="number">0</span>];	<span class="comment">//引用数组元素a[0]地址的表示方法</span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-2、指针指向数组元素"><a href="#4-2、指针指向数组元素" class="headerlink" title="4.2、指针指向数组元素"></a>4.2、指针指向数组元素</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">p=&amp;a[<span class="number">1</span>];	<span class="comment">//指针变量p指向数组元素a[1]的地址</span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-3、指针指向的移动（指针的偏移）"><a href="#4-3、指针指向的移动（指针的偏移）" class="headerlink" title="4.3、指针指向的移动（指针的偏移）"></a>4.3、指针指向的移动（指针的偏移）</h3><p>指针的偏移：指针每次会以其基类型所占字节数为单位进行偏移。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">p=&amp;a[<span class="number">0</span>];</span><br><span class="line">++*p;	<span class="comment">//指针指向地址中的数值加1</span></span><br><span class="line"><span class="built_in">printf</span>(“%<span class="meta">#p\n”,p);	<span class="comment">//打印指针变量p所指向的地址编号</span></span></span><br><span class="line">p++;	<span class="comment">//指针移动到数组元素a[1]的位置</span></span><br><span class="line"><span class="built_in">printf</span>(“%#X\n”,p);	<span class="comment">//打印移动后指针变量p所指向的地址编号</span></span><br><span class="line"><span class="comment">//指针变量++（或--）移动一次是移动其基类型大小的内存区域</span></span><br></pre></td></tr></table></figure></div>

<p>使用指针的偏移输入&#x2F;输出数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%d”,*(p+i));	<span class="comment">//通过指针移动引用数组元素，输出数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%d”,p[i]));	<span class="comment">//通过指针带下标的形式引用数组元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-4、指针指向字符串"><a href="#4-4、指针指向字符串" class="headerlink" title="4.4、指针指向字符串"></a>4.4、指针指向字符串</h3><p>指针可以用于直接引用字符串常量。<br>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = “abcdefg”;</span><br><span class="line"><span class="keyword">while</span> (*p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, *p++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：可能VS某些版本需要在指针定义之前加一个const定义指针为常量指针</p>
<h2 id="5、指向函数的指针（函数指针）"><a href="#5、指向函数的指针（函数指针）" class="headerlink" title="5、指向函数的指针（函数指针）"></a>5、指向函数的指针（函数指针）</h2><p>之前有学到过函数参数是指针类型的函数以及指针函数，熟悉了一些基本的指针与函数的应用，了解了变量的地址与指针变量。</p>
<p>思考一下：那既然变量有地址，数组也有地址，那么函数会有对应的地址么？</p>
<h3 id="5-1、什么是函数指针？"><a href="#5-1、什么是函数指针？" class="headerlink" title="5.1、什么是函数指针？"></a>5.1、什么是函数指针？</h3><p>首先，函数是会占内存空间的。在程序中定义了一个函数，在编译时，编译系统会为函数代码分配一段存储空间，这段存储空间就是函数的地址，这段地址的起始地址（又称入口地址）就称为这个函数的指针（或函数的首地址）。</p>
<p>既然函数也有地址，那么我们能不能用一个指针指向函数的地址呢？</p>
<p>既然都是地址，那么就可以用指针指向它。</p>
<p>指向整型变量地址的指针是整型指针，指向字符型变量地址的指针是字符型指针，指向单精度变量地址的指针是float型指针，那指向函数的指针是什么指针呢？</p>
<p>这就是接下来要接触到的函数指针了。</p>
<h3 id="5-2、函数指针的定义"><a href="#5-2、函数指针的定义" class="headerlink" title="5.2、函数指针的定义"></a>5.2、函数指针的定义</h3><p>简单来说，函数指针就是指向函数的指针。</p>
<p>定义函数指针的一般格式：*数据类型 (函数指针名)(函数参数列表);</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*funp)(<span class="type">int</span>,<span class="type">char</span>);</span><br><span class="line"><span class="comment">//定义了一个指针函数，用于指向返回值类型为int型、函数参数为(int,char)型的函数</span></span><br></pre></td></tr></table></figure></div>



<h3 id="5-3、函数指针的初始化及使用"><a href="#5-3、函数指针的初始化及使用" class="headerlink" title="5.3、函数指针的初始化及使用"></a>5.3、函数指针的初始化及使用</h3><p>函数指针可以用于指向与其类型匹配的函数。<br>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">funsum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;	<span class="comment">//求和函数</span></span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">funmax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;	<span class="comment">//求最大值函数</span></span><br><span class="line">	<span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">funmin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;	<span class="comment">//求最小值函数</span></span><br><span class="line">	<span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> (*funp)(<span class="type">int</span>,<span class="type">int</span>)=funsum;	<span class="comment">//定义一个函数指针funp，初始化赋值指向函数funsum</span></span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,c;	<span class="comment">//函数指针有以下两个赋值方式和两种调用方式</span></span><br><span class="line">	c=(*funp)(a,b);	<span class="comment">//通过函数指针funp调用函数funsum，(*)区分funp是个函数指针</span></span><br><span class="line">	funp=&amp;funmax;	<span class="comment">//改变函数指针funp的指向，&amp;取函数地址，使其指向函数funmax</span></span><br><span class="line">	c=funp(a,b);	<span class="comment">//此时是通过函数指针funp调用函数funmax</span></span><br><span class="line">	funp=funmin;	<span class="comment">//改变函数指针funp的指向，可以省略&amp;取址符，使其指向函数funmin</span></span><br><span class="line">	c=funp(a,b);	<span class="comment">//通过函数指针funp调用函数funmin</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="5-4、使用函数指针作为函数参数（回调函数）"><a href="#5-4、使用函数指针作为函数参数（回调函数）" class="headerlink" title="5.4、使用函数指针作为函数参数（回调函数）"></a>5.4、使用函数指针作为函数参数（回调函数）</h3><p>函数指针的一个重要的用途是把函数的地址作为参数传递到其他函数。</p>
<p>回调函数：通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就称这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> (fun)(<span class="type">int</span>,<span class="type">int</span>))</span></span><br><span class="line">&#123;<span class="comment">//这里的函数形式参数fun为函数指针类型</span></span><br><span class="line">	<span class="keyword">return</span> (*fun)(x,y);	<span class="comment">//可以通过函数fun调用其所指向的函数</span></span><br><span class="line">&#125;</span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>,sum);	<span class="comment">//调用时直接以函数名作为函数参数</span></span><br><span class="line">function(<span class="number">10</span>,<span class="number">20</span>,max);</span><br></pre></td></tr></table></figure></div>



<h3 id="5-5、使用typedef给函数指针取别名"><a href="#5-5、使用typedef给函数指针取别名" class="headerlink" title="5.5、使用typedef给函数指针取别名"></a>5.5、使用typedef给函数指针取别名</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> (*funp)(<span class="type">int</span>,<span class="type">int</span>);		<span class="comment">//给 (*)(int,int)类型的函数指针取一个别名为funp</span></span><br><span class="line">funp p1;	<span class="comment">//用别名funp定义()(int,int)类型的函数指针p1*</span></span><br><span class="line">p1 = sum;	<span class="comment">//函数指针p1指向函数sum</span></span><br><span class="line">p1(<span class="number">1</span>,<span class="number">2</span>);	<span class="comment">//通过函数指针p1调用函数</span></span><br></pre></td></tr></table></figure></div>

<h3 id="5-6、指针函数和函数指针的区别"><a href="#5-6、指针函数和函数指针的区别" class="headerlink" title="5.6、指针函数和函数指针的区别"></a>5.6、指针函数和函数指针的区别</h3><p>所谓的指针函数，其本质上是个函数，是返回值为指针类型的函数</p>
<p>所谓的函数指针，其本质上是个指针，是指向函数的指针</p>
<h2 id="6、指针数组和数组指针"><a href="#6、指针数组和数组指针" class="headerlink" title="6、指针数组和数组指针"></a>6、指针数组和数组指针</h2><h3 id="6-1、指针数组"><a href="#6-1、指针数组" class="headerlink" title="6.1、指针数组"></a>6.1、指针数组</h3><p>（1）什么指针数组</p>
<p>所谓指针数组，其本质上是一个数组，数组中的每一个元素都是指针类型的，都可以指向对应数据类型的地址。</p>
<p>（2）指针数组的定义</p>
<p>定义的一般格式：数据类型 *指针数组名[数组元素个数];</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">6</span>];	<span class="comment">//定义一个指针数组，有6个元素，分别可以指向六个地址</span></span><br></pre></td></tr></table></figure></div>

<p>（3）指针数组的使用</p>
<p>使用指针数组指向二维字符数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">10</span>][<span class="number">10</span>],*p[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p[i]=arr[i];	<span class="comment">//指针数组p中的每个元素指向二维数组arr的每一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(“%s”,p[i]);	<span class="comment">//使用指针数组p给二维数组arr赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%s”,p[i]);	<span class="comment">//使用指针数组p输出二维数组arr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用指针数组存储字符串的形式代替二维字符数组，达到省空间的目的</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> p[<span class="number">6</span>]=&#123;“abc”,”<span class="number">123456</span>”,”abcdefg”,”hello world!”,”xiaowei”,”x”&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-2、数组指针"><a href="#6-2、数组指针" class="headerlink" title="6.2、数组指针"></a>6.2、数组指针</h3><p>（1）什么是数组指针</p>
<p>所谓的数组指针，其本质上是一个指针，是一个用于指向数组地址的指针。</p>
<p>（2）数组指针的定义</p>
<p>定义的一般格式：数据类型 (指针变量名)[所指向数组的大小];*</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>];	<span class="comment">//定义一个整型数组指针p，用于指向大小为4的整型数组</span></span><br><span class="line">p=a;	<span class="comment">//将整型数组指针p指向二维数组a的第一行</span></span><br></pre></td></tr></table></figure></div>

<p>（3）数组指针的使用</p>
<p>使用数组指针完成二维数组的输入和输出</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a3;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">6</span>];</span><br><span class="line">p = a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,p[i][j]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>（4）数组指针的移动</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">p++;	<span class="comment">//移动一整行</span></span><br><span class="line">*(*(p+i)+j)	<span class="comment">//可以把数组指针理解成为一个二级指针，通过两次解引用得到元素值</span></span><br><span class="line">p[i][j];	<span class="comment">//指针带数组下标的形式访问数组元素</span></span><br></pre></td></tr></table></figure></div>



<h2 id="7、指针常量与常量指针"><a href="#7、指针常量与常量指针" class="headerlink" title="7、指针常量与常量指针"></a>7、指针常量与常量指针</h2><p>7.1、指针常量</p>
<p>指针常量就是指针的指向不能够被改变的指针，也就是指针类型的常量，指针中存储的地址不可被改变。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p;</span><br></pre></td></tr></table></figure></div>

<p>它的指向不能被改变，但是能够改变值。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b=<span class="number">20</span>; </span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> q = &amp;a; <span class="comment">//必须初始化指针指向 </span></span><br><span class="line">*q = <span class="number">30</span>; <span class="comment">//可以改变值 </span></span><br><span class="line"><span class="comment">//q = &amp;b; //错误：不能改变指针的指向 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*q);</span><br></pre></td></tr></table></figure></div>

<p>7.2、常量指针</p>
<p>常量指针就是指向常量的指针，也就是指针指向的地址内的值不可被改变，其又被称为只读指针。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br></pre></td></tr></table></figure></div>

<p>它的能够改变指向，但是不能够改变地址内的值</p>
<p>示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b=<span class="number">20</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p; </span><br><span class="line">p = &amp;a; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p); </span><br><span class="line"><span class="comment">//*p=30; //错误：不能通过指针改变变量的值 </span></span><br><span class="line">p = &amp;b; <span class="comment">//可以改变指针的指向 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p); </span><br></pre></td></tr></table></figure></div>

<p>指针常量和常量指针一般用于函数参数的传递，为了使在函数使用中不改变值以及指针的指向。</p>
<p>如：指向常量的指针常量</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p)</span> <span class="comment">//指向常量的指针常量 </span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//指针p是一个只读指针，既不能改变指针的指向，也不能改变其指向地址里的值，在函数中防止被篡改 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="8、动态内存分配"><a href="#8、动态内存分配" class="headerlink" title="8、动态内存分配"></a>8、动态内存分配</h2><h3 id="8-1、什么是动态内存分配"><a href="#8-1、什么是动态内存分配" class="headerlink" title="8.1、什么是动态内存分配"></a>8.1、什么是动态内存分配</h3><p>动态内存分配就是使用户可以根据自己的需要，向系统申请所需大小的内存空间；由于没有声明部分来定义它们是为变量的地址还是为数组的地址，所有只能通过指针来引用它们。</p>
<p>动态内存分配的内存空间可以像普通的变量或数组一样使用，也支持存入和取出数据。</p>
<h3 id="8-2、怎样建立内存的动态分配"><a href="#8-2、怎样建立内存的动态分配" class="headerlink" title="8.2、怎样建立内存的动态分配"></a>8.2、怎样建立内存的动态分配</h3><p>①使用malloc函数动态申请内存</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="type">int</span> size);</span><br></pre></td></tr></table></figure></div>

<p>malloc函数用于动态申请一个大小为size的内存区域，并返回这块区域的首地址。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">//动态开辟一块大小为100个字节的内存区域，并使指针s指向这块区域的首地址</span></span><br></pre></td></tr></table></figure></div>

<p>size可以直接写大小，但是一般有sizeof计算</p>
<p>②使用calloc函数动态申请数组内存</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="type">unsigned</span> n,<span class="type">int</span> size);</span><br></pre></td></tr></table></figure></div>

<p>calloc函数用于分配n个大小为size的连续内存区域，可以开辟一个一维数组大小的动态内存空间，n为数组元素个数，每个数组元素的大小为size。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="comment">//动态申请10个int类型大小的连续空间，并使指针p指向那块空间的首地址</span></span><br></pre></td></tr></table></figure></div>



<p>③使用realloc函数扩大&#x2F;缩小动态内存</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">realloc</span>(<span class="type">void</span> *p,<span class="type">unsigned</span> <span class="type">int</span> size);</span><br></pre></td></tr></table></figure></div>

<p>realloc函数用于重新分配已通过malloc函数或calloc函数开辟的内存空间，可以改变其内存空间的大小。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">realloc</span>(p,<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//将指针p所指向的动态内存区域调整为5个整型大小</span></span><br></pre></td></tr></table></figure></div>



<p>④使用free函数释放动态内存空间</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br></pre></td></tr></table></figure></div>

<p>free函数用于释放指针所指向的动态内存空间。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);	<span class="comment">//释放掉p指针所指向的动态内存</span></span><br></pre></td></tr></table></figure></div>

<p>用于释放指针变量p所指向的动态内存空间，使得这部分空间能被其他变量使用，否则这段内存空间需要等到程序结束后才会被释放。</p>
<p>每次使用完动态内存空间的时候记得释放内存空间。</p>
<p>开辟的内存空间大小size一般由sizeof(数据类型);来进行计算</p>
<p>（注意：以上函数的声明在stdlib.h头文件中，使用这些函数之前需要包含stdlib.h头文件）</p>
<h2 id="9、结构体指针"><a href="#9、结构体指针" class="headerlink" title="9、结构体指针"></a>9、结构体指针</h2><h3 id="9-1、指向结构体变量的指针"><a href="#9-1、指向结构体变量的指针" class="headerlink" title="9.1、指向结构体变量的指针"></a>9.1、指向结构体变量的指针</h3><p>所谓的结构体指针就是指向结构体变量的指针，一个结构体变量的起始地址就是这个结构体变量的指针。如果把一个结构体变量的起始地址存放在一个指针变量中，那么这个指针变量就指向此结构体变量。</p>
<h3 id="9-2、结构体指针的定义"><a href="#9-2、结构体指针的定义" class="headerlink" title="9.2、结构体指针的定义"></a>9.2、结构体指针的定义</h3><p>如有以下结构体：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">&#125;s1,s2,s3;</span><br></pre></td></tr></table></figure></div>

<p>则可以定义指向struct student类型结构体的指针：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">sp</span>;</span></span><br><span class="line">sp = &amp;s1;<span class="comment">//用struct student类型的结构体指针sp指向struct student类型的结构体变量s1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="9-3、通过结构体指针引用结构体成员"><a href="#9-3、通过结构体指针引用结构体成员" class="headerlink" title="9.3、通过结构体指针引用结构体成员"></a>9.3、通过结构体指针引用结构体成员</h3><p>指向结构体成员运算符：’-&gt;’</p>
<p>通过结构体指针引用结构体成员的基本格式：结构体指针名-&gt;结构体成员名</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">sp-&gt;id=<span class="number">100</span>;	<span class="comment">//通过结构体指针引用结构体成员用指向结构体成员运算符’-&gt;’</span></span><br><span class="line"><span class="built_in">printf</span>(“%s”,sp-&gt;name);</span><br></pre></td></tr></table></figure></div>



<h2 id="10、多重指针（多级指针）"><a href="#10、多重指针（多级指针）" class="headerlink" title="10、多重指针（多级指针）"></a>10、多重指针（多级指针）</h2><h3 id="10-1、什么是多重指针"><a href="#10-1、什么是多重指针" class="headerlink" title="10.1、什么是多重指针"></a>10.1、什么是多重指针</h3><p>之前有了解过变量、函数等都有其对应的地址，都可以由其对应数据类型的指针变量指向这个地址。那么指针变量也有地址么？</p>
<p>指针变量也是有其对应地址的，那么既然有地址，就可以用另一个指针变量指向它的地址，也就是指向指针变量地址的指针，简称指向指针的指针（双重指针&#x2F;二级指针）。而指向指针的指针也是有地址的，那又可以有指向其地址的指针，这就是多重指针了。</p>
<h3 id="10-2、多重指针的定义"><a href="#10-2、多重指针的定义" class="headerlink" title="10.2、多重指针的定义"></a>10.2、多重指针的定义</h3><p>定义双重指针（二级指针）基本格式：数据类型 **指针变量名;</p>
<p>定义三重指针（三级指针）基本格式：数据类型 ***指针变量名;</p>
<p>依次类推：四级指针、五级指针……</p>
<h3 id="10-3、多重指针的使用"><a href="#10-3、多重指针的使用" class="headerlink" title="10.3、多重指针的使用"></a>10.3、多重指针的使用</h3><p>如有以下定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,*p,**q,***r;	<span class="comment">//定义整型变量a、指针p、双重指针q、三重指针r</span></span><br></pre></td></tr></table></figure></div>

<p>就可以有以下赋值语句：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">p=&amp;a;	<span class="comment">//使一级指针p指向变量a的地址</span></span><br><span class="line">q=&amp;p;	<span class="comment">//使双重指针q指向一级指针p的地址</span></span><br><span class="line">r=&amp;q;	<span class="comment">//使三重指针r指向双重指针q的地址</span></span><br><span class="line">*p=<span class="number">20</span>;	<span class="comment">//使用一级指针p给变量a赋值</span></span><br><span class="line">**q=<span class="number">30</span>;	<span class="comment">//使用二级指针q给变量a赋值</span></span><br><span class="line">***r=<span class="number">40</span>;	<span class="comment">//使用三级指针r给变量a赋值</span></span><br></pre></td></tr></table></figure></div>

<h3 id="10-4、双重指针作为函数形参"><a href="#10-4、双重指针作为函数形参" class="headerlink" title="10.4、双重指针作为函数形参"></a>10.4、双重指针作为函数形参</h3><p>一般来说函数的形参无法改变实参，除非形参是指针类型的。那么如果实参是一个指针，想要在一个函数中改变一个指针的指向应该怎么做？ </p>
<p>例如：若定义了以下函数fun，如果指针p是该函数的形参，要求通过p把动态分配存储单元的首地址传回主调函数，则形参p应当怎样正确定义?</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(……)</span></span><br><span class="line">&#123;</span><br><span class="line">	*p=(<span class="type">int</span> )<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">	fun(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里形参p的类型应该定义为整型双重指针类型：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **p;</span><br></pre></td></tr></table></figure></div>

<p>双重指针可用于在函数中改变一级指针的指向。</p>
<h2 id="11、内存四区"><a href="#11、内存四区" class="headerlink" title="11、内存四区"></a>11、内存四区</h2><p>在系统为程序开辟内存时，将内存区域划分为4部分，分别为：</p>
<p>栈区：存放函数的形参、局部变量等。由编译器自动分配和释放，当函数执行完毕时自动释放。</p>
<p>堆区：用于动态内存的申请与释放，一般由程序员手动分配和释放，若程序员不释放，则程序结束时由操作系统回收。</p>
<p>全局静态常量区（全局区）：存放常量（一般是字符串常量和其他常量）、全局变量和静态变量，在程序结束后由操作系统释放。</p>
<p>代码区：存放可执行的代码，一般为CPU 执行的机器指令。</p>
<h1 id="十一、排序算法"><a href="#十一、排序算法" class="headerlink" title="十一、排序算法"></a>十一、排序算法</h1><h2 id="1、排序的基本概念"><a href="#1、排序的基本概念" class="headerlink" title="1、排序的基本概念"></a>1、排序的基本概念</h2><h3 id="1-1、什么是排序？"><a href="#1-1、什么是排序？" class="headerlink" title="1.1、什么是排序？"></a>1.1、什么是排序？</h3><p>排序是指把一组数据以某种关系（递增或递减）按顺序排列起来的一种算法。</p>
<p>例如：数列 8、3、5、6、2、9、1、0、4、7</p>
<p>递增排序后 0、1、2、3、4、5、6、7、8、9</p>
<p>递减排序后 9、8、7、6、5、4、3、2、1、0 </p>
<h3 id="1-2、排序的稳定性"><a href="#1-2、排序的稳定性" class="headerlink" title="1.2、排序的稳定性"></a>1.2、排序的稳定性</h3><p>如果在一组需要排序的数据序列中，数据ki和kj的值相同，即ki&#x3D; &#x3D;kj，且在排序前ki在序列中的位置领先于kj，那么当排序后，如果ki和kj的相对前后次序保持不变，即ki仍然领先于kj，则称此类排序算法是稳定的。如果ki和kj的相对前后次序变了，即kj领先于ki了，则称此类排序算法是不稳定的。</p>
<h3 id="1-3、排序的分类"><a href="#1-3、排序的分类" class="headerlink" title="1.3、排序的分类"></a>1.3、排序的分类</h3><p>●内部排序：指待排序数据全部存放在内存中进行排序的过程。</p>
<p>●外部排序：指待排序数据的数量很大，内存无法全部容纳所有数据，在排序过程中需要对外存进行访问的排序过程。</p>
<h3 id="1-4、排序的过程"><a href="#1-4、排序的过程" class="headerlink" title="1.4、排序的过程"></a>1.4、排序的过程</h3><p>排序的过程中需要进行如下两种基本操作：</p>
<p>（1）比较两个数据的大小；</p>
<p>（2）移动两个数据的位置。</p>
<h3 id="1-5、排序算法"><a href="#1-5、排序算法" class="headerlink" title="1.5、排序算法"></a>1.5、排序算法</h3><p>排序算法按照其实现的思想和方法的不同，可以分为许多种。</p>
<p>我们比较常用的排序算法有：冒泡排序、 插入排序、选择排序、希尔排序（缩小增量排序）、快速排序、堆排序、归并排序。</p>
<p>排序算法的分类：</p>
<p>交换类排序：冒泡排序、快速排序<br>插入类排序： 直接插入排序、希尔排序（缩小增量排序）<br>选择类排序：简单选择排序、堆排序<br>归并排序<br>基数排序</p>
<h2 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h2><p>冒泡排序的规则：n个数据进行冒泡排序，首先将第一个数据和第二个数据进行比较，如果为逆序就交换两个数据的值，然后比较第二个和第三个数据，依此类推，直到第最后一个和倒数第二个比较完了为止。上述过程为冒泡排序的第一趟冒泡排序，其结果是最大或者最小的数据被放置在末尾的位置。然后进行第二趟排序，把第二大或者第二小的数放置在倒数第二的位置，之后每一趟排序都会使一个数据有序，直到此序列的全部数据都有序为止。</p>
<p>冒泡排序的演示示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> x[],<span class="type">int</span> n)</span><span class="comment">//冒泡排序 </span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> i, j; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;n<span class="number">-1</span>-i; j++) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (x[j] &gt; x[j + <span class="number">1</span>]) </span><br><span class="line">			&#123; </span><br><span class="line">				x[j] += x[j + <span class="number">1</span>]; </span><br><span class="line">				x[j + <span class="number">1</span>] = x[j] - x[j + <span class="number">1</span>]; </span><br><span class="line">				x[j] = x[j] - x[j + <span class="number">1</span>]; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,x[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3、简单选择排序"><a href="#3、简单选择排序" class="headerlink" title="3、简单选择排序"></a>3、简单选择排序</h2><p>对一个序列进行选择排序，首先通过一轮循环比较，从n个数据中找出最大或者最小的那个数据的位置，然后按照递增或者递减的顺序，将此数据与第一个或最后一个数据进行交换。然后再找第二大或者第二小的数据进行交换，以此类推，直到序列全部有序为止。</p>
<p>选择排序与冒泡排序的区别在于，冒泡排序每比较一次后，满足条件的数据就交换，而选择排序是每次比较后，记录满足条件数据的位置，一轮循环过后再作交换。</p>
<p>选择排序的演示示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> n)</span><span class="comment">//选择排序 </span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> i, j, min,k; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">	&#123; </span><br><span class="line">		min=i;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt; n; j++) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (x[min] &gt; x[j]) </span><br><span class="line">			min = j; </span><br><span class="line">		&#125;</span><br><span class="line">		k = x[i]; </span><br><span class="line">		x[i] = x[min]; </span><br><span class="line">		x[min] = k; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,x[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="4、直接插入排序"><a href="#4、直接插入排序" class="headerlink" title="4、直接插入排序"></a>4、直接插入排序</h2><p>插入排序的规则是：第一轮开始时默认序列中第一个数据是有序的，之后各个数据以此为基准，判断是插入在此数据的前面还是后面，之后的数据依次向后移动，腾出位置，让数据插入，以此类推，直到整个序列有序为止。每比较一次，如果满足条件（升序：前面一个数比后面需要插入的数大），就直接交换。</p>
<p>特点：对基本有序的序列插入排序速度相对而言比较快，插入排序的优势越明显，数据量越多，劣势也越明显</p>
<p>插入排序的演示示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> n)</span><span class="comment">//插入排序 </span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> i, j, k; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">for</span> (j = i; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">		<span class="keyword">if</span> (x[j - <span class="number">1</span>]&gt;x[j]) </span><br><span class="line">		&#123; </span><br><span class="line">			k = x[j - <span class="number">1</span>]; </span><br><span class="line">			x[j - <span class="number">1</span>] = x[j]; </span><br><span class="line">			x[j] = k; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n;i++) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,x[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>优化后的插入排序：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span><span class="comment">//优化后的插入排序 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tempVal; </span><br><span class="line">	<span class="type">int</span> j; </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)<span class="comment">//确定循环次数，改变i是为了把i直接当成下标 </span></span><br><span class="line">	&#123; </span><br><span class="line">		tempVal = arr[i];<span class="comment">//把待插入的数据另行保存一份 </span></span><br><span class="line">		j = i - <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tempVal &lt; arr[j]) </span><br><span class="line">		&#123; </span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j]; </span><br><span class="line">			--j; </span><br><span class="line">		&#125;</span><br><span class="line">		arr[j + <span class="number">1</span>] = tempVal;<span class="comment">//注意 ： j+1 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="十二、顺序表"><a href="#十二、顺序表" class="headerlink" title="十二、顺序表"></a>十二、顺序表</h1><h2 id="1、顺序表的基本概念"><a href="#1、顺序表的基本概念" class="headerlink" title="1、顺序表的基本概念"></a>1、顺序表的基本概念</h2><p>顺序表是将表中的数据依次存放在计算机内存中一组地址连续的存储单元中的一种数据结构，可以将顺序表看成一个可以动态改变大小的数组。</p>
<p>​	数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系</p>
<p>是线性表的一种，也就是采用顺序存储结构的线性表简称为”顺序表”。</p>
<p>顺序表的存储特点是：只要确定了起始位置 ,数据可以通过指定位置得到：首地址+(位置*偏移大小)</p>
<h2 id="2、顺序表的定义"><a href="#2、顺序表的定义" class="headerlink" title="2、顺序表的定义"></a>2、顺序表的定义</h2><p>顺序表结构的定义如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type <span class="comment">//类型别名的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">	Type *data; <span class="comment">//数据域（存储数据的空间）</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//顺序表的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="3、顺序表的功能实现"><a href="#3、顺序表的功能实现" class="headerlink" title="3、顺序表的功能实现"></a>3、顺序表的功能实现</h2><p>数据的4种基本操作：增、删、改、查，顺序表的基本操作：增、删、改、查。</p>
<p>使用函数实现以下顺序表的基本操作：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*顺序表功能函数的实现*/</span></span><br><span class="line"><span class="comment">//①构造一个空的顺序线性表</span></span><br><span class="line"><span class="built_in">array</span> * <span class="title function_">arr_init</span><span class="params">()</span> <span class="comment">//顺序表的初始化函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">array</span> * temp = (<span class="built_in">array</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">array</span>)); <span class="comment">//顺序表结构体的初始化</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表初始化失败：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	temp-&gt;data = (Type *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(Type)); <span class="comment">//顺序表数据域的初始化</span></span><br><span class="line">	temp-&gt;lenth = <span class="number">0</span>; <span class="comment">//顺序表长度的初始化</span></span><br><span class="line">	<span class="keyword">return</span> temp; <span class="comment">//将顺序表返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//②销毁顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_free</span><span class="params">(<span class="built_in">array</span> * arr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr-&gt;data != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">free</span>(arr-&gt;data); <span class="comment">//释放顺序表的数据域</span></span><br><span class="line">		<span class="built_in">free</span>(arr); <span class="comment">//释放整个顺序表</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//③重置为空表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_clear</span><span class="params">(<span class="built_in">array</span> * arr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (int i = 0; i &lt; arr-&gt;lenth; i++)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		arr-&gt;data[i] = 0; //顺序表元素置0</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	arr-&gt;data = (Type *)realloc(arr-&gt;data, sizeof(Type)); //顺序表数据域清空</span></span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(arr-&gt;data);</span><br><span class="line">	arr-&gt;data = (Type *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Type));</span><br><span class="line">	arr-&gt;lenth = <span class="number">0</span>; <span class="comment">//顺序表长度置0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//④判断是否为空表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">arr_empty</span><span class="params">(<span class="built_in">array</span> * arr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;lenth == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⑤插入顺序表元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_push</span><span class="params">(<span class="built_in">array</span> * arr, Type elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Error(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Error(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arr-&gt;lenth++; <span class="comment">//顺序表长度+1</span></span><br><span class="line">	arr-&gt;data = (Type *)<span class="built_in">realloc</span>(arr-&gt;data, <span class="keyword">sizeof</span>(Type)*arr-&gt;lenth); <span class="comment">//顺序表数据域内存扩大</span></span><br><span class="line">	arr-&gt;data[arr-&gt;lenth<span class="number">-1</span>] = elem; <span class="comment">//元素放入顺序表最后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⑥在顺序表指定位置插入新的数据元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_insert</span><span class="params">(<span class="built_in">array</span> * arr, <span class="type">int</span> index, Type elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr_empty(arr))</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="comment">//	if (index &gt; arr-&gt;lenth) //如果插入的位置大于顺序表最大长度，则插入错误</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		printf(&quot;插入数据的位置错误：&quot;);</span></span><br><span class="line"><span class="comment">// 		return;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="type">int</span> i = arr-&gt;lenth++;</span><br><span class="line">	arr-&gt;data = (Type *)<span class="built_in">realloc</span>(arr-&gt;data, <span class="keyword">sizeof</span>(Type)*arr-&gt;lenth); <span class="comment">//顺序表数 据域内存扩大</span></span><br><span class="line">	<span class="keyword">for</span> (; i &gt; index - <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		arr-&gt;data[i] = arr-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	arr-&gt;data[i] = elem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⑦删除顺序表指定位置的数据元素, 并返回元素的值</span></span><br><span class="line">Type <span class="title function_">arr_remove</span><span class="params">(<span class="built_in">array</span> * arr, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr_empty(arr))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	&#125;</span><br><span class="line">	Type val = arr-&gt;data[index - <span class="number">1</span>]; <span class="comment">//记录被删除元素</span></span><br><span class="line">	<span class="type">int</span> i = index - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; arr-&gt;lenth; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr-&gt;data[i] = arr-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	arr-&gt;lenth--; <span class="comment">//顺序表长度减1</span></span><br><span class="line">	arr-&gt;data = (Type *)<span class="built_in">realloc</span>(arr-&gt;data, <span class="keyword">sizeof</span>(Type)*arr-&gt;lenth); <span class="comment">//顺序表数据域内存减少</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⑧输出顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_out</span><span class="params">(<span class="built_in">array</span> * arr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arr_empty(arr); <span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr-&gt;lenth; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(P, arr-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="十三、链表"><a href="#十三、链表" class="headerlink" title="十三、链表"></a>十三、链表</h1><h2 id="1、链表的基本概念"><a href="#1、链表的基本概念" class="headerlink" title="1、链表的基本概念"></a>1、链表的基本概念</h2><h3 id="1-1、什么是链表"><a href="#1-1、什么是链表" class="headerlink" title="1.1、什么是链表"></a>1.1、什么是链表</h3><p>链表是数据结构中线性表的一种，其中的每个元素实际上是一个单独的结构体对象，而所有对象都通过</p>
<p>每个元素中的指针链接在一起。它是以结构体为节点，将一个结构体看成数据域和指针域两个部分，数</p>
<p>据域用于存储数据，指针域用于连接下一个节点，链表中每个结构体对象叫做节点，其中第一个数据节</p>
<p>点叫做链表的首元节点；如果第一个节点不用于存储数据，只用于代表链表的起始点，则这个节点称为</p>
<p>链表的头节点。</p>
<h3 id="1-2、链表的特点"><a href="#1-2、链表的特点" class="headerlink" title="1.2、链表的特点"></a>1.2、链表的特点</h3><p>链表有以下特点：</p>
<p>①链表没有固定的长度，可以自由增加节点<br>②链表能够实现快速的插入删除数据，也就是可以快速的插入和删除链表中的节点<br>③与数组类似，链表也是一种线性数据结构<br>④链表的尾结点的后继必定指向空</p>
<h3 id="1-3、链表和数组的区别："><a href="#1-3、链表和数组的区别：" class="headerlink" title="1.3、链表和数组的区别："></a>1.3、链表和数组的区别：</h3><p>数组和顺序表是顺序存储的，也就是内存是连续的；而链表是通过指针将不连续的内存连接起来，实现链式存储的。</p>
<h2 id="2、链表的结构"><a href="#2、链表的结构" class="headerlink" title="2、链表的结构"></a>2、链表的结构</h2><h2 id="3、单链表"><a href="#3、单链表" class="headerlink" title="3、单链表"></a>3、单链表</h2><h3 id="3-1、单链表结构的声明"><a href="#3-1、单链表结构的声明" class="headerlink" title="3.1、单链表结构的声明"></a>3.1、单链表结构的声明</h3><p>单链表结构体的定义如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type; <span class="comment">//数据类型 通过取别名的形式进行灵活使用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="comment">//单链表节点结构体的声明</span></span><br><span class="line">	Type data; <span class="comment">//链表节点的数据域，用于存储数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">//链表节点的指针域，用于指向和连接下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>&#123;</span> <span class="comment">//单链表结构体的声明</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span>;</span> <span class="comment">//链表头节点的指针域，用于指向链表的开头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">//链表尾节点的指针域，用于指向链表的末尾</span></span><br><span class="line">	<span class="type">int</span> lenth; <span class="comment">//链表的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、单链表的创建与功能实现"><a href="#3-2、单链表的创建与功能实现" class="headerlink" title="3.2、单链表的创建与功能实现"></a>3.2、单链表的创建与功能实现</h3><p>（1）单链表的创建</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建单链表 </span></span><br><span class="line">LL *<span class="title function_">list_init</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">	LL *temp = (LL *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LL)); </span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	temp-&gt;head = <span class="literal">NULL</span>; <span class="comment">//链表头节点指针置空(初始化) </span></span><br><span class="line">	temp-&gt;end = <span class="literal">NULL</span>; <span class="comment">//链表尾结点指针置空(初始化) </span></span><br><span class="line">	temp-&gt;lenth = <span class="number">0</span>; <span class="comment">//链表长度置0(初始化) </span></span><br><span class="line">	<span class="keyword">return</span> temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（2）单链表节点的链接</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2、链接单链表节点</span></span><br><span class="line">Node *<span class="title function_">node_init</span><span class="params">(Type val)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node *temp = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	temp-&gt;data = val; <span class="comment">//链表节点的数据域赋值</span></span><br><span class="line">	temp-&gt;next = <span class="literal">NULL</span>; <span class="comment">//(*temp).next = NULL</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（3）单链表的输出</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3、单链表的输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_print</span><span class="params">(LL *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表为空！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Node *temp = <span class="built_in">list</span>-&gt;head; temp != <span class="literal">NULL</span>; temp = temp-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(T, temp-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（4）单链表节点的插入</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4、单链表节点的插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_end</span><span class="params">(LL *<span class="built_in">list</span>, Type val)</span> <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Node *temp = node_init(val);</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>) <span class="comment">//如果是空链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;end = node_init(val); <span class="comment">//第一个链表节点，其既是头部也是尾部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth++; <span class="comment">//链表长度+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Node *temp = node_init(val);</span></span><br><span class="line">		<span class="comment">//list-&gt;end-&gt;next = temp</span></span><br><span class="line">		<span class="comment">//list-&gt;end = temp;</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;end-&gt;next = node_init(val); <span class="comment">//创建一个新节点，连接到链表当前的末尾</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;end = <span class="built_in">list</span>-&gt;end-&gt;next; <span class="comment">//新节点成为新的尾部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth++; <span class="comment">//链表长度+1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（5）单链表节点的删除</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5、单链表节点的删除</span></span><br><span class="line">Type <span class="title function_">list_delete</span><span class="params">(LL *<span class="built_in">list</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; <span class="built_in">list</span>-&gt;lenth || index &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除位置错误！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Node *temp = <span class="built_in">list</span>-&gt;head; <span class="comment">//记录当前头部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;head-&gt;next; <span class="comment">//第二个节点成为新的头部</span></span><br><span class="line">		Type val = temp-&gt;data; <span class="built_in">free</span>(temp);</span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth--;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="built_in">list</span>-&gt;lenth)</span><br><span class="line">	&#123;</span><br><span class="line">		Node *temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; index - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = temp-&gt;next; <span class="comment">//找到删除位置前一个节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		Type val = temp-&gt;next-&gt;data; <span class="built_in">free</span>(temp-&gt;next);</span><br><span class="line">		temp-&gt;next = <span class="literal">NULL</span>; <span class="comment">//链表末尾指向空</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;end = temp; <span class="comment">//倒数第二个节点成为新的尾部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth--;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">	Node *temp1 = <span class="built_in">list</span>-&gt;head; Node *temp2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; index - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp1 = temp1-&gt;next;</span><br><span class="line">		<span class="comment">//找到删除位置前一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	Type val = temp1-&gt;next-&gt;data; <span class="comment">//记录被删除节点的数据</span></span><br><span class="line">	temp2 = temp1-&gt;next; <span class="comment">//temp2指向被删除节点</span></span><br><span class="line">	temp1-&gt;next = temp2-&gt;next; <span class="comment">//删除位置前的节点跳过被删除的节点，指向下下一个节点</span></span><br><span class="line">	<span class="built_in">free</span>(temp2); <span class="comment">//释放被删除节点</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;lenth--; </span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（6）向单链表指定位置插入数据</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6、指定位置插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert</span><span class="params">(LL *<span class="built_in">list</span>, <span class="type">int</span> index, Type val)</span> <span class="comment">//index指定位置</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; <span class="built_in">list</span>-&gt;lenth+<span class="number">1</span> || index&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入位置错误！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="built_in">list</span>-&gt;lenth + <span class="number">1</span>) <span class="comment">//如果插入位置刚好比链表长度大一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		list_insert_end(<span class="built_in">list</span>, val); <span class="comment">//从尾部插入</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">1</span>) <span class="comment">//如果在当前头节点之前插入</span></span><br><span class="line">	&#123;</span><br><span class="line">		Node * New = node_init(val); <span class="comment">//创建新插入的节点</span></span><br><span class="line">		New-&gt;next = <span class="built_in">list</span>-&gt;head; <span class="comment">//新节点指向当前头节点</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;head = New; <span class="comment">//新节点成为新的头部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node *temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; index<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = temp-&gt;next; <span class="comment">//找到插入位置前一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	Node * New = node_init(val); <span class="comment">//创建新插入的节点</span></span><br><span class="line">	New-&gt;next = temp-&gt;next; <span class="comment">//新节点连接插入位置之后的节点</span></span><br><span class="line">	temp-&gt;next = New; <span class="comment">//链表插入位置之前的节点连接上新节点</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;lenth++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（7）获取单链表指定位置上的数据</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7、获取单链表指定位置上的数据</span></span><br><span class="line">Type <span class="title function_">list_get</span><span class="params">(LL *<span class="built_in">list</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; <span class="built_in">list</span>-&gt;lenth || index &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置错误！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node *temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; index; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（8）单链表的销毁</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8、链表的销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_delete_all</span><span class="params">(LL **<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (*<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	if (list-&gt;head == NULL)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		free(list);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	Node *temp1 = (*<span class="built_in">list</span>)-&gt;head,*temp2;</span><br><span class="line">	<span class="keyword">for</span> (; temp1 != <span class="literal">NULL</span>;) <span class="comment">//循环释放链表中的各个数据节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp2 = temp1;</span><br><span class="line">		temp1 = temp1-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(*<span class="built_in">list</span>); <span class="comment">//释放整个链表</span></span><br><span class="line">	*<span class="built_in">list</span> = <span class="literal">NULL</span>;	<span class="comment">//链表指针指向空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="十四、栈和队列"><a href="#十四、栈和队列" class="headerlink" title="十四、栈和队列"></a>十四、栈和队列</h1><h2 id="1、栈和队列的基本概念"><a href="#1、栈和队列的基本概念" class="headerlink" title="1、栈和队列的基本概念"></a>1、栈和队列的基本概念</h2><p>在数组中，我们可以通过索引（下标）访问随机元素。 但是，在某些情况下，我们可能需要限制处理</p>
<p>顺序，这就产生了栈和队列这两种功能受限的线性结构。</p>
<p>栈和队列是两种不同的处理顺序：先进后出和先进先出，以及两个相应的线性数据结构。</p>
<h2 id="2、数据结构中的栈和队列"><a href="#2、数据结构中的栈和队列" class="headerlink" title="2、数据结构中的栈和队列"></a>2、数据结构中的栈和队列</h2><h3 id="2-1、栈-stack"><a href="#2-1、栈-stack" class="headerlink" title="2.1、栈 (stack)"></a>2.1、栈 (stack)</h3><p>数据后进先出,先进后出：LIFO (last in first out)</p>
<p>栈只有一个开口,先进去的就到下面,后进来的就在上面(top),要是拿出去的话,肯定是从开口端拿出去,所以说先进后出，后进先出。</p>
<p>入栈：push</p>
<p>出栈：pop</p>
<p>获取栈顶元素：top</p>
<p>判断栈是否已经为空：is_empty</p>
<p>判断栈是否已经满了：is_full (如果是数组实现的) </p>
<h3 id="2-2、队列-queue"><a href="#2-2、队列-queue" class="headerlink" title="2.2、队列(queue)"></a>2.2、队列(queue)</h3><p>数据入队规则：先进先出，后进后出，FIFO(first in first out)</p>
<p>队列有队首（front）和队尾（back），数据从队尾入队，从队首出队。</p>
<p>队首（front）指向队列的第一个数据，队尾（back）指向队列中的最后一个数据。</p>
<p>入队：push</p>
<p>出队：pop</p>
<p>队首：front</p>
<p>队尾：back</p>
<h2 id="3、栈和队列的基本结构"><a href="#3、栈和队列的基本结构" class="headerlink" title="3、栈和队列的基本结构"></a>3、栈和队列的基本结构</h2><h3 id="3-1、栈和队列的结构示意图"><a href="#3-1、栈和队列的结构示意图" class="headerlink" title="3.1、栈和队列的结构示意图"></a>3.1、栈和队列的结构示意图</h3><h3 id="3-2、栈和队列中数据的插入和删除"><a href="#3-2、栈和队列中数据的插入和删除" class="headerlink" title="3.2、栈和队列中数据的插入和删除"></a>3.2、栈和队列中数据的插入和删除</h3><p>（1）栈中数据的插入和删除</p>
<p>（2）队列中数据的插入和删除</p>
<h2 id="4、栈和队列的实现"><a href="#4、栈和队列的实现" class="headerlink" title="4、栈和队列的实现"></a>4、栈和队列的实现</h2><h3 id="4-1、栈功能的实现"><a href="#4-1、栈功能的实现" class="headerlink" title="4.1、栈功能的实现"></a>4.1、栈功能的实现</h3><p>可以使用链表或顺序表的结构实现栈。</p>
<p>如：栈的数组实现</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 10 <span class="comment">//栈的最大大小</span></span></span><br><span class="line"><span class="comment">//栈的数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> //栈的结构体声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Type data[STACK_SIZE]; <span class="comment">//数据域</span></span><br><span class="line">	<span class="type">int</span> top; <span class="comment">//栈顶元素下标</span></span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"><span class="comment">/*栈的功能实现*/</span></span><br><span class="line"><span class="comment">//栈的初始化函数</span></span><br><span class="line"><span class="built_in">stack</span> *<span class="title function_">stack_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stack</span> *temp = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">	assert(temp);</span><br><span class="line">	temp-&gt;top = <span class="number">-1</span>; <span class="comment">//初始化栈顶元素下标为-1，-1表示栈中没有元素</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据入栈函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stack_push</span><span class="params">(<span class="built_in">stack</span> *st, Type val)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(st); <span class="comment">//判断栈是否存在</span></span><br><span class="line">	assert(!stack_full(st)); <span class="comment">//判断栈是否满了</span></span><br><span class="line">	st-&gt;data[++st-&gt;top] = val; <span class="comment">//从栈顶插入元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据出栈函数</span></span><br><span class="line">Type <span class="title function_">stack_pop</span><span class="params">(<span class="built_in">stack</span> *st)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(st); <span class="comment">//判断栈是否存在</span></span><br><span class="line">	assert(!stack_empty(st)); <span class="comment">//判断栈是否空了</span></span><br><span class="line">	Type val = st-&gt;data[st-&gt;top]; <span class="comment">//记录当前栈顶元素</span></span><br><span class="line">	st-&gt;top--; <span class="comment">//栈顶元素下标-1</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取栈顶元素</span></span><br><span class="line">Type <span class="title function_">stack_top</span><span class="params">(<span class="built_in">stack</span> *st)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(st); <span class="comment">//判断栈是否存在</span></span><br><span class="line">	assert(!stack_empty(st)); <span class="comment">//判断栈是否空了</span></span><br><span class="line">	<span class="keyword">return</span> st-&gt;data[st-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">stack_empty</span><span class="params">(<span class="built_in">stack</span> *st)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> st-&gt;top == <span class="number">-1</span>; <span class="comment">//栈空了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈是否满了</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">stack_full</span><span class="params">(<span class="built_in">stack</span> *st)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> st-&gt;top &gt;= STACK_SIZE; <span class="comment">//栈满了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-2、队列功能的实现"><a href="#4-2、队列功能的实现" class="headerlink" title="4.2、队列功能的实现"></a>4.2、队列功能的实现</h3><p>可以使用链表或顺序表的结构实现队列。</p>
<p>如：队列的链表实现</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type;</span><br><span class="line"><span class="comment">/*队列的链表实现*/</span></span><br><span class="line"><span class="comment">//链表节点结构的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Type data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">//队列链表结构的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Node *front; <span class="comment">//队首指针</span></span><br><span class="line">	Node *back; <span class="comment">//队尾指针</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="comment">/*队列功能的实现*/</span></span><br><span class="line"><span class="comment">//队列单链表的初始化</span></span><br><span class="line">Queue *<span class="title function_">queue_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Queue *temp = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">	assert(temp); <span class="comment">//如果队列初始化失败则报错</span></span><br><span class="line">	temp-&gt;front = temp-&gt;back = <span class="literal">NULL</span>; <span class="comment">//队首和队尾指针初始化为NULL</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列单链表节点的创建函数</span></span><br><span class="line">Node *<span class="title function_">node_create</span><span class="params">(Type val)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node *temp = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	assert(temp);</span><br><span class="line">	temp-&gt;data = val; <span class="comment">//节点数据域的初始化</span></span><br><span class="line">	temp-&gt;next = <span class="literal">NULL</span>; <span class="comment">//节点指针域的初始化</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据入队函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_push</span><span class="params">(Queue *q, Type val)</span> <span class="comment">//链表的尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q);</span><br><span class="line"><span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	q-&gt;front = node_create(val); <span class="comment">//创建队列的第一个节点</span></span><br><span class="line">	q-&gt;back = q-&gt;front; <span class="comment">//队列只有一个节点，其既是头部也是尾部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	q-&gt;back-&gt;next = node_create(val); <span class="comment">//新创建的节点连接到队列尾部</span></span><br><span class="line">	q-&gt;back = q-&gt;back-&gt;next; <span class="comment">//新节点是新的尾部</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据出队函数</span></span><br><span class="line">Type <span class="title function_">queue_pop</span><span class="params">(Queue *q)</span> <span class="comment">//链表的头删法</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q); <span class="comment">//整个链表不存在</span></span><br><span class="line">	assert(q-&gt;front); <span class="comment">//链表为空</span></span><br><span class="line">	Node *temp = q-&gt;front;</span><br><span class="line">	Type val = temp-&gt;data;</span><br><span class="line">	q-&gt;front = q-&gt;front-&gt;next; <span class="comment">//当前队首的下一个节点成为成为新的队首</span></span><br><span class="line">	<span class="built_in">free</span>(temp); <span class="comment">//之前的队首节点释放</span></span><br><span class="line">	temp = <span class="literal">NULL</span>; <span class="comment">//避免temp成为野指针</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取队首元素</span></span><br><span class="line">Type <span class="title function_">queue_front</span><span class="params">(Queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q); <span class="comment">//整个链表不存在</span></span><br><span class="line">	<span class="comment">//assert(q-&gt;front); //链表为空</span></span><br><span class="line">	assert(!queue_empty(q)); <span class="comment">//链表为空</span></span><br><span class="line">	<span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取队尾元素</span></span><br><span class="line">Type <span class="title function_">queue_back</span><span class="params">(Queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q); <span class="comment">//整个链表不存在</span></span><br><span class="line">	<span class="comment">//assert(q-&gt;front); //链表为空</span></span><br><span class="line">	assert(!queue_empty(q)); <span class="comment">//链表为空</span></span><br><span class="line">	<span class="keyword">return</span> q-&gt;back-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">queue_empty</span><span class="params">(Queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q); <span class="comment">//整个链表不存在</span></span><br><span class="line">	<span class="comment">//if (q-&gt;front == NULL) //如果队列为空</span></span><br><span class="line">    <span class="comment">//	return true; //返回真1</span></span><br><span class="line">	<span class="comment">//else</span></span><br><span class="line">	<span class="comment">//	return false; //否则返回假0</span></span><br><span class="line">	<span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>; <span class="comment">//判断队列是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT跨域验证</title>
    <url>/2023/08/17/JWT%E8%B7%A8%E5%9F%9F%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JWT（JSON Web Token）是一种轻量级的、可扩展的、基于JSON的身份验证和授权机制，用于在不同的应用程序之间安全地传输信息。JWT是由三部分组成：头部、载荷和签名。头部通常包含有关JWT的元数据，如过期时间、签名算法等；载荷包含要传输的信息，例如用户ID、角色等；签名则用于验证JWT是否被篡改过。</p>
<h2 id="Session认证"><a href="#Session认证" class="headerlink" title="Session认证"></a>Session认证</h2><p>互联网服务离不开用户认证，一般流程是这样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230817094609.png"
                      alt="image-20230816225712326"
                ></p>
<ul>
<li><p>用户向服务器发送用户名和密码。</p>
</li>
<li><p>服务器验证通过后，在当前对话(session)里面保存相关数据，比如用户角色登录时间等。</p>
</li>
<li><p>服务器向用户返回一个 session id，写入用户的 Cookie。用户随后的每一次请求，都会通过 Cookie，将 session id 传回服务器服务器收到 session id，找到前期保存的数据，由此得知用户的身份。</p>
</li>
</ul>
<p>session 认证的方式应用非常普遍，但也存在一些问题，扩展性不好，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session，针对此种问题一般有两种方案:<br>一种解决方案是session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。<br>一种方案是服务器不再保存 session 数据，所有数据都保存在客户端，每次请求都发回服务器。Token认证就是这种方案的一个代表</p>
<h2 id="Token认证"><a href="#Token认证" class="headerlink" title="Token认证"></a>Token认证</h2><p>Token是在服务端产生的一串字符串,是客户端访问资源接口(API)时所需要的资源凭证，流程如下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230817094610.png"
                      alt="image-20230816225840248"
                ></p>
<ul>
<li><p>客户端使用用户名跟密码请求登录，服务端收到请求，去验证用户名与密码</p>
</li>
<li><p>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</p>
</li>
<li><p>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者localStorage 里</p>
</li>
<li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</p>
</li>
<li><p>服务端收到请求，然后去验证客户端请求里面带着的 token，如果验证成功就向客户端返回请求的数据</p>
</li>
</ul>
<h3 id="Token认证的特点"><a href="#Token认证的特点" class="headerlink" title="Token认证的特点"></a>Token认证的特点</h3><p>基于token的用户认证是一种服务端无状态的认证方式，服务端不用存放token 数据。<br>用解析 token的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库<br>token 完全由应用管理，所以它可以避开同源策略</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JSON Web Token（简称JWT）是一个token的具体实现方式，是目前最流行的跨域认证解决方案。</p>
<p>JWT的原理是，服务器认证以后，生成一个JSON对象，发回给用户。</p>
<p>用户于服务端通信的时候，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份。</p>
<p>为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</p>
<p>JWT的由三个部分组成，依次如下：<br><strong>Header（头部）、Payload（负载）、Signature（签名）</strong></p>
<p>三部分最终组合为完整的字符串，中间使用 . 分隔，如下：<br><strong>Header.Payload.Signature</strong></p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header部分是一个JSON对象，描述JWT的元数据</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>alg属性表示签名的算法 (algorithm)，默认是HMAC SHA256 (写成HS256)<br>typ属性表示这个令牌 (token)的类型 (ype)，JWT 令牌统一写为JWT</p>
<p>最后，将上面的JSON 对象使用 Base64URL算法转成字符串</p>
<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>​	Payload 部分也是一个JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<ul>
<li><p>iss(issuer): 签发人</p>
</li>
<li><p>exp (expiration time): 过期时间</p>
</li>
<li><p>sub (subject):主题</p>
</li>
<li><p>aud(audience):受众</p>
</li>
<li><p>nbf(Not Before): 生效时间</p>
</li>
<li><p>iat(Issued At): 签发时间</p>
</li>
<li><p>jti (WT ID): 编号</p>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在个部分。</p>
<p>这个JSON 对象也要使用 Base64URL算法转成字符串</p>
</li>
</ul>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>Signature部分是对前两部分的签名，防止数据篡改</p>
<p>首先，需要指定一个密钥 (secret) 。这个密钥只有服务器才知道，不能泄露给用户<br>然后，使用 Header 里面指定的签名算法(默认是HMAC SHA256)，按照下面的公式产生签名</p>
<h2 id="JWT的特点"><a href="#JWT的特点" class="headerlink" title="JWT的特点"></a>JWT的特点</h2><p>客户端收到服务器返回的JWT，可以储存在 Cookie 里面，也可以储存在ocalStorage。<br>客户端每次与服务器通信，都要带上这个JWT，可以把它放在 Cookie 里面自动发送，但是这样不能跨域。<br>更好的做法是放在HTTP 请求的头信息Authorization字段里面，单独发送</p>
<h2 id="JWT的使用"><a href="#JWT的使用" class="headerlink" title="JWT的使用"></a>JWT的使用</h2><p>首先引入Maven依赖。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>创建工具类，用户创建JWT字符串和解析JWT</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.secretKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createJWT</span><span class="params">(String id, String subject, <span class="type">long</span> ttlMillis, Map&lt;String, Object&gt; map)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setId(id)</span><br><span class="line">                .setSubject(subject) <span class="comment">// 发行者</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// 发行时间</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, secretKey) <span class="comment">// 签名类型 与 密钥</span></span><br><span class="line">                .compressWith(CompressionCodecs.DEFLATE);<span class="comment">// 对载荷进行压缩</span></span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(map)) &#123;</span><br><span class="line">            builder.setClaims(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ttlMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            builder.setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + ttlMillis));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwtString)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwtString)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着在application.yml配置文件配置jwt.secretKey</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 用户生成jwt字符串的secretKey</span></span><br><span class="line"><span class="attr">jwt:</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="string">ak47</span></span><br></pre></td></tr></table></figure></div>

<p>接着创建一个实体类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BaseResponse <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BaseResponse</span>(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BaseResponse <span class="title function_">fail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BaseResponse</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器、getter、setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtResponse</span> <span class="keyword">extends</span> <span class="title class_">BaseResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String jwtData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JwtResponse <span class="title function_">success</span><span class="params">(String jwtData)</span> &#123;</span><br><span class="line">        <span class="type">BaseResponse</span> <span class="variable">success</span> <span class="operator">=</span> BaseResponse.success();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtResponse</span>(success.getCode(), success.getMsg(), jwtData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JwtResponse <span class="title function_">fail</span><span class="params">(String jwtData)</span> &#123;</span><br><span class="line">        <span class="type">BaseResponse</span> <span class="variable">fail</span> <span class="operator">=</span> BaseResponse.fail();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtResponse</span>(fail.getCode(), fail.getMsg(), jwtData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器、getter、setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着是Controller控制类：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> JwtResponse <span class="title function_">login</span><span class="params">(<span class="meta">@RequestParam(name = &quot;userName&quot;)</span> String userName,</span></span><br><span class="line"><span class="params">                             <span class="meta">@RequestParam(name = &quot;passWord&quot;)</span> String passWord)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jwt = userService.login(userName, passWord);</span><br><span class="line">            <span class="keyword">return</span> JwtResponse.success(jwt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> JwtResponse.fail(jwt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>还有Service层</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String userName, String passWord)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//登录验证</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.findByUserNameAndPassword(userName, passWord);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果能查出，则表示账号密码正确，生成jwt返回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, user.getName());</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, user.getAge());</span><br><span class="line">        <span class="keyword">return</span> jwtUtil.createJWT(uuid, <span class="string">&quot;login subject&quot;</span>, <span class="number">0L</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>还有xml</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;io.github.yehongzhi.jwtdemo.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUserNameAndPassword&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;io.github.yehongzhi.jwtdemo.model.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where user_name = #&#123;userName&#125; and pass_word = #&#123;passWord&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>后续就可以做接口验证啦</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/jwt&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">test</span><span class="params">(<span class="meta">@RequestParam(&quot;jwt&quot;)</span> String jwt)</span> &#123;</span><br><span class="line">        <span class="comment">//这个步骤可以使用自定义注解+AOP编程做解析jwt的逻辑，这里为了简便就直接写在controller里</span></span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> jwtUtil.parseJWT(jwt);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> claims.get(<span class="string">&quot;name&quot;</span>, String.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> claims.get(<span class="string">&quot;age&quot;</span>, String.class);</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, age);</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;请求成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a class="link"   href="https://cloud.tencent.com/developer/support-plan?invite_code=1m621mn5zh4ac" >https://cloud.tencent.com/developer/support-plan?invite_code=1m621mn5zh4ac <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Java List 去除重复值</title>
    <url>/2022/09/26/Java-List-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%80%BC/</url>
    <content><![CDATA[<p>JAVA中List对象去除重复值，大致分为两种情况，一种是List<String>、List<Integer>这类，直接根据List中的值进行去重，另一种是List<User>这种，List中存的是javabean对象，需要根据List中对象的某个值或某几个值进行比较去重。方法如下：</p>
<h2 id="一、List、List对象去重复值。"><a href="#一、List、List对象去重复值。" class="headerlink" title="一、List、List对象去重复值。"></a>一、List<String>、List<Integer>对象去重复值。</h2><p>这种情况的话，处理起来比较简单，通过JDK1.8新特性stream的distinct方法，可以直接处理。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">list1.stream().distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">list2.stream().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure></div>


<h2 id="二、List对象去重复值。"><a href="#二、List对象去重复值。" class="headerlink" title="二、List对象去重复值。"></a>二、List<User>对象去重复值。</h2><p>这种的话，不能直接比较List中的对象，需要重写bean对象的equals和hashCode方法，然后通过放入Set集合来自动去重，具体例子如下。</p>
<p>对象实体：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User) obj;</span><br><span class="line">        <span class="keyword">return</span> name.equals(u.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">in</span> <span class="operator">=</span> name;</span><br><span class="line">        <span class="keyword">return</span> in.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上例子中就是通过比较姓名相同，即认为对象相等。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;peter&quot;</span>, <span class="number">18</span>));</span><br><span class="line">userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;stark&quot;</span>, <span class="number">25</span>));</span><br><span class="line">userList.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;peter&quot;</span>, <span class="number">22</span>));</span><br><span class="line"></span><br><span class="line">Set&lt;User&gt; userSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(userList);</span><br><span class="line">List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(userSet);</span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure></div>

<p>通过将List放入Set进行自动去重（即使用到上面的equals与hashCode方法），然后重新放回List中即可。</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript参数传递，参数默认值，参数的收集与展开</title>
    <url>/2022/12/05/JavaScript%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%8C%E5%8F%82%E6%95%B0%E7%9A%84%E6%94%B6%E9%9B%86%E4%B8%8E%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>一、参数传递</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 输出 [1, 2]</span></span><br></pre></td></tr></table></figure></div>

<p>这个例子中，a 和 b 属于函数中的局部变量，只能在函数中访问。调用函数时，传递的数据会根据位置来匹配对应，分别赋值给 a 和 b。</p>
<p>创建函数时，function 函数名 后面括号中设定的参数被称为形参；调用函数时，函数名后面括号中传入的参数被称为实参。上面例子中，a 和 b 是形参，传入的 1 和 2 是实参。</p>
<p>因为形参是已声明的变量，所以不能再用 let 和 const 重复声明。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// 报错，a 已声明</span></span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">1</span>; <span class="comment">// 报错，b 已声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>JavaScript 中所有函数传递都是按值传递的，不会按引用传递。所谓的值，就是指直接保存在变量上的值，如果把对象作为参数传递，那么这个值就是这个对象的引用，而不是对象本身。这里实际上是一个隐式的赋值过程，所以给函数传递参数时，相当于从一个变量赋值到另一个变量。</p>
<p>原始值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(count); <span class="comment">// 此处参数传递的过程可以看作是 num = count</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></div>

<p>引用值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">setName</span>(person); <span class="comment">// 此处参数传递的过程可以看作是 obj = person;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;name: &quot;小明&quot;&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>二、理解参数<br>JavaScript 中的函数既不会检测参数的类型，也不会检测传入参数的个数。定义函数时设置两个形参，不意味着调用时必须传入两个参数。实际调用时不管是传了一个还是三个，甚至不传参数也不会报错。</p>
<p>所有函数（非箭头）中都有一个名为 arguments 的特殊的类数组对象（不是 Array 的实例），它保存着所有实参的副本，我们可以通过它按照数组的索引访问方式获取所有实参的值，也可以访问它的 arguments.length 属性来确定函数实际调用时传入的参数个数。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 依次输出 10、20、2 </span></span><br></pre></td></tr></table></figure></div>


<p>上面例子中，foo() 函数的第一个参数是 a，第二个参数是b ，可以通过 arguments[x] 的方式来分别获取同样的值 。因此，你甚至可以在声明函数时不设置形参。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 依次输出 10、20 </span></span><br></pre></td></tr></table></figure></div>

<p>由此可见，JavaScript 函数的形参只是方便使用才写出来的。想传多少个参数都不会产生错误。</p>
<p>还有一个要注意的是，arguments 可以跟形参一起使用，并且 arguments 对象中的值会和对应的形参保持同步。例如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">	<span class="variable language_">arguments</span>[<span class="number">0</span>] ++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">10</span>); <span class="comment">// 输出 11</span></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params">a</span>) &#123;</span><br><span class="line">	a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo2</span>(<span class="number">10</span>); <span class="comment">// 输出 11</span></span><br></pre></td></tr></table></figure></div>

<p>当修改 arguments[0] 或 a 的值时，另一个也被改变了。这并不意味着它们访问同一个内存地址，毕竟我们传入的是一个原始值。它们在内存中还是分开的，只是由于内部的机制使它们的值保持了同步。</p>
<p>另外，如果缺少传参，那这个形参的值就不会和 arguments 对象中的对应值进行同步。例如下面这个例子，只传了一个参数，那么arguments 中只有一个实参值，这时候在函数中把 arguments[1] 设置为某个值，这个值并不会同步给第二个形参，例如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a,b</span>) &#123;</span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>); <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure></div>

<p>这个例子中，形参 b 没有传入实参，它的值会默认为 undefined。但如果：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="literal">undefined</span>); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure></div>

<p>手动传入 undefined 时， arguments 数组中会出现一个值为 undefined 的元素，依然能和 b 的值进行同步。</p>
<p>严格模式下，arguments 对象中的值和形参不会再同步，当然，如果传入的是引用值，它们依然会互相影响，但这只是引用值的特性而已。因此，在开发中最好不要依赖这种同步机制，也就是说不要同时使用形参和它在arguments 对象中的对应值。</p>
<p>箭头函数中没有 arguments<br>如果函数是使用箭头语法定义的，那么函数中是没有 arguments 对象的，只能通过定义的形参来访问。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 报错，arguments 未定义</span></span><br></pre></td></tr></table></figure></div>

<p>在某些情况可能会访问到 arguments ：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">fn2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></div>


<p>但这个 arguments，并不是箭头函数的，而是属于外部普通函数的，当箭头函数中访问 arguments 时，顺着作用域链找到了外部函数的arguments。</p>
<p>三、将对象属性用作实参<br>当一个函数包含的形参有多个时，调用函数就成了一种麻烦，因为你总是要保证传入的参数放在正确的位置上，有没有办法解决传参顺序的限制呢？</p>
<p>由于对象属性是无序的，通过属性名来确定对应的值。因此可以通过传入对象的方式，以对象中的属性作为真正的实参，这样参数的顺序就无关紧要了。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>, obj.<span class="property">sex</span>, obj.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(&#123; <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span> &#125;); <span class="comment">// 小明 男 18</span></span><br></pre></td></tr></table></figure></div>

<p>四、参数默认值<br>如果调用函数时缺少提供实参，那么形参默认值为 undefined。</p>
<p>有时候我们想要设置特定的默认值，在 ES6 之前还不支持显式地设置默认值的时候，只能采用变通的方式：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    name = name || <span class="string">&#x27;everyone&#x27;</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Hello &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// 输出 &#x27;Hello everyone!&#x27; </span></span><br></pre></td></tr></table></figure></div>

<p>通过检查参数值的方式判断有没有赋值，上面的做法虽然简便，但缺点在于如果传入的实参对应布尔值为 false ，实参就不起作用了。需要更精确的话可以用 if 语句或者三元表达式，判断参数是否等于 undefined，如果是则说明这个参数缺失 ：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if 语句判断</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">		name = <span class="string">&#x27;everyone&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Hello &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 三元表达式判断</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">	name =  (name !== <span class="literal">undefined</span>) ? name : <span class="string">&#x27;everyone&#x27;</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Hello &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>ES6 就方便了许多，因为它支持了显式的设置默认值的方式，就像这样：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name = <span class="string">&#x27;everyone&#x27;</span></span>) &#123; <span class="comment">// 定义函数时，直接给形参赋值</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Hello &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// 输出 &#x27;Hello everyone!&#x27; </span></span><br><span class="line"><span class="title function_">sayHi</span>(<span class="string">&#x27;Tony&#x27;</span>); <span class="comment">// 输出 &#x27;Hello Tony!&#x27; </span></span><br><span class="line"><span class="title function_">sayHi</span>(<span class="literal">undefined</span>); <span class="comment">// 输出 &#x27;Hello everyone!&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>这些结果表明了，它也是通过参数是否等于 undefined 来判定参数是否缺失的。</p>
<p>默认值不但可以是一个值，它还可以是任意合法的表达式，甚至是函数调用：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name = <span class="string">&#x27;every&#x27;</span>+<span class="string">&#x27;one&#x27;</span></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Hello &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// 输出 &#x27;Hello everyone!&#x27; </span></span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用foo&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Tony&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name = foo()</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Hello &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">		  </span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// 输出 &#x27;调用foo&#x27;</span></span><br><span class="line">         <span class="comment">// 输出 &#x27;Hello Tony!&#x27; </span></span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>(<span class="literal">undefined</span>); <span class="comment">// 输出 &#x27;调用foo&#x27;</span></span><br><span class="line">                  <span class="comment">// 输出 &#x27;Hello Tony!&#x27; </span></span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>(<span class="string">&#x27;John&#x27;</span>); <span class="comment">// 输出 &#x27;Hello John!&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>可以看到，函数参数的默认值只有在函数调用时，参数的值缺失或者是 undefined 才会求值，不会在函数定义时求值。</p>
<p>参数默认值的位置<br>通常我们给参数设置默认值，是为了调用函数时可以适当省略参数的传入，这里要注意的是，有多个参数时，设置了默认值的参数如果不是放在尾部，实际上它是无法省略的。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x = <span class="number">1</span>, y</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>([x, y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 输出 [1, undefined]</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">2</span>); <span class="comment">// 输出 [2, undefined]</span></span><br><span class="line"><span class="title function_">fn</span>(, <span class="number">2</span>); <span class="comment">// 报错，语法错误（这里不支持像数组那样的空槽）</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="literal">undefined</span>, <span class="number">2</span>); <span class="comment">// 输出 [1, 2] （那还不如传个 1 方便呢!）</span></span><br></pre></td></tr></table></figure></div>

<p>上面例子中，给形参 x 设置的默认值就显得没有任何意义了。因此，设置默认值的参数放在尾部是最好的做法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y = <span class="number">2</span></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>([x, y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 输出 [undefined, 2]</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>); <span class="comment">// 输出 [1, 2]</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 输出 [1, 1]</span></span><br></pre></td></tr></table></figure></div>

<p>参数的省略问题<br>在多个参数设置了默认值的情况下，那么问题又来了，你并不能省略比较靠前的参数，而只给最后的一个参数传入实参。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y = <span class="number">2</span>, z = <span class="number">3</span></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>([x, y, z]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>, , <span class="number">10</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></div>

<p>前面我们知道，可以通过传入对象的这种方式去避免参数顺序的限制。那参数默认值如何实现呢？用 || 、 if 语句或者三元表达式去判断也是解决办法，但这样就显得有些落后了。接下来要讨论的是另外两种 ES6 中的全新方式。</p>
<p>参数默认值和 Object.assign() 结合使用</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">obj = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> defaultObj = &#123;</span><br><span class="line">        <span class="attr">x</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">z</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(defaultObj, obj);</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([result.<span class="property">x</span>, result.<span class="property">y</span>, result.<span class="property">z</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 输出 [undefined, 2, 3]</span></span><br><span class="line"><span class="title function_">fn</span>(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">10</span> &#125;); <span class="comment">// 输出 [1, 2, 10]</span></span><br></pre></td></tr></table></figure></div>

<p>上面的例子中，在函数中定义了一个对象 defaultObj ，变通地利用其中的属性作为参数的默认值，然后利用 Object.assagin() 把传入的对象和默认对象进行合并，defaultObj 中的属性会被 obj 的相同属性覆盖，obj 中如果有其他属性会分配给 defaultObj 。这里用一个变量接收返回的合并对象。</p>
<p>同时形参 obj 也设置了默认值为一个空对象，防止函数调用时不传任何参数，因为这会导致 Object.assign() 接收的第二个参数是 undefined ，从而产生报错。</p>
<p>参数默认值和解构赋值结合使用<br>函数调用时，实参和形参的匹配实际上是一个隐式的赋值过程，所以，参数传递也可以进行解构赋值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">&#123; x, y = <span class="number">2</span>, z = <span class="number">3</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([x, y, z]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;); <span class="comment">// 输出 [undefined, 2, 3]</span></span><br><span class="line"><span class="title function_">fn</span>(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">z</span>: <span class="number">10</span> &#125;); <span class="comment">// 输出 [1, 2, 10]</span></span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，使用的只是对象的解构赋值默认值，还没有使用函数参数的默认值。如果函数调用时不传任何参数，也会产生报错，因为这导致了参数初始化时解构赋值失败，相当于执行了 {x, y &#x3D; 2, z &#x3D; 3} &#x3D; undefined 这样的代码。</p>
<p>同样的，你可以利用参数默认值的语法，给 {x, y &#x3D; 2, z &#x3D; 3} 设置一个默认的解构对象，使得不传参函数也能够顺利执行：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">&#123; x, y = <span class="number">2</span>, z = <span class="number">3</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([x, y, z]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 输出 [undefined, 2, 3]</span></span><br></pre></td></tr></table></figure></div>

<p>这里出现了双重的默认值，可能有些绕，那么用一段伪代码来解释以上的参数初始化过程就是：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( 实参 === &#123;...&#125; ) &#123; <span class="comment">// 当 fn(&#123;...&#125;);     </span></span><br><span class="line">    &#123; x, y = <span class="number">2</span>, z = <span class="number">3</span> &#125; = &#123;...&#125;;</span><br><span class="line">                        </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( 实参 === <span class="literal">undefined</span> )&#123; <span class="comment">// 当 fn();</span></span><br><span class="line">    &#123; x, y = <span class="number">2</span>, z = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>双重默认值有一点细节需要特别注意，就是解构赋值默认值和函数参数默认值的差别，看下面例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> (&#123; x = <span class="number">1</span> &#125; = &#123;&#125;, &#123; y &#125; = &#123; <span class="attr">y</span>: <span class="number">2</span> &#125;)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 输出 1 2</span></span><br><span class="line"><span class="title function_">fn</span>(&#123; <span class="attr">x</span>: <span class="number">10</span> &#125;, &#123; <span class="attr">y</span>: <span class="number">20</span> &#125;); <span class="comment">// 输出 10 20</span></span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;,&#123;&#125;); <span class="comment">// 1 undefined</span></span><br></pre></td></tr></table></figure></div>

<p>这个函数中，有两组参数采用了解构赋值的方式，看似 x 和 y 都设置了默认值，虽然是不同的两种形式，但显然不是任何情况下结果都相同的。当传入的参数是{}时，y 并没有获取到默认值 2 ，为什么会这样呢？结合前面的伪代码例子来看：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>(&#123; <span class="attr">x</span>: <span class="number">10</span> &#125;, &#123; <span class="attr">y</span>: <span class="number">20</span> &#125;); <span class="comment">// 初始化时: &#123; x = 1 &#125; = &#123; x: 10 &#125;, &#123; y &#125; = &#123; y: 20 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;,&#123;&#125;); <span class="comment">// 初始化时: &#123; x = 1 &#125; = &#123;&#125;, &#123; y &#125; = &#123;&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>当传入的参数是{}时，函数参数没有缺失也不是 undefined ，所以函数参数默认值是不起作用的。同时 {} 里面也没有 x 和 y 的对应值，x 得到的 1 是解构赋值默认值，而 y 由于没有设置解构赋值默认值，所以它默认是 undefined。</p>
<p>参数默认值的作用域与暂时性死区<br>还有一个小细节，一旦有参数设置了默认值，那么它们会形成自己的作用域（包裹在(…)中），因此不能引用函数体中的变量：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a = b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 报错，b 未定义</span></span><br></pre></td></tr></table></figure></div>

<p>但这个作用域只是临时的，参数初始化完毕后，这个作用域就不存在了。</p>
<p>它也符合普通作用域的规则：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a = b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></div>

<p>上面例子中，存在一个全局变量 b，那么形参 a 会获取到全局变量 b 的值。</p>
<p>当然，如果形参作用域中存在一个形参 b 的话，它优先获取到的是当前作用域的：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">b = <span class="number">3</span> ,a = b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></div>

<p>给多个参数设置默认值，它们会按顺序初始化的，遵循“暂时性死区”的规则，即前面的参数不能引用后面的参数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a = b, b = <span class="number">2</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 报错，b 在初始化之前不能访问</span></span><br></pre></td></tr></table></figure></div>

<p>五、参数的收集与展开<br>剩余参数<br>ES6 提供了<strong>剩余参数（rest）</strong>的语法（…变量名），它可以收集函数多余的实参（即没有对应形参的实参），这样就不再需要使用 arguments 对象来获取了。形参使用了 … 操作符会变成一个数组，多余的实参都会被放进这个数组中。</p>
<p>剩余参数基本用法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, ...values</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">        a += val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></div>

<p>上面例子中，在参数初始化时，首先根据参数位置进行匹配，把 0 赋值给 a ，然后剩余的参数 1、2、3 都会被放进数组 values 中。</p>
<p>下面是分别用 arguments 对象和剩余参数来获取参数的对比例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>).<span class="title function_">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数的写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sortNumbers</span> = (<span class="params">...numbers</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.<span class="title function_">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line">可以看出剩余参数的写法更加简洁。尽管 <span class="variable language_">arguments</span> 是一个类数组，也是可迭代对象，但它终究不是数组。它不支持数组方法，当我们使用 <span class="variable language_">arguments</span> 时，如果想要调用数组方法，就必须使用<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="property">call</span>先将其转为数组。</span><br></pre></td></tr></table></figure></div>

<p>而剩余参数它不同于 arguments 对象，它是真正的 Array 实例，能够很方便地使用数组方法。并且箭头函数也支持剩余参数。</p>
<p>另外，使用剩余参数不会影响 arguments 对象的功能，它仍然能够反映调用函数时传入的参数。</p>
<p>剩余参数的位置<br>剩余参数必须是最后一个形参，否则会报错。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a, ...rest, b</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>([a, b, rest]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">a, b, ...rest</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b, rest]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn2</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 输出 [1, 2, [3, 4]]</span></span><br></pre></td></tr></table></figure></div>

<p>展开语法<br>前面我们知道了如何把多余的参数收集为一个数组，但有时候我们需要做一些相反的事，例如要把一个数组中的元素分别传入给某个函数，而不是传入一个数组，像这样：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">        sum += val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(arr); <span class="comment">// &quot;01,2,3,4&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>上面例子的函数会把所有传进来的数值累加，如果直接传入一个数组，就得不到我们想要的结果。</p>
<p>例子中传入一个数组， values 的值会变成 [[1, 2, 3, 4]]，导致数组 values 中只有一个元素，而这个元素的类型是数组。那么函数返回值就是数值 0 和数组 [1, 2, 3, 4]相加的结果了，两者各自进行了类型的隐式转换变成字符串，然后再相加，是一个字符串拼接的效果。</p>
<p>要实现把数组拆解传入给函数，首先不可能一个个传入参数——sum(arr[0], arr[1], arr[2], arr[3]);，因为不是任何时候都知道数组中有多少个元素的，而且数组中可能会非常多的元素，手动传是不明智的。</p>
<p>比较可行的是借助 apply() 方法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">sum.<span class="title function_">apply</span>(<span class="literal">null</span>, arr); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></div>

<p>但这还不是最优解，那么重点来了！</p>
<p>ES6 新增的<strong>展开语法（spread）</strong>可以帮助我们面对这种情况。它也是使用 …变量名 的语法，虽然跟剩余参数语法一样，但是用途完全相反，它能够把一个可迭代对象拆分成逗号分隔的参数序列。</p>
<p>在函数调用时，它的应用是这样子的：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sum</span>(...arr); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 sum(1,2,3,4);</span></span><br></pre></td></tr></table></figure></div>

<p>它甚至可以随意搭配常规值使用，没有前后位置限制，还可以同时传入多个可迭代对象：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sum</span>(-<span class="number">1</span>, ...arr); <span class="comment">// 9</span></span><br><span class="line"><span class="title function_">sum</span>(...arr, <span class="number">5</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="title function_">sum</span>(-<span class="number">1</span>, ...arr, <span class="number">5</span>); <span class="comment">// 14</span></span><br><span class="line"><span class="title function_">sum</span>(-<span class="number">1</span>, ...arr, ...[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的异常处理机制</title>
    <url>/2023/05/13/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>Java是一种面向对象的编程语言，广泛应用于Web应用开发、游戏开发、企业应用开发等领域。在Java的开发过程中，异常处理是一个非常重要的机制。本文将介绍Java中的异常处理机制，包括异常的定义、异常的分类、异常处理的方式等。</p>
<p>一、异常的定义<br>在Java中，异常是一种程序执行期间发生的问题。它可以是由程序员自己抛出的异常，也可以是由Java运行时系统抛出的异常。异常可以是一个错误、一个意外情况、一个阻碍程序正常执行的问题等等。在Java中，异常可以通过try-catch块来捕获和处理。</p>
<p>二、异常的分类<br>Java中的异常可以分为编译时异常和运行时异常。编译时异常是指在编译时期就能够预见到的异常，如文件不存在、权限不足等。编译时异常必须在代码中进行处理，否则程序将无法通过编译。运行时异常是指在程序运行期间才能够出现的异常，如除零错误、类型转换错误等。运行时异常可以不进行处理，但是如果不进行处理，程序将会中断并抛出异常。有些异常既可以是编译时异常，也可以是运行时异常，如空指针异常等。</p>
<p>三、异常处理的方式<br>Java中有几种处理异常的方式，包括使用try-catch块、使用throws关键字和使用finally块。</p>
<ol>
<li>try-catch块</li>
</ol>
<p>try-catch块是一种处理异常的方式，可以在代码块中检测异常并进行处理。在try块中，可以放一段可能会抛出异常的代码。在catch块中，可以捕获并处理异常。同时，还可以使用多个catch块来捕获不同类型的异常。</p>
<p>下面是一个使用try-catch块处理异常的例子：</p>
<p>try {<br>    &#x2F;&#x2F;可能会抛出异常的代码<br>} catch (ExceptionType1 e) {<br>    &#x2F;&#x2F;处理异常的代码<br>} catch (ExceptionType2 e) {<br>    &#x2F;&#x2F;处理异常的代码<br>} finally {<br>    &#x2F;&#x2F;无论是否有异常，均执行的代码<br>}</p>
<ol start="2">
<li>使用throws关键字</li>
</ol>
<p>throws关键字用于声明可能会抛出异常的方法，并将异常抛给调用该方法的方法处理。这种方法需要在方法定义中使用throws关键字声明可能会抛出的异常类型。</p>
<p>下面是一个使用throws关键字处理异常的例子：</p>
<p>public void openFile() throws FileNotFoundException {<br>    &#x2F;&#x2F;打开文件的代码<br>}</p>
<ol start="3">
<li>使用finally块</li>
</ol>
<p>finally块用于执行无论是否有异常，都必须执行的代码（如关闭文件、释放资源等）。即使在try块中抛出了异常，在catch块中使用了return语句，finally块中的代码也必须执行。</p>
<p>下面是一个使用finally块处理异常的例子：</p>
<p>try {<br>    &#x2F;&#x2F;可能会抛出异常的代码<br>} catch (Exception e) {<br>    &#x2F;&#x2F;处理异常的代码<br>} finally {<br>    &#x2F;&#x2F;无论是否有异常，均执行的代码，如关闭文件、释放资源等<br>}</p>
<p>四、总结</p>
<p>异常处理是Java编程过程中必须要掌握的机制。Java中的异常分为编译时异常和运行时异常，可以通过try-catch块、throws关键字和finally块来处理。程序员需要根据实际需求选择合适的异常处理方式，保证程序的正常执行。</p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java爬虫</title>
    <url>/2022/09/26/Java%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<p>在日常生活中，我们最先想到的爬虫是Python，它的确是一个非常方便且快捷易上手的，<br>但我们是否能用Java来实现python这一功能呢，让我们一起来看看~</p>
<h2 id="导入Jar包"><a href="#导入Jar包" class="headerlink" title="导入Jar包"></a>导入Jar包</h2><p>需要用到Jsoup这个包导入即可</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="分析网页"><a href="#分析网页" class="headerlink" title="分析网页"></a>分析网页</h2><p>先浏览器进去网址，F12看看，找找规律</p>
<p>发现这地址在 <ul class="b_boxjw1"> <li> 的 a标签里，这个时候通过标签选择器定位到这个a标签</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.connect(html).get();</span><br><span class="line"></span><br><span class="line"><span class="type">Elements</span> <span class="variable">elements</span> <span class="operator">=</span> document.select(<span class="string">&quot;div.g_box1 &gt; ul &gt; li &gt; a&quot;</span>);<span class="comment">//此处是所有a标签的集合</span></span><br></pre></td></tr></table></figure></div>

<p>然后 再遍历elements获取到这个a标签的href属性  通过拼接地址  得到想要的每个页面的完整链接</p>
<p><a class="link"   href="https://m.jieseba.org//a/4149.html" >https://m.jieseba.org//a/4149.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Element element:elements)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">d_url</span> <span class="operator">=</span> element.attr(<span class="string">&quot;href&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;详情页链接：https://m.jieseba.org/&quot;</span>+d_url);<span class="comment">//这个就是网页内容的链接地址</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个时候看一下详情页的内容，想要的数据都在类为txt1的div下的p标签里，再想上面一样，定位到这个p标签</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;https://m.jieseba.org/&quot;</span>+d_url).get();</span><br><span class="line"><span class="type">Elements</span> <span class="variable">select</span> <span class="operator">=</span> doc.select(<span class="string">&quot;div.g_con &gt; div.txt1 &gt; p&quot;</span>);<span class="comment">//定位到P标签 此时是P标签集合</span></span><br></pre></td></tr></table></figure></div>



<p>定位到P标签之后还是跟上面的步骤一样，循环输出就可以了</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Element ele : select) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> ele.ownText();</span><br><span class="line">    System.out.println(index);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.3zi.www;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrabUrl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**测试*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">html</span> <span class="operator">=</span> <span class="string">&quot;https://m.jieseba.org/a/jzbj_1.html&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> Jsoup.connect(html).get();</span><br><span class="line"></span><br><span class="line">        <span class="type">Elements</span> <span class="variable">elements</span> <span class="operator">=</span> document.select(<span class="string">&quot;div.g_box1 &gt; ul &gt; li &gt; a&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Element element:elements)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">d_url</span> <span class="operator">=</span> element.attr(<span class="string">&quot;href&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;详情页链接：https://m.jieseba.org/&quot;</span>+d_url);</span><br><span class="line"></span><br><span class="line">            <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.connect(<span class="string">&quot;https://m.jieseba.org/&quot;</span>+d_url).get();</span><br><span class="line">            <span class="type">Elements</span> <span class="variable">select</span> <span class="operator">=</span> doc.select(<span class="string">&quot;div.g_con &gt; div.txt1 &gt; p&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Element ele : select) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> ele.ownText();</span><br><span class="line">                System.out.println(index);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java后端返回Json数据规范</title>
    <url>/2023/03/23/Java%E5%90%8E%E7%AB%AF%E8%BF%94%E5%9B%9EJson%E6%95%B0%E6%8D%AE%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="Java后端返回Json数据规范"><a href="#Java后端返回Json数据规范" class="headerlink" title="Java后端返回Json数据规范"></a>Java后端返回Json数据规范</h1><h2 id="一，统一返回的Json数据格式"><a href="#一，统一返回的Json数据格式" class="headerlink" title="一，统一返回的Json数据格式"></a>一，统一返回的Json数据格式</h2><h4 id="返回内容："><a href="#返回内容：" class="headerlink" title="返回内容："></a>返回内容：</h4><p>状态码，返回消息，数据</p>
<h4 id="1-列表数据"><a href="#1-列表数据" class="headerlink" title="1.列表数据"></a>1.列表数据</h4><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">20000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小王&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;identified&quot;</span><span class="punctuation">:</span> <span class="string">&quot;用户&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-分页数据"><a href="#2-分页数据" class="headerlink" title="2.分页数据"></a>2.分页数据</h4><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">20000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">17</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小王&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;identified&quot;</span><span class="punctuation">:</span> <span class="string">&quot;用户&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-无返回数据"><a href="#3-无返回数据" class="headerlink" title="3.无返回数据"></a>3.无返回数据</h4><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">20000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="4-返回数据失败"><a href="#4-返回数据失败" class="headerlink" title="4.返回数据失败"></a>4.返回数据失败</h4><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">20001</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;失败&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="统一定义格式："><a href="#统一定义格式：" class="headerlink" title="统一定义格式："></a>统一定义格式：</h4><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> 布尔<span class="punctuation">,</span> <span class="comment">//响应是否成功</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> 数字<span class="punctuation">,</span> <span class="comment">//响应码</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> 字符串<span class="punctuation">,</span> <span class="comment">//返回消息</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> HashMap <span class="comment">//返回数据，放在键值对中</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="二，创建统一返回结果类"><a href="#二，创建统一返回结果类" class="headerlink" title="二，创建统一返回结果类"></a>二，创建统一返回结果类</h2><h4 id="1-创建接口定义返回码"><a href="#1-创建接口定义返回码" class="headerlink" title="1.创建接口定义返回码"></a>1.创建接口定义返回码</h4><p>创建工具包utils，创建接口命名为ResultCode.java</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.commonutils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResultCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">SUCCESS</span> <span class="operator">=</span> <span class="number">20000</span>;  <span class="comment">//成功码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">ERROR</span> <span class="operator">=</span> <span class="number">20001</span>;  <span class="comment">//失败码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-创建结果类"><a href="#2-创建结果类" class="headerlink" title="2.创建结果类"></a>2.创建结果类</h4><p>创建类Result</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;是否成功&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;返回码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;返回消息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;返回数据&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Result</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">        r.setSuccess(<span class="literal">true</span>);</span><br><span class="line">        r.setCode(ResultCode.SUCCESS);</span><br><span class="line">        r.setMessage(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">        r.setSuccess(<span class="literal">false</span>);</span><br><span class="line">        r.setCode(ResultCode.ERROR);</span><br><span class="line">        r.setMessage(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">success</span><span class="params">(Boolean success)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setSuccess(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">message</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">code</span><span class="params">(Integer code)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setCode(code);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">data</span><span class="params">(String key, Object value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">data</span><span class="params">(Map&lt;String, Object&gt; map)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.setData(map);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-Controller中的返回统一数据格式的Json示例"><a href="#3-Controller中的返回统一数据格式的Json示例" class="headerlink" title="3.Controller中的返回统一数据格式的Json示例"></a>3.Controller中的返回统一数据格式的Json示例</h4><p>列表数据<br>在返回的json的中，有一个键值为data的Hashmap<br>使用mybatis plus无条件（wrapper为null，查询全部）查询所有用户的信息<br>所有信息返回一个list<br>将list放入hashmap中，键值为items</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;所有列表&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;findAllTeacher&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Teacher&gt; list = teacherService.list(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok().data(<span class="string">&quot;items&quot;</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>空数据<br>这里是根据id删除用户信息，因此无返回数据</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;根据ID删除&quot;)</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">removeById</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@ApiParam(name = &quot;id&quot;, value = &quot;ID&quot;, required = true)</span></span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable</span> String id)</span>&#123;</span><br><span class="line">    teacherService.removeById(id);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Java23种设计模式</title>
    <url>/2023/07/26/Java23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Java设计模式：23种设计模式"><a href="#Java设计模式：23种设计模式" class="headerlink" title="Java设计模式：23种设计模式"></a>Java设计模式：23种设计模式</h1><h2 id="设计模式的目标："><a href="#设计模式的目标：" class="headerlink" title="设计模式的目标："></a><strong>设计模式的目标：</strong></h2><p>提升代码重用性、可读性、可扩展性、可靠性，还能降低系统中类与类之间的耦合度，使程序呈现高内聚低耦合的特性。</p>
<h2 id="设计模式的价值："><a href="#设计模式的价值：" class="headerlink" title="设计模式的价值："></a><strong>设计模式的价值：</strong></h2><p>代码重用性、可读性、可扩展性、可靠性</p>
<h2 id="设计模式常用6大原则："><a href="#设计模式常用6大原则：" class="headerlink" title="设计模式常用6大原则："></a><strong>设计模式常用6大原则：</strong></h2><ol>
<li>单一职责原则（SRP）：一个类只应该有一个引起它变化的原因。</li>
<li>开放封闭原则（OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。</li>
<li>里氏替换原则（LSP）：子类型必须能够替换掉它们的父类型。</li>
<li>依赖倒置原则（DIP）：高层模块不应该依赖于低层模块，两者都应该依赖于抽象接口；抽象接口不应该依赖于具体实现，具体实现应该依赖于抽象接口。</li>
<li>接口隔离原则（ISP）：不应该强迫一个类实现它不需要的接口，应该将接口拆分成更小和更具体的部分，以便客户端只需要知道它们感兴趣的部分。</li>
<li>迪米特法则（LOD）：一个对象应该对其他对象有尽可能少的了解，通常称为“最少知识原则”。</li>
</ol>
<h2 id="设计模式的种类："><a href="#设计模式的种类：" class="headerlink" title="设计模式的种类："></a><strong>设计模式的种类：</strong></h2><p>1、创建型模式<br>用来描述“如何创建对象”，它的主要特点是“将对象的创建和使用分离”<br>2、结构型模式<br>用来描述如何将类或对象按照某种布局组成更大的结构<br>3、行为型模式<br>用来识别对象之间的常用交流模式以及如何分配职责</p>
<h2 id="一、5种创建型模式"><a href="#一、5种创建型模式" class="headerlink" title="一、5种创建型模式"></a>一、5种创建型模式</h2><p>单例模式、建造者模式、抽象工厂模式、原型模式、工厂模式。</p>
<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p><strong>定义</strong><br>创建某个类的实例，该类的实例在系统中只有这一份<br>单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而使用单例模式能够保证整个应用中有且只有一个实例。<br><strong>应用场景</strong><br>一个国家只有一个总统:<br>项目中用于读取配置文件的类;<br>数据库连接池，因为数据库连接池是一种数据库资源:Spring中，每个Bean默认都是单例的，这样便于Spring容器进行管理:Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行</p>
<p>特点：</p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h3 id="1）饿汉式"><a href="#1）饿汉式" class="headerlink" title="1）饿汉式"></a>1）饿汉式</h3><p>这种方式比较常用，但容易产生垃圾对象<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2）懒汉式，双检锁"><a href="#2）懒汉式，双检锁" class="headerlink" title="2）懒汉式，双检锁"></a>2）懒汉式，双检锁</h3><p>在懒汉式基础上加入双重检验锁，保证线程安全和性能。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3）静态内部类"><a href="#3）静态内部类" class="headerlink" title="3）静态内部类"></a>3）静态内部类</h3><p>使用静态内部类来实现懒汉式单例模式，保证线程安全和性能。这种方式能达到双检锁方式一样的功效，但实现更简单。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4）枚举"><a href="#4）枚举" class="headerlink" title="4）枚举"></a>4）枚举</h3><p>使用枚举来实现单例模式，保证线程安全和防止反射攻击。<br>1）将已经有的class转换成枚举单例<br><code>PersonEnum.INSTANCE.getInstance()</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PersonEnum</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Person instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PersonEnum</span><span class="params">()</span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>2）直接新建枚举类<br><code>PersonSingleton.INSTANCE</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PersonSingleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h3><p><strong>定义</strong><br>工厂模式属于创建型设计模式，需要生成的对象叫做产品，生成对象的地方叫做工厂把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。<br><strong>应用场景</strong><br>在任何需要生成复杂对象的场景，都可以使用工厂模式</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个静态方法，根据传入的参数创建具体的产品类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title function_">createAnimal</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;dog&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;cat&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid animal type: &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用工厂类创建不同的 Animal 对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> AnimalFactory.createAnimal(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        dog.sound();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> AnimalFactory.createAnimal(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        cat.sound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3.抽象工厂模式"></a>3.抽象工厂模式</h3><p><strong>定义</strong><br>抽象工厂模式(Abstract Factory Pattern) 是围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类，每个生成的工厂都能按照工厂模式提供对象<br><strong>应用场景</strong><br>系统中有多于一个的产品族，而每次只使用其中某一产品族在很多软件系统中需要更换界面主题或者一键换肤DAO层支持多种类型的数据库，动态切换时。不同操作系统代码差异化，可以切换不同操作系统</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个抽象产品类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建具体产品类，继承自 Animal 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个抽象方法，用于创建 Animal 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatFactory</span> <span class="keyword">extends</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建具体工厂类，实现创建 Animal 对象的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogFactory</span> <span class="keyword">extends</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 Dog 对象</span></span><br><span class="line">        <span class="type">AnimalFactory</span> <span class="variable">dogFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogFactory</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> dogFactory.createAnimal();</span><br><span class="line">        dog.sound();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 Cat 对象</span></span><br><span class="line">        <span class="type">AnimalFactory</span> <span class="variable">catFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CatFactory</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> catFactory.createAnimal();</span><br><span class="line">        cat.sound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.原型模式"></a>4.原型模式</h3><p><strong>定义</strong><br>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。<br><strong>应用场景</strong><br>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等，通过原型拷贝避免这些消耗。<br>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">protected</span> String type;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">clone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone = <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span> &#123;</span><br><span class="line">        type = <span class="string">&quot;Circle&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">()</span> &#123;</span><br><span class="line">        type = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Shape&gt; shapeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeId)</span> &#123;</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">cachedShape</span> <span class="operator">=</span> shapeMap.get(shapeId);</span><br><span class="line">        <span class="keyword">return</span> (Shape) cachedShape.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// For each shape run database query and create shape</span></span><br><span class="line">    <span class="comment">// shapeMap.put(shapeKey, shape);</span></span><br><span class="line">    <span class="comment">// for example, we are adding three shapes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        circle.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        shapeMap.put(circle.getId(), circle);</span><br><span class="line">        <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        square.setId(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        shapeMap.put(square.getId(), square);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ShapeCache.loadCache();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">clonedShape</span> <span class="operator">=</span> ShapeCache.getShape(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape : &quot;</span> + clonedShape.getType());</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">clonedShape2</span> <span class="operator">=</span> ShapeCache.getShape(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Shape : &quot;</span> + clonedShape2.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的代码中，Shape是一个抽象类，它实现了Cloneable接口并重写了clone()方法。Circle和Square是Shape的具体子类，它们实现了draw()方法。ShapeCache类是一个缓存，它存储了Shape对象的副本。PrototypePatternDemo类是一个演示类，它使用ShapeCache来获取Shape对象的副本。</p>
<p>在loadCache()方法中，我们创建了两个Shape对象的副本，并将它们存储在shapeMap中。在main()方法中，我们使用getShape()方法来获取Shape对象的副本，并输出它们的类型。由于我们使用了原型模式，所以我们可以通过复制现有对象来创建新对象，而无需实例化类。</p>
<h3 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5.建造者模式"></a>5.建造者模式</h3><p><strong>定义</strong><br>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成不同复杂对象<br><strong>应用场景</strong><br>建造者模式一般用在构建流程或者组成部件固定的场合，将这些部件分开构建成为组件对象<br>再将这些组件对象整合成为目标对象。比如创建一个旅游产品，旅游产品里面有机票，酒店，门票，保险等等，行程定制师可以根据你的要求，组装成一个你满意的产品。<br>生活中的应用场景，比如汽车中的方向盘，发动机，车架，轮胎等等部件也是多种多样的</p>
<p>在这个示例中，我们创建了Car类作为我们想要构建的复杂对象。然后，我们创建了CarBuilder类，该类逐步构建Car对象，并最终返回它。最后，我们使用CarBuilder来构建Car对象。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String make;</span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> String engine;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seats;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String make, String model, <span class="type">int</span> year, String engine, <span class="type">int</span> seats)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.make = make;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">        <span class="built_in">this</span>.seats = seats;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ... getter setter ... //</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String make;</span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> String engine;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setMake</span><span class="params">(String make)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.make = make;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setModel</span><span class="params">(String model)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setEngine</span><span class="params">(String engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setSeats</span><span class="params">(<span class="type">int</span> seats)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seats = seats;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(make, model, year, engine, seats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="二、7种结构性模式"><a href="#二、7种结构性模式" class="headerlink" title="二、7种结构性模式"></a>二、7种结构性模式</h2><p>适配器模式、代理模式、享元模式、外观模式、组合模式、装饰模式、桥接模式</p>
<h3 id="1-适配器模式"><a href="#1-适配器模式" class="headerlink" title="1.适配器模式"></a>1.适配器模式</h3><p><strong>定义</strong><br>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<br>目的是兼容性，让原本因接口不匹配，不能一起工作的两个类可以协同工作.<br><strong>应用场景</strong><br>封装有缺陷的接口设计统一多个类的接口设计，比如一个支付系统，有三种不同的支付方式，微信支付、支付宝支付、网银支付，这三种支付的实现方法都不一样，那么我们可以用适配器模式，让他们对外具有统一的方法，这样，我们在调用的时候就非常的方便兼容老版本的接口，这个在我们系统升级中经常会用到</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String make;</span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> String engine;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seats;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String make, String model, <span class="type">int</span> year, String engine, <span class="type">int</span> seats)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.make = make;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">        <span class="built_in">this</span>.seats = seats;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ... getter setter ... //</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String make;</span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> String engine;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setMake</span><span class="params">(String make)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.make = make;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setModel</span><span class="params">(String model)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.model = model;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setYear</span><span class="params">(<span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setEngine</span><span class="params">(String engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CarBuilder <span class="title function_">setSeats</span><span class="params">(<span class="type">int</span> seats)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seats = seats;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(make, model, year, engine, seats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-桥接模式"><a href="#2-桥接模式" class="headerlink" title="2.桥接模式"></a>2.桥接模式</h3><p><strong>定义</strong><br>把 抽象(Abstraction) 与行为实现(lmplementation) 分离开，保持各部分的独立性以及功能扩展。<br><strong>应用场景</strong><br>JDBC连接数据库时，利用驱动来桥接</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，我们定义一个 Color 接口，它表示颜色：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">applyColor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后，我们定义一个 Shape 抽象类，它包含了一个 Color 对象：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Color color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">applyColor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接下来，我们定义两个实现了 Color 接口的具体类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Red</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyColor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Applying red color&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blue</span> <span class="keyword">implements</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyColor</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Applying blue color&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后，我们定义两个实现了 Shape 抽象类的具体类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyColor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Circle applying color: &quot;</span>);</span><br><span class="line">        color.applyColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(Color color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">applyColor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Square applying color: &quot;</span>);</span><br><span class="line">        color.applyColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在，我们可以使用这些类来创建出对应的对象并调用它们的方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Color</span> <span class="variable">blue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Blue</span>();</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="keyword">new</span> <span class="title class_">Red</span>());</span><br><span class="line">        <span class="type">Shape</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(blue);</span><br><span class="line">        square.applyColor();</span><br><span class="line">        circle.applyColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出结果如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Square applying color: Applying red color</span><br><span class="line">Circle applying color: Applying blue color</span><br></pre></td></tr></table></figure></div>

<p>这是一个简单的桥接模式实现，它允许我们在运行时动态地改变 Shape 类的颜色而不用影响到 Shape 子类，同时也允许我们增加新的颜色和形状类而无需改变其它现有的类。</p>
<h3 id="3-装饰模式"><a href="#3-装饰模式" class="headerlink" title="3.装饰模式"></a>3.装饰模式</h3><p><strong>定义</strong><br>动态的将新功能附加到对象上，就像打包一个快递，一层一层地给物品添加外层包装<br>应用场景<br><strong>扩展一个类的功能</strong><br>动态增加功能，动态撤销.</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 具体组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PlainPizza</span> <span class="keyword">implements</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;薄饼&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4.00</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ToppingDecorator</span> <span class="keyword">implements</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Pizza pizza;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ToppingDecorator</span><span class="params">(Pizza pizza)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pizza = pizza;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pizza.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pizza.getCost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 具体装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cheese</span> <span class="keyword">extends</span> <span class="title class_">ToppingDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cheese</span><span class="params">(Pizza pizza)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(pizza);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pizza.getDescription() + <span class="string">&quot;，马苏里拉奶酪&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pizza.getCost() + <span class="number">0.50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 具体装饰器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pepperoni</span> <span class="keyword">extends</span> <span class="title class_">ToppingDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pepperoni</span><span class="params">(Pizza pizza)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(pizza);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pizza.getDescription() + <span class="string">&quot;，意大利辣香肠&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getCost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pizza.getCost() + <span class="number">1.00</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaShop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlainPizza</span>();</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">Cheese</span>(pizza);</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">Pepperoni</span>(pizza);</span><br><span class="line">        System.out.println(pizza.getDescription());</span><br><span class="line">        System.out.println(<span class="string">&quot;成本：$&quot;</span> + pizza.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-组合模式"><a href="#4-组合模式" class="headerlink" title="4.组合模式"></a>4.组合模式</h3><p><strong>定义</strong><br>依据树形结构来组合对象，用来表示部分以及整体层次，比如: 学校、院、系的关系<br><strong>应用场景</strong><br>组合模式非常适合有递归迭代性质的结构或者逻辑。即结构上存在树型或者包含关系，逻辑上”整体”和”部分”的行为和状态的对外表现是一致的，或者是类似的。比如目录和文件，目录可以只包含子目录，也可以只包含文件，当然可以同时包含子目录和文件，而子目录又可以包含子目录或者文件。</p>
<p>以下是一个使用Java实现组合模式的示例代码，其中我们使用一个抽象类Component来表示树形结构中的节点，包括叶节点和组合节点。组合节点包含子节点，可以通过add()和remove()方法来添加和删除子节点。叶节点没有子节点，但可以实现共同的操作方法。具体的组合节点继承自Component类，实现自己的操作方法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IComponent</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Component.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">implements</span> <span class="title class_">IComponent</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IComponent component)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(IComponent component)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Composite.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IComponent&gt; children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(IComponent component)</span> &#123;</span><br><span class="line">        children.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(IComponent component)</span> &#123;</span><br><span class="line">        children.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Composite: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (IComponent component : children) &#123;</span><br><span class="line">            component.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Leaf.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">implements</span> <span class="title class_">IComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Leaf: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Client.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">branch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;branch1&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">branch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;branch2&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">leaf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;leaf1&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">leaf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;leaf2&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">leaf3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;leaf3&quot;</span>);</span><br><span class="line">        root.add(branch1);</span><br><span class="line">        root.add(branch2);</span><br><span class="line">        branch1.add(leaf1);</span><br><span class="line">        branch2.add(leaf2);</span><br><span class="line">        branch2.add(leaf3);</span><br><span class="line">        root.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-外观模式"><a href="#5-外观模式" class="headerlink" title="5.外观模式"></a>5.外观模式</h3><p><strong>定义</strong><br>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。<br><strong>应用场景</strong><br>为一个复杂的模块或子系统提供一个供外界访问的接口。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在加载内存...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">HardDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在读取硬盘数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 外观类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> HardDrive hardDrive;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ComputerFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line">        memory = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        hardDrive = <span class="keyword">new</span> <span class="title class_">HardDrive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动计算机...&quot;</span>);</span><br><span class="line">        cpu.processData();</span><br><span class="line">        memory.load();</span><br><span class="line">        hardDrive.readData();</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机启动完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacadePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ComputerFacade</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerFacade</span>();</span><br><span class="line">        computer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-享元模式"><a href="#6-享元模式" class="headerlink" title="6.享元模式"></a>6.享元模式</h3><p><strong>定义</strong><br>使用共享对象可以有效的支持大量细粒度对象的复用，比如: 池化技术，数据库连接池 、线程池 等<br><strong>应用场景</strong><br>系统中存在大量的相似对象<br>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对 象没有特定身份。<br>需要缓冲池的场景</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在处理数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在加载内存...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">HardDrive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在读取硬盘数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 外观类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CPU cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    <span class="keyword">private</span> HardDrive hardDrive;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ComputerFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> <span class="title class_">CPU</span>();</span><br><span class="line">        memory = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        hardDrive = <span class="keyword">new</span> <span class="title class_">HardDrive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启动计算机...&quot;</span>);</span><br><span class="line">        cpu.processData();</span><br><span class="line">        memory.load();</span><br><span class="line">        hardDrive.readData();</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机启动完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacadePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ComputerFacade</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComputerFacade</span>();</span><br><span class="line">        computer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="7-代理模式"><a href="#7-代理模式" class="headerlink" title="7.代理模式"></a>7.代理模式</h3><p><strong>定义</strong><br>封装目标对象，并添加额外的功能，对客户端提供更多更优的服务，分类: 静态代理和动态代理。<br><strong>应用场景</strong><br>日志的采集<br>权限控制<br>实现aop<br>Mybatis mapper<br>Spring的事务全局捕获异常Rpc远程调用接口<br>分布式事务原理代理数据源</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**代理接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    String <span class="title function_">hi</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**代理接口实现类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hi</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello:&quot;</span> + key;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloImpl! &quot;</span> + str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**静态代理类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloStaticProxy</span> <span class="keyword">implements</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IHello hello;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloStaticProxy</span><span class="params">(IHello hello)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hi</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; static proxy start&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> hello.hi(key);</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; static proxy end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**测试*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IHello</span> <span class="variable">helloProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloStaticProxy</span>(<span class="keyword">new</span> <span class="title class_">HelloImpl</span>());</span><br><span class="line">        helloProxy.hi(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2）jdk动态代理"><a href="#2）jdk动态代理" class="headerlink" title="2）jdk动态代理"></a>2）jdk动态代理</h3><p>jdk动态代理是基于接口的一种代理方式，目标对象一定要实现接口。</p>
<p>原理是，利用反射机制，动态生成匿名类继承Proxy类并且实现了要代理的接口，由于java不支持多继承，所以JDK动态代理不能代理类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**代理接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    String <span class="title function_">hi</span><span class="params">(String key)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**代理接口实现类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hi</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello:&quot;</span> + key;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloImpl! &quot;</span> + str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**jdk动态代理类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JdkProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取被代理接口实例对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; JdkProxy start&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt; JdkProxy end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**测试*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JdkProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkProxy</span>(<span class="keyword">new</span> <span class="title class_">HelloImpl</span>());</span><br><span class="line">        <span class="type">IHello</span> <span class="variable">helloProxy</span> <span class="operator">=</span> proxy.getProxy();</span><br><span class="line">        helloProxy.hi(<span class="string">&quot; jdk proxy !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>目标对象可以不用实现接口，不能针对final类进行代理。<br>原理是，动态生成class继承目标对象。使用cglib必须引入对应的jar包</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">/**目标类*/</span><br><span class="line">public class HelloImpl &#123;</span><br><span class="line">    public String hi(String key) &#123;</span><br><span class="line">        String str = &quot;hello:&quot; + key;</span><br><span class="line">        System.out.println(&quot;HelloImpl! &quot; + str);</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**cglib代理类*/</span><br><span class="line">public class CglibProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取被代理接口实例对象</span><br><span class="line">     */</span><br><span class="line">    public <span class="tag">&lt;<span class="name">T</span>&gt;</span> T getProxy() &#123;</span><br><span class="line">        //1创建增强器对象</span><br><span class="line">        Enhancer e = new Enhancer();</span><br><span class="line">        //2设置增强器的类加载器</span><br><span class="line">        e.setClassLoader(target.getClass().getClassLoader());</span><br><span class="line">        //3设置代理对象父类类型</span><br><span class="line">        e.setSuperclass(target.getClass());</span><br><span class="line">        //4设置回调函数</span><br><span class="line">        e.setCallback(this);</span><br><span class="line">        //5创建代理对象</span><br><span class="line">        return (T) e.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CglibProxy(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;&gt;&gt;&gt; cglib start&quot;);</span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;&gt;&gt;&gt; cglib end&quot;);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**测试*/</span><br><span class="line">public class Demo3Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HelloImpl hello = new HelloImpl();</span><br><span class="line">        CglibProxy cglibProxy = new CglibProxy(hello);</span><br><span class="line">        HelloImpl proxy = cglibProxy.getProxy();</span><br><span class="line">        proxy.hi(&quot; cglib &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="三、11种行为型模式"><a href="#三、11种行为型模式" class="headerlink" title="三、11种行为型模式"></a>三、11种行为型模式</h2><p>模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式。</p>
<h3 id="1-模板方法模式"><a href="#1-模板方法模式" class="headerlink" title="1.模板方法模式"></a>1.模板方法模式</h3><p><strong>定义</strong><br>定义了操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤。<br><strong>应用场景</strong><br>多个子类有共同的方法，且逻辑基本相同可以把核心的算法和重要的功能设计为模板方法，子类去实现相关细节功能系统在进行重构或者是功能优化的时候可以将子类重复的代码抽离到父类中</p>
<p>下面是一个简单的Java模板模式示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span>;</span><br><span class="line">     <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化游戏</span></span><br><span class="line">        initialize();</span><br><span class="line">         <span class="comment">// 开始游戏</span></span><br><span class="line">        startPlay();</span><br><span class="line">         <span class="comment">// 结束游戏</span></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Cricket</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cricket Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Football</span> <span class="keyword">extends</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">endPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Finished!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Initialized! Start playing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startPlay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Football Game Started. Enjoy the game!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplatePatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Game</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cricket</span>();</span><br><span class="line">        game.play();</span><br><span class="line">         System.out.println();</span><br><span class="line">         game = <span class="keyword">new</span> <span class="title class_">Football</span>();</span><br><span class="line">        game.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的代码中，Game类是一个抽象类，定义了一个play()方法作为模板方法。Cricket和Football类是具体的实现类，它们实现了抽象类中定义的抽象方法。在main()方法中，我们创建了一个Cricket对象和一个Football对象，并调用它们的play()方法。这样我们就可以在不改变算法结构的情况下重新定义算法中的某些步骤。</p>
<h3 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2.命令模式"></a>2.命令模式</h3><p><strong>定义</strong><br>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。<br>消除了 请求发送者 与 请求接收者 之间的合，对象之间的调用关系更加灵活，实现解耦<br><strong>应用场景</strong><br>当一个应用程序调用者与多个目标对象之间存在调用关系时，并且目标对象之间的操作很类似的时候。例如当一个目标对象内部的方法调用太复杂，或者内部的方法需要协作才能完成对象的某个特点操作时。<br>有时候调用者调用目标对象后，需要回调一些方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String[] args)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 定义具体命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreateFileCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据给定的名称和内容创建文件的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;创建文件 : &quot;</span> + String.join(<span class="string">&quot;, &quot;</span>, args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">DeleteFileCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据给定的名称删除文件的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除文件 : &quot;</span>+String.join(<span class="string">&quot;,&quot;</span>,args) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 定义命令执行者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommandExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Command&gt; commands = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">CommandExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 将具体命令与命令名称关联起来</span></span><br><span class="line">        commands.put(<span class="string">&quot;create&quot;</span>, <span class="keyword">new</span> <span class="title class_">CreateFileCommand</span>());</span><br><span class="line">        commands.put(<span class="string">&quot;delete&quot;</span>, <span class="keyword">new</span> <span class="title class_">DeleteFileCommand</span>());</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCommand</span><span class="params">(String commandName, String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找对应的命令并执行</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> commands.get(commandName);</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="literal">null</span>) &#123;</span><br><span class="line">            command.execute(args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Unknown command: &quot;</span> + commandName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 使用命令执行者执行命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CommandExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommandExecutor</span>();</span><br><span class="line">        executor.executeCommand(<span class="string">&quot;create&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>&#125;);</span><br><span class="line">        executor.executeCommand(<span class="string">&quot;delete&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;file.txt&quot;</span>&#125;);</span><br><span class="line">        executor.executeCommand(<span class="string">&quot;unknown&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建文件 : file.txt, Hello World!</span><br><span class="line">删除文件 : file.txt</span><br><span class="line">Unknown command: unknown</span><br></pre></td></tr></table></figure></div>

<h3 id="3-访问者模式"><a href="#3-访问者模式" class="headerlink" title="3.访问者模式"></a>3.访问者模式</h3><p><strong>定义</strong><br>将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式<br><strong>应用场景</strong><br>对象结构比较稳定，但经常需要在此对象结构上定义新的操作。需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。</p>
<p>下面是一个简单的Java备忘录模式示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Originator类表示原始对象，它包含需要保存的状态。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// createMemento()方法创建备忘录对象，并将当前状态保存到备忘录对象中。</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// restore()方法用于从备忘录对象中恢复先前的状态。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restore</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Memento类表示备忘录对象，它包含需要保存的状态。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Caretaker类负责管理备忘录对象，它包含一个Memento对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MementoPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line">        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();</span><br><span class="line">         <span class="comment">// 保存原始对象的状态到备忘录对象中</span></span><br><span class="line">        originator.setState(<span class="string">&quot;State 1&quot;</span>);</span><br><span class="line">        caretaker.setMemento(originator.createMemento());</span><br><span class="line">         <span class="comment">// 修改原始对象的状态</span></span><br><span class="line">        originator.setState(<span class="string">&quot;State 2&quot;</span>);</span><br><span class="line">         <span class="comment">// 从备忘录对象中恢复先前的状态</span></span><br><span class="line">        originator.restore(caretaker.getMemento());</span><br><span class="line">         System.out.println(<span class="string">&quot;Current state: &quot;</span> + originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的代码中，Originator类表示原始对象，它包含需要保存的状态。createMemento()方法创建备忘录对象，并将当前状态保存到备忘录对象中。restore()方法用于从备忘录对象中恢复先前的状态。</p>
<p>Memento类表示备忘录对象，它包含需要保存的状态。</p>
<p>Caretaker类负责管理备忘录对象，它包含一个Memento对象。</p>
<p>在main()方法中，我们创建了一个Originator对象和一个Caretaker对象，并调用它们的方法进行状态保存和恢复。通过备忘录模式，我们可以在不破坏封装性的情况下捕获和恢复对象的内部状态。</p>
<h3 id="4-迭代器模式"><a href="#4-迭代器模式" class="headerlink" title="4.迭代器模式"></a>4.迭代器模式</h3><p><strong>定义</strong><br>提供一种方法顺序访问一个聚合对象中各个元素,而又无须暴露该对象的内部表示，提供一种遍历集合元素的统一接口。<br><strong>应用场景</strong><br>统一接口:为遍历不同的 集合结构，提供统一接口</p>
<p>下面是一个简单的Java迭代器模式示例代码，使用数组存储，实现了一个数组迭代器：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 具体迭代器实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currentIndex;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ArrayIterator</span><span class="params">(T[] array)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.currentIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentIndex &lt; array.length;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">element</span> <span class="operator">=</span> array[currentIndex];</span><br><span class="line">        currentIndex++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 使用迭代器遍历数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = <span class="keyword">new</span> <span class="title class_">ArrayIterator</span>&lt;&gt;(array);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例代码中，我们定义了抽象迭代器接口（Iterator），用于表示迭代器对象。我们还定义了具体迭代器实现类（ArrayIterator），用于实现数组迭代器。最后，我们使用迭代器遍历了一个整型数组，并打印出了每个元素的值。</p>
<h3 id="5-观察者模式"><a href="#5-观察者模式" class="headerlink" title="5.观察者模式"></a>5.观察者模式</h3><p><strong>定义</strong></p>
<p>当一个对象被修改时，则会自动通知依赖它的对象。<br>观察者，顾名思义，就是一个监听者，类似监听器的存在，一旦被观察&#x2F;监听的目标发生的情况，就会被监听者发现，这么想来目标发生情况到观察者知道情况，其实是由目标将情况发送到观察者的。<br><strong>应用场景</strong><br>多用于实现订阅功能的场景，例如微博的订阅，当我们订阅了某个人的微博账号，当这个人发布了新的消息，就会通知我们。</p>
<p>下面是一个简单的Java观察者模式示例代码，实现了一个气象站，当气象数据发生改变时，会通知所有的观察者对象：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> <span class="comment">// 抽象主题接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体观察者实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Temperature: &quot;</span> + temperature);</span><br><span class="line">        System.out.println(<span class="string">&quot;Humidity: &quot;</span> + humidity);</span><br><span class="line">        System.out.println(<span class="string">&quot;Pressure: &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 抽象观察者接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 具体观察者实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Temperature: &quot;</span> + temperature);</span><br><span class="line">        System.out.println(<span class="string">&quot;Humidity: &quot;</span> + humidity);</span><br><span class="line">        System.out.println(<span class="string">&quot;Pressure: &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 使用观察者模式实现气象站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeatherStation</span> <span class="variable">weatherStation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherStation</span>();</span><br><span class="line">        <span class="type">Display</span> <span class="variable">display1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>();</span><br><span class="line">        <span class="type">Display</span> <span class="variable">display2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>();</span><br><span class="line">        weatherStation.registerObserver(display1);</span><br><span class="line">        weatherStation.registerObserver(display2);</span><br><span class="line">        weatherStation.setMeasurements(<span class="number">25.0f</span>, <span class="number">60.0f</span>, <span class="number">1013.0f</span>);</span><br><span class="line">        weatherStation.removeObserver(display2);</span><br><span class="line">        weatherStation.setMeasurements(<span class="number">26.0f</span>, <span class="number">65.0f</span>, <span class="number">1012.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行输入结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; 通知所有观察者 &lt;&lt;</span><br><span class="line">------观察者:01-----------</span><br><span class="line">Temperature: 25.0</span><br><span class="line">Humidity: 60.0</span><br><span class="line">Pressure: 1013.0</span><br><span class="line">------观察者:02-----------</span><br><span class="line">Temperature: 25.0</span><br><span class="line">Humidity: 60.0</span><br><span class="line">Pressure: 1013.0</span><br><span class="line">&gt;&gt; 通知所有观察者 &lt;&lt;</span><br><span class="line">------观察者:01-----------</span><br><span class="line">Temperature: 26.0</span><br><span class="line">Humidity: 65.0</span><br><span class="line">Pressure: 1012.0</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例代码中，我们定义了抽象主题接口（Subject）和抽象观察者接口（Observer），用于表示主题和观察者对象。我们还定义了具体主题实现类（WeatherStation）和具体观察者实现类（Display），用于实现气象站和显示器对象。最后，我们使用观察者模式实现了一个气象站，当气象数据发生改变时，会通知所有的观察者对象，并更新显示器的数据。</p>
<p><strong>Java自带观察者模式介绍</strong></p>
<p>Java提供的一种内置的观察者模式实现。它使用了Java中的Observable类和Observer接口来实现观察者模式。</p>
<p>Observable类是一个抽象类，它表示一个可观察的对象，具有添加、删除和通知观察者的方法。当Observable对象的状态发生改变时，会调用它的notifyObservers()方法，通知所有的观察者对象，并更新它们的状态。Observable类还提供了setChanged()方法和clearChanged()方法，用于标记Observable对象的状态是否发生了改变。</p>
<p>Observer接口表示观察者对象，具有更新状态的方法update()。当Observable对象的状态发生改变时，会调用观察者对象的update()方法，传递更新的数据。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherStation</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getHumidity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPressure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体观察者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> WeatherStation) &#123;</span><br><span class="line">            <span class="type">WeatherStation</span> <span class="variable">weatherStation</span> <span class="operator">=</span> (WeatherStation) o;</span><br><span class="line">            <span class="built_in">this</span>.temperature = weatherStation.getTemperature();</span><br><span class="line">            <span class="built_in">this</span>.humidity = weatherStation.getHumidity();</span><br><span class="line">            <span class="built_in">this</span>.pressure = weatherStation.getPressure();</span><br><span class="line">            display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Temperature: &quot;</span> + temperature);</span><br><span class="line">        System.out.println(<span class="string">&quot;Humidity: &quot;</span> + humidity);</span><br><span class="line">        System.out.println(<span class="string">&quot;Pressure: &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用JDK自带观察者模式实现气象站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeatherStation</span> <span class="variable">weatherStation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherStation</span>();</span><br><span class="line">        <span class="type">Display</span> <span class="variable">display1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>();</span><br><span class="line">        <span class="type">Display</span> <span class="variable">display2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>();</span><br><span class="line">        weatherStation.addObserver(display1);</span><br><span class="line">        weatherStation.addObserver(display2);</span><br><span class="line">        weatherStation.setMeasurements(<span class="number">25.0f</span>, <span class="number">60.0f</span>, <span class="number">1013.0f</span>);</span><br><span class="line">        weatherStation.deleteObserver(display2);</span><br><span class="line">        weatherStation.setMeasurements(<span class="number">26.0f</span>, <span class="number">65.0f</span>, <span class="number">1012.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例代码中，我们使用了Observable类和Observer接口来实现气象站和显示器对象。当气象数据发生改变时，Observable对象会调用notifyObservers()方法，通知所有的观察者对象，并更新它们的状态。观察者对象实现Observer接口的update()方法，用于更新自己的状态。</p>
<h3 id="6-中介者模式"><a href="#6-中介者模式" class="headerlink" title="6.中介者模式"></a>6.中介者模式</h3><p><strong>定义</strong><br>是用来降低多个对象和类之间的通信复杂性，这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松合，使代码易于维护<br><strong>应用场景</strong><br>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。</p>
<p>下面是一个简单的Java中介者模式示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mediator接口定义了send()方法，用于处理对象之间的交互。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, Colleague colleague)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Colleague抽象类表示对象，它包含一个Mediator对象，用于处理对象之间的通信。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Colleague</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// ConcreteColleague1和ConcreteColleague2是具体的对象实现类，它们实现了Colleague抽象类中的方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteColleague1</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Colleague1 received message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Colleague1 sends message: &quot;</span> + message);</span><br><span class="line">        mediator.send(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteColleague2</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Colleague2 received message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Colleague2 sends message: &quot;</span> + message);</span><br><span class="line">        mediator.send(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// ConcreteMediator是具体的中介者实现类，它负责协调对象之间的通信。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague1 colleague1;</span><br><span class="line">    <span class="keyword">private</span> ConcreteColleague2 colleague2;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleague1</span><span class="params">(ConcreteColleague1 colleague1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colleague1 = colleague1;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColleague2</span><span class="params">(ConcreteColleague2 colleague2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colleague2 = colleague2;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message, Colleague colleague)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (colleague == colleague1) &#123;</span><br><span class="line">            colleague2.receive(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            colleague1.receive(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediatorPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteMediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class="line">         <span class="type">ConcreteColleague1</span> <span class="variable">colleague1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague1</span>(mediator);</span><br><span class="line">        <span class="type">ConcreteColleague2</span> <span class="variable">colleague2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague2</span>(mediator);</span><br><span class="line">         mediator.setColleague1(colleague1);</span><br><span class="line">        mediator.setColleague2(colleague2);</span><br><span class="line">         colleague1.send(<span class="string">&quot;Hello, Colleague2.&quot;</span>);</span><br><span class="line">        colleague2.send(<span class="string">&quot;Hello, Colleague1.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的代码中，Mediator接口定义了send()方法，用于处理对象之间的交互。Colleague抽象类表示对象，它包含一个Mediator对象，用于处理对象之间的通信。ConcreteColleague1和ConcreteColleague2是具体的对象实现类，它们实现了Colleague抽象类中的方法。ConcreteMediator是具体的中介者实现类，它负责协调对象之间的通信。</p>
<p>在main()方法中，我们创建了一个ConcreteMediator对象和两个ConcreteColleague对象，并调用它们的send()方法进行通信。通过中介者对象进行通信，避免了对象之间的直接耦合。</p>
<h3 id="7-备忘录模式"><a href="#7-备忘录模式" class="headerlink" title="7.备忘录模式"></a>7.备忘录模式</h3><p><strong>定义</strong><br>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。<br><strong>应用场景</strong><br>需要保存和恢复数据的相关状态场景<br>Windows 里的 ctri + z<br>E 中的后退。<br>数据库连接的事务管理就是用的备忘录模式</p>
<p>下面是一个简单的Java备忘录模式示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Originator类表示原始对象，它包含需要保存的状态。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// createMemento()方法创建备忘录对象，并将当前状态保存到备忘录对象中。</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// restore()方法用于从备忘录对象中恢复先前的状态。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restore</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Memento类表示备忘录对象，它包含需要保存的状态。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Caretaker类负责管理备忘录对象，它包含一个Memento对象。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MementoPatternDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line">        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();</span><br><span class="line">         <span class="comment">// 保存原始对象的状态到备忘录对象中</span></span><br><span class="line">        originator.setState(<span class="string">&quot;State 1&quot;</span>);</span><br><span class="line">        caretaker.setMemento(originator.createMemento());</span><br><span class="line">         <span class="comment">// 修改原始对象的状态</span></span><br><span class="line">        originator.setState(<span class="string">&quot;State 2&quot;</span>);</span><br><span class="line">         <span class="comment">// 从备忘录对象中恢复先前的状态</span></span><br><span class="line">        originator.restore(caretaker.getMemento());</span><br><span class="line">         System.out.println(<span class="string">&quot;Current state: &quot;</span> + originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的代码中，Originator类表示原始对象，它包含需要保存的状态。createMemento()方法创建备忘录对象，并将当前状态保存到备忘录对象中。restore()方法用于从备忘录对象中恢复先前的状态。</p>
<p>Memento类表示备忘录对象，它包含需要保存的状态。</p>
<p>Caretaker类负责管理备忘录对象，它包含一个Memento对象。</p>
<p>在main()方法中，我们创建了一个Originator对象和一个Caretaker对象，并调用它们的方法进行状态保存和恢复。通过备忘录模式，我们可以在不破坏封装性的情况下捕获和恢复对象的内部状态。</p>
<h3 id="8-解释器模式"><a href="#8-解释器模式" class="headerlink" title="8.解释器模式"></a>8.解释器模式</h3><p><strong>定义</strong><br>这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL解析、符号处理引擎等.<br><strong>应用场景</strong><br>重复发生的问题可以使用解释器模式<br>例如，多个应用服务器，每天产生大量的日志，需要对日志文件进行分析处理，由于各个服务器的日志格式不同，但是数据要素是相同的，按照解释器的说法就是终结符表达式都是相同的，但是非终结符表达式就需要制定了。在这种情况下，可以通过程序来一劳永逸地解决该问题</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 终结符表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">NumberExpression</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 非终结符表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddExpression</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression left;</span><br><span class="line">    <span class="keyword">private</span> Expression right;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">AddExpression</span><span class="params">(Expression left, Expression right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) + right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVariable</span><span class="params">(String name, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        variables.put(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVariable</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> variables.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 解释器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Interpreter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Expression expression;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Interpreter</span><span class="params">(Expression expression)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.expression = expression;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expression.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 使用解释器执行表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建上下文</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        context.setVariable(<span class="string">&quot;a&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;b&quot;</span>, <span class="number">20</span>);</span><br><span class="line">         <span class="comment">// 创建表达式</span></span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddExpression</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(context.getVariable(<span class="string">&quot;a&quot;</span>)),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NumberExpression</span>(context.getVariable(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">         <span class="comment">// 创建解释器并执行表达式</span></span><br><span class="line">        <span class="type">Interpreter</span> <span class="variable">interpreter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Interpreter</span>(expression);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> interpreter.interpret(context);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例代码中，我们定义了两个终结符表达式（NumberExpression）和一个非终结符表达式（AddExpression），用于表示加法操作。我们还定义了一个上下文（Context），用于存储变量和函数，以及一个解释器（Interpreter），用于执行表达式。最后，我们使用解释器执行了一个简单的加法表达式，并打印出了结果。</p>
<h3 id="9-状态模式"><a href="#9-状态模式" class="headerlink" title="9.状态模式"></a>9.状态模式</h3><p><strong>定义</strong><br>我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类<br><strong>应用场景</strong><br>行为随状态改变而改变的场景这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行 为结果也会不同，在这种情况下需要考虑使用状态模式QQ的不同状态可以用状态模式来处理，包括离线，登录中，在线和忙碌</p>
<p>下面是一个使用Java状态模式实现的示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 具体状态类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteState1</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteState1 is handling.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 具体状态类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteState2</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteState2 is handling.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 环境类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        state.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 使用状态模式实现的客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        <span class="type">State</span> <span class="variable">state1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteState1</span>();</span><br><span class="line">        <span class="type">State</span> <span class="variable">state2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteState2</span>();</span><br><span class="line">        context.setState(state1);</span><br><span class="line">        context.request();</span><br><span class="line">        context.setState(state2);</span><br><span class="line">        context.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例代码中，我们定义了一个状态接口State和两个具体状态类ConcreteState1和ConcreteState2。我们还定义了一个环境类Context，它包含一个状态对象，并定义了一个请求方法request()，用于调用当前状态对象的handle()方法。在客户端代码中，我们创建了一个Context对象，并设置它的状态为ConcreteState1，然后调用request()方法，输出”ConcreteState1 is handling.“。接着，我们将Context的状态设置为ConcreteState2，并再次调用request()方法，输出”ConcreteState2 is handling.”。</p>
<p>通过使用状态模式，我们可以将状态和行为分离，使得对象的行为可以随着状态的改变而改变，从而实现更加灵活的设计。</p>
<h3 id="10-策略模式"><a href="#10-策略模式" class="headerlink" title="10.策略模式"></a>10.策略模式</h3><p><strong>定义</strong><br>利用面向对象的多态特点，引用的是抽象父类，当实际调用的时候是该对象的实体子类，从而调用不同的逻辑<br><strong>应用场景</strong><br>诸葛亮的锦囊妙计，每一个锦囊就是一个策略旅行的出游方式，选择骑自行车.坐汽车，每一种旅行方式都是一个策略</p>
<p>下面的例子展示了如何使用策略模式来实现一个简单的支付系统。我们定义了一个接口 PaymentStrategy ，并创建了多个实现该接口的类，每个类代表一种不同的支付方式。客户端可以根据需要选择使用哪种支付方式。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">CreditCardPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardNumber;</span><br><span class="line">    <span class="keyword">private</span> String cvv;</span><br><span class="line">    <span class="keyword">private</span> String expiryDate;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">CreditCardPayment</span><span class="params">(String cardNumber, String cvv, String expiryDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardNumber = cardNumber;</span><br><span class="line">        <span class="built_in">this</span>.cvv = cvv;</span><br><span class="line">        <span class="built_in">this</span>.expiryDate = expiryDate;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Paying &quot;</span> + amount + <span class="string">&quot; using credit card.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">PayPalPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">PayPalPayment</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Paying &quot;</span> + amount + <span class="string">&quot; using PayPal.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">CashPayment</span> <span class="keyword">implements</span> <span class="title class_">PaymentStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Paying &quot;</span> + amount + <span class="string">&quot; using cash.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">PaymentProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentStrategy strategy;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">PaymentProcessor</span><span class="params">(PaymentStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(PaymentStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        strategy.pay(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PaymentProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentProcessor</span>(<span class="keyword">new</span> <span class="title class_">CreditCardPayment</span>(<span class="string">&quot;1234 5678 9012 3456&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;12/23&quot;</span>));</span><br><span class="line">        processor.processPayment(<span class="number">100.0</span>);</span><br><span class="line">         processor.setStrategy(<span class="keyword">new</span> <span class="title class_">PayPalPayment</span>(<span class="string">&quot;example@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        processor.processPayment(<span class="number">50.0</span>);</span><br><span class="line">         processor.setStrategy(<span class="keyword">new</span> <span class="title class_">CashPayment</span>());</span><br><span class="line">        processor.processPayment(<span class="number">25.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Paying 100.0 using credit card.</span><br><span class="line">Paying 50.0 using PayPal.</span><br><span class="line">Paying 25.0 using cash.</span><br></pre></td></tr></table></figure></div>

<h3 id="11-责任链模式"><a href="#11-责任链模式" class="headerlink" title="11.责任链模式"></a>11.责任链模式</h3><p><strong>定义</strong><br>责任链模式:在这种模式中，通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推<br><strong>应用场景</strong><br>多个对象可以处理同一个请求，但具体由哪个对象处理则在运行时动态决定。JAVA WEB 中 Apache Tomcat 对 Encoding 的处理Struts2的拦截器Servlet 的 Filter实现</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    Handler <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建抽象处理器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">getNextHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建具体的处理器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType().equals(<span class="string">&quot;Type1&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ConcreteHandler1 handles request &quot;</span> + request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getNextHandler().handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType().equals(<span class="string">&quot;Type2&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ConcreteHandler2 handles request &quot;</span> + request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getNextHandler().handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler3</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getType().equals(<span class="string">&quot;Type3&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ConcreteHandler3 handles request &quot;</span> + request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getNextHandler().handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Request</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Request [type=&quot;</span> + type + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler1</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler2</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler3</span>();</span><br><span class="line">        handler1.setNextHandler(handler2)</span><br><span class="line">                .setNextHandler(handler3);</span><br><span class="line">        handler1.handleRequest(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;Type1&quot;</span>));</span><br><span class="line">        handler1.handleRequest(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;Type2&quot;</span>));</span><br><span class="line">        handler1.handleRequest(<span class="keyword">new</span> <span class="title class_">Request</span>(<span class="string">&quot;Type3&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输入结果：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConcreteHandler1 handles request Request [type=Type1]</span><br><span class="line">ConcreteHandler2 handles request Request [type=Type2]</span><br><span class="line">ConcreteHandler3 handles request Request [type=Type3]</span><br></pre></td></tr></table></figure></div>

<p>以上代码演示了如何创建一个处理器链，并将请求沿着链传递，直到有一个处理程序处理它为止。在这个例子中，ConcreteHandler1、ConcreteHandler2和ConcreteHandler3都是具体的处理器类，它们继承自AbstractHandler类，并实现handleRequest方法。客户端代码创建了一个处理器链，并将请求发送到链的第一个处理器。当请求到达处理器时，它会检查请求类型是否与处理器可以处理的类型匹配。如果是，处理器将处理请求。否则，它将请求传递给链中的下一个处理器，直到有一个处理程序处理它为止。</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>Java判断日期是不是当天、本周、本月、本季度、本年</title>
    <url>/2022/10/07/Java%E5%88%A4%E6%96%AD%E6%97%A5%E6%9C%9F%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BD%93%E5%A4%A9%E3%80%81%E6%9C%AC%E5%91%A8%E3%80%81%E6%9C%AC%E6%9C%88%E3%80%81%E6%9C%AC%E5%AD%A3%E5%BA%A6%E3%80%81%E6%9C%AC%E5%B9%B4/</url>
    <content><![CDATA[<p>这是一个java工具类，用于大多数需要判断日期是不是当天、本周、本月、本季度、本年，以更好的进行下一步判断，<br>那么如何去写代码吗？请直接看下面：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateStatusUtil</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断选择的日期是否是今天</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isToday</span><span class="params">(Date time)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isThisTime(time, <span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//判断选择的日期是否是本周</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isThisWeek</span><span class="params">(Date time)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentWeek</span> <span class="operator">=</span> calendar.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">        calendar.setTime(time);</span><br><span class="line">        <span class="type">int</span> <span class="variable">paramWeek</span> <span class="operator">=</span> calendar.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">        <span class="keyword">if</span> (paramWeek == currentWeek) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断选择的日期是否是本月</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isThisMonth</span><span class="params">(Date time)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isThisTime(time, <span class="string">&quot;yyyy-MM&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断选择的日期是否是本年</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isThisYear</span><span class="params">(Date time)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isThisTime(time, <span class="string">&quot;yyyy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//判断选择的日期是否是本季度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isThisQuarter</span><span class="params">(Date time)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">QuarterStart</span> <span class="operator">=</span> getCurrentQuarterStartTime();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">QuarterEnd</span> <span class="operator">=</span> getCurrentQuarterEndTime();</span><br><span class="line">        <span class="keyword">return</span> time.after(QuarterStart) &amp;&amp; time.before(QuarterEnd);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isThisTime</span><span class="params">(Date time, String pattern)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(pattern);</span><br><span class="line">        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> sdf.format(time);<span class="comment">//参数时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">now</span> <span class="operator">=</span> sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>());<span class="comment">//当前时间</span></span><br><span class="line">        <span class="keyword">if</span> (param.equals(now)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得季度开始时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getCurrentQuarterStartTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentMonth</span> <span class="operator">=</span> c.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">longSdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">shortSdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentMonth &gt;= <span class="number">1</span> &amp;&amp; currentMonth &lt;= <span class="number">3</span>)</span><br><span class="line">                c.set(Calendar.MONTH, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentMonth &gt;= <span class="number">4</span> &amp;&amp; currentMonth &lt;= <span class="number">6</span>)</span><br><span class="line">                c.set(Calendar.MONTH, <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentMonth &gt;= <span class="number">7</span> &amp;&amp; currentMonth &lt;= <span class="number">9</span>)</span><br><span class="line">                c.set(Calendar.MONTH, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentMonth &gt;= <span class="number">10</span> &amp;&amp; currentMonth &lt;= <span class="number">12</span>)</span><br><span class="line">                c.set(Calendar.MONTH, <span class="number">9</span>);</span><br><span class="line">            c.set(Calendar.DATE, <span class="number">1</span>);</span><br><span class="line">            now = longSdf.parse(shortSdf.format(c.getTime()) + <span class="string">&quot; 00:00:00&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前季度的结束时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">getCurrentQuarterEndTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        cal.setTime(getCurrentQuarterStartTime());</span><br><span class="line">        cal.add(Calendar.MONTH, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> cal.getTime();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;当天：&quot;</span> + DateStatusUtil</span><br><span class="line">					.isToday(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(<span class="string">&quot;2021-07-15 08:23:21&quot;</span>)));</span><br><span class="line">			System.out.println(<span class="string">&quot;本周：&quot;</span> + DateStatusUtil</span><br><span class="line">					.isThisWeek(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(<span class="string">&quot;2021-07-25 08:23:21&quot;</span>)));</span><br><span class="line">			System.out.println(<span class="string">&quot;本月：&quot;</span> + DateStatusUtil</span><br><span class="line">					.isThisMonth(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(<span class="string">&quot;2021-07-15 08:23:21&quot;</span>)));</span><br><span class="line">			System.out.println(<span class="string">&quot;本年：&quot;</span> + DateStatusUtil</span><br><span class="line">					.isThisYear(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(<span class="string">&quot;2022-07-15 08:23:21&quot;</span>)));</span><br><span class="line">			System.out.println(<span class="string">&quot;本季度：&quot;</span> + DateStatusUtil</span><br><span class="line">					.isThisQuarter(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(<span class="string">&quot;2021-07-15 08:23:21&quot;</span>)));</span><br><span class="line"> </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception pe) &#123;</span><br><span class="line">			System.out.println(pe.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行后输出：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">当天：<span class="literal">true</span></span><br><span class="line">本周：<span class="literal">false</span></span><br><span class="line">本月：<span class="literal">true</span></span><br><span class="line">本年：<span class="literal">false</span></span><br><span class="line">本季度：<span class="literal">true</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java获取IP属地</title>
    <url>/2022/09/04/Java%E8%8E%B7%E5%8F%96IP%E5%B1%9E%E5%9C%B0/</url>
    <content><![CDATA[<p>此篇为ip2region xdb java 查询客户端实现，教你如何使用java查询ip归属地。</p>
<p>使用方式</p>
<p>maven 仓库：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lionsoul<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ip2region<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>完全基于文件的查询</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.lionsoul.ip2region.xdb.Searcher;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearcherTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">// 1、创建 searcher 对象</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">dbPath</span> <span class="operator">=</span> <span class="string">&quot;ip2region.xdb file path&quot;</span>;</span><br><span class="line">       <span class="type">Searcher</span> <span class="variable">searcher</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           searcher = Searcher.newWithFileOnly(dbPath);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;创建searcherTest失败 `%s`: %s\n&quot;</span>, dbPath, e);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、查询</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;1.2.3.4&quot;</span>;</span><br><span class="line">           <span class="type">long</span> <span class="variable">sTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">           <span class="type">String</span> <span class="variable">region</span> <span class="operator">=</span> searcher.search(ip);</span><br><span class="line">           <span class="type">long</span> <span class="variable">cost</span> <span class="operator">=</span> TimeUnit.NANOSECONDS.toMicros((<span class="type">long</span>) (System.nanoTime() - sTime));</span><br><span class="line">           System.out.printf(<span class="string">&quot;&#123;region: %s, ioCount: %d, took: %d μs&#125;\n&quot;</span>, region, searcher.getIOCount(), cost);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;查询失败(%s): %s\n&quot;</span>, ip, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、关闭资源</span></span><br><span class="line">       searcher.close();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 备注：并发使用，每个线程需要创建一个独立的 searcher 对象单独使用。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>缓存 VectorIndex索引</p>
<p>我们可以提前从 xdb文件中加载出来VectorIndex数据，然后全局缓存，每次创建 Searcher 对象的时候使用全局的 VectorIndex 缓存可以减少一次固定的 IO 操作，从而加速查询，减少 IO 压力。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.lionsoul.ip2region.xdb.Searcher;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearcherTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">dbPath</span> <span class="operator">=</span> <span class="string">&quot;ip2region.xdb file path&quot;</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1、从 dbPath 中预先加载 VectorIndex 缓存，并且把这个得到的数据作为全局变量，后续反复使用。</span></span><br><span class="line">       <span class="type">byte</span>[] vIndex;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           vIndex = Searcher.loadVectorIndexFromFile(dbPath);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;无法加载矢量索引 `%s`: %s\n&quot;</span>, dbPath, e);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、使用全局的 vIndex 创建带 VectorIndex 缓存的查询对象。</span></span><br><span class="line">       Searcher searcher;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           searcher = Searcher.newWithVectorIndex(dbPath, vIndex);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;创建 vectorIndex 缓存搜索器失败 `%s`: %s\n&quot;</span>, dbPath, e);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、查询</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;1.2.3.4&quot;</span>;</span><br><span class="line">           <span class="type">long</span> <span class="variable">sTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">           <span class="type">String</span> <span class="variable">region</span> <span class="operator">=</span> searcher.search(ip);</span><br><span class="line">           <span class="type">long</span> <span class="variable">cost</span> <span class="operator">=</span> TimeUnit.NANOSECONDS.toMicros((<span class="type">long</span>) (System.nanoTime() - sTime));</span><br><span class="line">           System.out.printf(<span class="string">&quot;&#123;region: %s, ioCount: %d, took: %d μs&#125;\n&quot;</span>, region, searcher.getIOCount(), cost);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;查询失败(%s): %s\n&quot;</span>, ip, e);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 4、关闭资源</span></span><br><span class="line">       searcher.close();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 备注：每个线程需要单独创建一个独立的 Searcher 对象，但是都共享全局的制度 vIndex 缓存。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>缓存整个 xdb数据</p>
<p>我们也可以预先加载整个 ip2region.xdb 的数据到内存，然后基于这个数据创建查询对象来实现完全基于文件的查询，类似之前的 memory search。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.lionsoul.ip2region.xdb.Searcher;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearcherTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">dbPath</span> <span class="operator">=</span> <span class="string">&quot;ip2region.xdb file path&quot;</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1、从 dbPath 加载整个 xdb 到内存。</span></span><br><span class="line">       <span class="type">byte</span>[] cBuff;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           cBuff = Searcher.loadContentFromFile(dbPath);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;无法加载内容 `%s`: %s\n&quot;</span>, dbPath, e);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、使用上述的 cBuff 创建一个完全基于内存的查询对象。</span></span><br><span class="line">       Searcher searcher;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           searcher = Searcher.newWithBuffer(cBuff);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;无法创建内容缓存搜索器: %s\n&quot;</span>, e);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、查询</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="string">&quot;1.2.3.4&quot;</span>;</span><br><span class="line">           <span class="type">long</span> <span class="variable">sTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">           <span class="type">String</span> <span class="variable">region</span> <span class="operator">=</span> searcher.search(ip);</span><br><span class="line">           <span class="type">long</span> <span class="variable">cost</span> <span class="operator">=</span> TimeUnit.NANOSECONDS.toMicros((<span class="type">long</span>) (System.nanoTime() - sTime));</span><br><span class="line">           System.out.printf(<span class="string">&quot;&#123;region: %s, ioCount: %d, took: %d μs&#125;\n&quot;</span>, region, searcher.getIOCount(), cost);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;查询失败(%s): %s\n&quot;</span>, ip, e);</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 4、关闭资源 - 该 searcher 对象可以安全用于并发，等整个服务关闭的时候再关闭 searcher</span></span><br><span class="line">       <span class="comment">// searcher.close();</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 备注：并发使用，用整个 xdb 数据缓存创建的查询对象可以安全的用于并发，也就是你可以把这个 searcher 对象做成全局对象去跨线程访问。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译测试程序</p>
<p>通过 maven 来编译测试程序。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> 到 java binding 的根目录</span></span><br><span class="line">cd binding/java/</span><br><span class="line">mvn compile package</span><br></pre></td></tr></table></figure></div>

<p>然后会在当前目录的 target 目录下得到一个 ip2region-{version}.jar 的打包文件。</p>
<p>查询测试</p>
<p>可以通过 java -jar ip2region-{version}.jar search命令来测试查询：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ java git:(v2.0_xdb) ✗ java -jar target/ip2region-2.6.0.jar search</span><br><span class="line">java -jar ip2region-&#123;version&#125;.jar search [command options]</span><br><span class="line">options:</span><br><span class="line">--db string             ip2region binary xdb file path</span><br><span class="line">--cache-policy string   cache policy: file/vectorIndex/content</span><br></pre></td></tr></table></figure></div>

<p>例如：使用默认的 data&#x2F;ip2region.xdb 文件进行查询测试：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ java git:(v2.0_xdb) ✗ java -jar target/ip2region-2.6.0.jar search --db=../../data/ip2region.xdb</span><br><span class="line">ip2region xdb searcher test program, cachePolicy: vectorIndex</span><br><span class="line">type &#x27;quit&#x27; to exit</span><br><span class="line"><span class="meta prompt_">ip2region&gt;</span><span class="language-bash">&gt; 1.2.3.4</span></span><br><span class="line">&#123;region: 美国|0|华盛顿|0|谷歌, ioCount: 7, took: 82 μs&#125;</span><br><span class="line"><span class="meta prompt_">ip2region&gt;</span><span class="language-bash">&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>输入 ip 即可进行查询测试，也可以分别设置 cache-policy为 file&#x2F;vectorIndex&#x2F;content 来测试三种不同缓存实现的查询效果。</p>
<p>bench 测试</p>
<p>可以通过 java -jar ip2region-{version}.jar bench命令来进行 bench 测试，一方面确保 <code>xdb</code> 文件没有错误，一方面可以评估查询性能：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ java git:(v2.0_xdb) ✗ java -jar target/ip2region-2.6.0.jar bench</span><br><span class="line">java -jar ip2region-&#123;version&#125;.jar bench [command options]</span><br><span class="line">options:</span><br><span class="line">--db string             ip2region binary xdb file path</span><br><span class="line">--src string             source ip text file path</span><br><span class="line">--cache-policy string   cache policy: file/vectorIndex/content</span><br></pre></td></tr></table></figure></div>

<p>例如：通过默认的 data&#x2F;ip2region.xdb 和 data&#x2F;ip.merge.txt 文件进行 bench 测试：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">➜ java git:(v2.0_xdb) ✗ java -jar target/ip2region-2.6.0.jar bench --db=../../data/ip2region.xdb --src=../../data/ip.merge.txt</span><br><span class="line">Bench finished, &#123;cachePolicy: vectorIndex, total: 3417955, took: 8s, cost: 2 μs/op&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以通过分别设置 cache-policy为 file&#x2F;vectorIndex&#x2F;content 来测试三种不同缓存实现的效果。@Note: 注意 bench 使用的 src 文件要是生成对应 xdb 文件相同的源文件。</p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java通过FTP实现上传下载</title>
    <url>/2022/09/27/Java%E9%80%9A%E8%BF%87FTP%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>今天是2022年9月27日，突发灵感再java中如何通过ftp实现上传以及下载，那么此文Java通过FTP实现上传下载为大家讲述一整套流程。</p>
<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a><strong>添加依赖</strong></h2><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Sftp工具 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jcraft<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.54<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>


<h2 id="SFTP工具类"><a href="#SFTP工具类" class="headerlink" title="SFTP工具类"></a><strong>SFTP工具类</strong></h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.jcraft.jsch.*;</span><br><span class="line"><span class="keyword">import</span> com.jcraft.jsch.ChannelSftp.LsEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SftpClientUtil</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(SftpClientUtil.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Sftp */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">ChannelSftp</span> <span class="variable">sftp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">/** 主机 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">/** 端口 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/** 用户名 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">/** 密码 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造函数</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> host</span></span><br><span class="line"><span class="comment">   *            主机</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">   *            端口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   *            用户名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   *            密码</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SftpClientUtil</span><span class="params">(String host, <span class="type">int</span> port, String username, String password)</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.host = host;</span><br><span class="line">    <span class="built_in">this</span>.port = port;</span><br><span class="line">    <span class="built_in">this</span>.username = username;</span><br><span class="line">    <span class="built_in">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 连接sftp服务器</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">JSch</span> <span class="variable">jsch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSch</span>();</span><br><span class="line">    <span class="type">Session</span> <span class="variable">sshSession</span> <span class="operator">=</span> jsch.getSession(<span class="built_in">this</span>.username, <span class="built_in">this</span>.host, <span class="built_in">this</span>.port);</span><br><span class="line">    logger.debug(SftpClientUtil.class + <span class="string">&quot;Session created.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sshSession.setPassword(password);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">sshConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    sshConfig.put(<span class="string">&quot;StrictHostKeyChecking&quot;</span>, <span class="string">&quot;no&quot;</span>);</span><br><span class="line">    sshSession.setConfig(sshConfig);</span><br><span class="line">    sshSession.connect(<span class="number">20000</span>);</span><br><span class="line">    logger.debug(SftpClientUtil.class + <span class="string">&quot; Session connected.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    logger.debug(SftpClientUtil.class + <span class="string">&quot; Opening Channel.&quot;</span>);</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> sshSession.openChannel(<span class="string">&quot;sftp&quot;</span>);</span><br><span class="line">    channel.connect();</span><br><span class="line">    <span class="built_in">this</span>.sftp = (ChannelSftp) channel;</span><br><span class="line">    logger.debug(SftpClientUtil.class + <span class="string">&quot; Connected to &quot;</span> + <span class="built_in">this</span>.host + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Disconnect with server</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sftp != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.sftp.isConnected())</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">this</span>.sftp.disconnect();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sftp.isClosed())</span><br><span class="line">      &#123;</span><br><span class="line">        logger.debug(SftpClientUtil.class + <span class="string">&quot; sftp is closed already&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下载单个文件</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">   *            下载目录</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> downloadFile</span></span><br><span class="line"><span class="comment">   *            下载的文件</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> saveDirectory</span></span><br><span class="line"><span class="comment">   *            存在本地的路径</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String directory, String downloadFile, String saveDirectory)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">pathFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveDirectory);</span><br><span class="line">    <span class="keyword">if</span> (!pathFile.exists())</span><br><span class="line">    &#123;</span><br><span class="line">      pathFile.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">saveFile</span> <span class="operator">=</span> saveDirectory + <span class="string">&quot;//&quot;</span> + downloadFile;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.sftp.cd(directory);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(saveFile);</span><br><span class="line">    <span class="built_in">this</span>.sftp.get(downloadFile, <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下载目录下全部文件</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">   *            下载目录</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> saveDirectory</span></span><br><span class="line"><span class="comment">   *            存在本地的路径</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downloadByDirectory</span><span class="params">(String directory, String saveDirectory)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">downloadFile</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    List&lt;String&gt; downloadFileList = <span class="built_in">this</span>.listFiles(directory);</span><br><span class="line">    Iterator&lt;String&gt; it = downloadFileList.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">      downloadFile = it.next().toString();</span><br><span class="line">      <span class="keyword">if</span> (downloadFile.toString().indexOf(<span class="string">&quot;.&quot;</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.download(directory, downloadFile, saveDirectory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 新建子目录</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dst 远程服务器路径</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mkdir</span><span class="params">(String dst, String subDir)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">this</span>.sftp.cd(dst);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.sftp.ls(subDir).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SftpException se) &#123;</span><br><span class="line">      logger.error(se.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.sftp.mkdir(subDir);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 上传单个文件</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> src 本地文件</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dst 远程服务器路径</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upload</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">this</span>.sftp.put(src, dst);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 列出目录下的文件</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">   *            要列出的目录</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> list 文件名列表</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">listFiles</span><span class="params">(String directory)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    Vector fileList;</span><br><span class="line">    List&lt;String&gt; fileNameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    fileList = <span class="built_in">this</span>.sftp.ls(directory);</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> fileList.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span>((LsEntry) it.next()).getFilename();</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;.&quot;</span>.equals(fileName) || <span class="string">&quot;..&quot;</span>.equals(fileName))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      fileNameList.add(fileName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fileNameList;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> ChannelSftp <span class="title function_">getSftp</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> sftp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSftp</span><span class="params">(ChannelSftp sftp)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">this</span>.sftp = sftp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="SFTP测试类"><a href="#SFTP测试类" class="headerlink" title="SFTP测试类"></a><strong>SFTP测试类</strong></h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;192.xx.xx.xxx&quot;</span>;<span class="comment">// 主机地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">port</span> <span class="operator">=</span> <span class="string">&quot;22&quot;</span>;<span class="comment">// 主机端口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;xxxx&quot;</span>;<span class="comment">// 服务器用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;xxxxx&quot;</span>;<span class="comment">// 服务器密码</span></span><br><span class="line">        <span class="type">SftpClientUtil</span> <span class="variable">sftpClientUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SftpClientUtil</span>(host, Integer.parseInt(port), username, password);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;开始连接sftp服务器&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sftpClientUtil.connect();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;开始连接sftp服务器报错:&#123;&#125;&quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 文件所在本地路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">srcUrl</span> <span class="operator">=</span> <span class="string">&quot;/Users/zhuangjy/Desktop/&quot;</span>;</span><br><span class="line">            <span class="comment">// 上传到服务器路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">dstUrl</span> <span class="operator">=</span> <span class="string">&quot;/usr/local/test&quot;</span> + File.separator;</span><br><span class="line">            <span class="comment">// SFTP 创建路径</span></span><br><span class="line">            sftpClientUtil.mkdir(<span class="string">&quot;/usr/local/&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="comment">// 上传文件</span></span><br><span class="line">            sftpClientUtil.upload(<span class="string">&quot;/Users/zhuangjy/Desktop/test.txt&quot;</span>, dstUrl + <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 下载文件</span></span><br><span class="line">            sftpClientUtil.download(<span class="string">&quot;/usr/local/test/&quot;</span>, <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;/Users/zhuangjy/Desktop/&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;下载文件出错&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;  <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sftpClientUtil.disconnect();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;获取文件：&quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬取多个网页</title>
    <url>/2022/09/22/Python%E7%88%AC%E5%8F%96%E5%A4%9A%E4%B8%AA%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p>最近学到了一个新鲜玩意，Python网页爬取数据脚本，今天我们就来试一试，python爬取数据到底有多方便。</p>
<p>下面直接放源代码：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.now())</span><br><span class="line"><span class="comment"># 文档路径</span></span><br><span class="line">filedir = <span class="string">&quot;d:\\tsldrb_pic\\&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(filedir):</span><br><span class="line">    os.makedirs(filedir)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;d:\\urls.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">urls = f.readlines()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    <span class="built_in">print</span>(url.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line">    driver.maximize_window()</span><br><span class="line">    driver.get(url)</span><br><span class="line">    data_content = request.urlopen(url.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    content_text = data_content.read().decode()</span><br><span class="line">    result_title_time = re.search(<span class="string">&#x27;(?&lt;=content/).*(?=/content)&#x27;</span>, url.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>))  <span class="comment"># 匹配content/和/content间时间</span></span><br><span class="line">    result_title = re.search(<span class="string">&#x27;(?&lt;=&quot;&gt;).*(?=&lt;/h2)&#x27;</span>, content_text)  <span class="comment"># 匹配&quot;&gt;和&lt;/h2间的标题</span></span><br><span class="line">    result_title_time.group().replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    pic_name = result_title_time.group().replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + result_title.group().replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;.png&#x27;</span></span><br><span class="line">    driver.get_screenshot_as_file(filedir + pic_name)</span><br><span class="line">    driver.close()</span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.now())</span><br></pre></td></tr></table></figure></div>

<p>使用教程：</p>
<p>打开此电脑，随便到哪个目录新创一个txt文件，例如我这里使用的是E盘：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Python-Script-Img/img1.jpg"
                     
                >

<p>创建完之后在里面输入多个网址，并用“，”隔开：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Python-Script-Img/img2.jpg"
                     
                >

<p>另外下载pycharm，复制代码即可完成爬取txt文档里的多个网页数据。</p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 11g简介</title>
    <url>/2022/09/06/Oracle-11g%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>此篇主要讲述了Oralce的简单介绍，例如Oracle的起源，Oracle有哪些特点，以及Oracle应用系统结构，另外也介绍了数据库的一些资料。</p>
<p>数据库定义：</p>
<p>什么是数据库？</p>
<p>数据库是指长期储存在计算机内，<strong>有组织的</strong>、<strong>可共享的大量</strong>数据集合。数据库中的数据按一定的数据模型组织、描述和存储，具有<strong>较小的冗余度</strong>、<strong>较高的数据独立性和易扩展性</strong>，并可为各种用户共享。</p>
<p>数据库发展史</p>
<p>数据库发展简史：</p>
<p>在应用的驱动下，在计算机硬件、软件发展的基础上，数据管理技术经历的下面几个阶段：</p>
<p>1.人工管理阶段</p>
<p>2.文件系统阶段</p>
<p>3.电子表格阶段</p>
<p>4.数据库系统阶段</p>
<p>什么是数据库系统</p>
<ul>
<li><p>数据库系统（Database System，简称DBS）是指在计算机系统中引入数据库后的系统构成</p>
</li>
<li><p>在不引起混淆的情况下常常把数据库系统简称为数据库</p>
</li>
</ul>
<p>数据库系统的构成</p>
<ul>
<li>由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员和用户构成</li>
</ul>
<h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p>E-R图也称实体-联系图（Entity Relationship Diagram），提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。</p>
<p>概念模型和数据模型</p>
<p>数据库设计模型分成两个不同的层次：</p>
<p>1.概念模型</p>
<p>也称为信息模型，即按照用户的观点来对数据和信息建模</p>
<p>2.数据模型</p>
<p>按计算机系统的观点对数据建模，常见的数据模型包括网状模型、层次模型、关系模型等。</p>
<p>现实世界中的实体是怎么进入数据库的？</p>
<p>客观对象的抽象过程——两步抽象：</p>
<p>1.将现实世界中的客观对象抽象为概念模型</p>
<p>2.把概念模型转换为某一DBMS支持的数据模型</p>
<h3 id="Oracle-11g数据库简介"><a href="#Oracle-11g数据库简介" class="headerlink" title="Oracle 11g数据库简介"></a>Oracle 11g数据库简介</h3><ul>
<li>Oracle数据库是目前最流行的大型数据库平台之一，是一种极具前景的大型数据库。</li>
<li>Oracle 支持包括32位Windows、64位Windows和Linux等多种操作系统，拥有广泛的用户和大量的应用。</li>
</ul>
<p><strong>主流数据库介绍</strong></p>
<ul>
<li><p>美国Oracle公司：Oracle（甲骨文）</p>
</li>
<li><p>微软：MS sql server</p>
</li>
<li><p>IBM公司：DB2,informix</p>
</li>
<li><p>美国sybase公司：mysql</p>
</li>
</ul>
<p><strong>数据库规模</strong></p>
<p>数据库有<strong>小型数据库、中型数据库、大型数据库</strong></p>
<p>  <strong>小型数据库：</strong>access,foxbase</p>
<p>  <strong>中型数据库：</strong>SQL server, mysql,informix</p>
<p>  <strong>大型数据库：</strong>oracle, Sybase,db2</p>
<p>三个方面考虑数据库：</p>
<ul>
<li>项目规模</li>
<li>成本</li>
<li>安全</li>
</ul>
<p><strong>Oracle</strong>名字：神喻，代神说话的人，甲骨文。暗示公司预作霸主的决心</p>
<p><strong>甲骨文股份有限公司（</strong>Oracle）是全球大型数据库软件公司总部位于美国加州的红木滩，现任执行董事长为公司创办人<strong>劳伦斯.埃里森</strong></p>
<p>2009年4月，甲骨文宣布成功收购SUN全部股权，这一爆炸性新闻表明一个信号：甲骨文从单一的、纯软件厂商走向既有硬件（全球高端服务器系统、存储系统的厂商）、也有软件，全球唯一能和IBM全面抗衡的公司。</p>
<h3 id="Oracle数据库特点"><a href="#Oracle数据库特点" class="headerlink" title="Oracle数据库特点"></a>Oracle数据库特点</h3><ul>
<li><p><strong>支持多用户、大事务量的事务处理</strong></p>
</li>
<li><p><strong>提供标准操作接口</strong></p>
</li>
<li><p><strong>实施安全性控制和完整性控制</strong></p>
</li>
<li><p><strong>支持分布式数据处理</strong></p>
</li>
<li><p><strong>具有可移植性、可兼容性和可连接性</strong></p>
</li>
<li><p><strong>运行速度快</strong></p>
</li>
<li><p><strong>稳定性，目前数据库中稳定性最好的</strong></p>
</li>
<li><p><strong>支持类型多，支持大量多媒体数据类型</strong></p>
</li>
</ul>
<h3 id="Oracle数据库应用系统结构"><a href="#Oracle数据库应用系统结构" class="headerlink" title="Oracle数据库应用系统结构"></a>Oracle数据库应用系统结构</h3><ul>
<li><p><strong>客户-服务器系统（C&#x2F;S）</strong></p>
</li>
<li><p><strong>浏览器-服务器系统（B&#x2F;S）</strong></p>
</li>
<li><p><strong>分布式数据库系统</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty初识</title>
    <url>/2022/10/04/Netty%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<p>前言：Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端&#x2F;服务器框架。<br>它活跃和成长于用户社区，像大型公司 Facebook 和 Instagram 以及流行 开源项目如 Infinispan, HornetQ, Vert.x, Apache Cassandra 和 Elasticsearch 等，都利用其强大的对于网络抽象的核心代码。</p>
<h1 id="Netty入门教程"><a href="#Netty入门教程" class="headerlink" title="Netty入门教程"></a>Netty入门教程</h1><h2 id="一、认识Netty"><a href="#一、认识Netty" class="headerlink" title="一、认识Netty"></a>一、认识Netty</h2><h3 id="1-什么是Netty？"><a href="#1-什么是Netty？" class="headerlink" title="1.什么是Netty？"></a>1.什么是Netty？</h3><p>Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端&#x2F;服务器框架。<br> Netty 是一个广泛使用的 Java 网络编程框架（Netty 在 2011 年获得了Duke’s Choice Award，见<a class="link"   href="https://links.jianshu.com/go?to=https://www.java.net/dukeschoice/2011" >https://www.java.net/dukeschoice/2011 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）。它活跃和成长于用户社区，像大型公司 Facebook 和 Instagram 以及流行 开源项目如 Infinispan, HornetQ, Vert.x, Apache Cassandra 和 Elasticsearch 等，都利用其强大的对于网络抽象的核心代码。</p>
<h3 id="2-Netty和Tomcat有什么区别？"><a href="#2-Netty和Tomcat有什么区别？" class="headerlink" title="2.Netty和Tomcat有什么区别？"></a>2.Netty和Tomcat有什么区别？</h3><p>Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为Netty能够通过codec自己来编码&#x2F;解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。</p>
<h3 id="3-Netty三大优点："><a href="#3-Netty三大优点：" class="headerlink" title="3.Netty三大优点："></a>3.Netty三大优点：</h3><p>1.并发高</p>
<p>2.传输快</p>
<p>3.封装好</p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot+thymeleaf项目——短视频上传</title>
    <url>/2022/09/14/SpringBoot+thymeleaf%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E7%9F%AD%E8%A7%86%E9%A2%91%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>关于我之前做过的SpringBoot小项目的一个功能：短视频上传<br>算是大学里做的一个入门项目了，项目基于SpringBoot+thymeleaf</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/UploadVideo-Note-Img/upload-video.jpg"
                     
                >

<h3 id="Pojo层："><a href="#Pojo层：" class="headerlink" title="Pojo层："></a>Pojo层：</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sporadic.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Video</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> videoId;<span class="comment">//视频标题</span></span><br><span class="line">  <span class="keyword">private</span> String videoTitle;<span class="comment">//视频标题</span></span><br><span class="line">  <span class="keyword">private</span> String videoDescription;<span class="comment">//视频简述</span></span><br><span class="line">  <span class="keyword">private</span> String videoType;<span class="comment">//视频类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> checkNumber;<span class="comment">//视频浏览量</span></span><br><span class="line">  <span class="keyword">private</span> String authorPicture;<span class="comment">//作者头像</span></span><br><span class="line">  <span class="keyword">private</span> String videoAuthor;<span class="comment">//视频作者</span></span><br><span class="line">  <span class="keyword">private</span> String videoDuration;<span class="comment">//视频市场</span></span><br><span class="line">  <span class="keyword">private</span> String videoTime;<span class="comment">//视频画质</span></span><br><span class="line">  <span class="keyword">private</span> String videoQuality;<span class="comment">//视频画质</span></span><br><span class="line">  <span class="keyword">private</span> String videoAddress;<span class="comment">//视频存储地址</span></span><br><span class="line">  <span class="keyword">private</span> String videoPicture;<span class="comment">//视频封面图片</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> videoGood;<span class="comment">//视频点赞数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> videoBad;<span class="comment">//视频差评数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getVideoId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoId</span><span class="params">(<span class="type">long</span> videoId)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoId = videoId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getVideoTitle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoTitle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoTitle</span><span class="params">(String videoTitle)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoTitle = videoTitle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getVideoDescription</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoDescription;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoDescription</span><span class="params">(String videoDescription)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoDescription = videoDescription;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getVideoType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoType</span><span class="params">(String videoType)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoType = videoType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCheckNumber</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> checkNumber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCheckNumber</span><span class="params">(<span class="type">long</span> checkNumber)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.checkNumber = checkNumber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getAuthorPicture</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> authorPicture;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthorPicture</span><span class="params">(String authorPicture)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.authorPicture = authorPicture;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getVideoAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoAuthor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoAuthor</span><span class="params">(String videoAuthor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoAuthor = videoAuthor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getVideoDuration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoDuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoDuration</span><span class="params">(String videoDuration)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoDuration = videoDuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getVideoTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoTime</span><span class="params">(String videoTime)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoTime = videoTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getVideoQuality</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoQuality;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoQuality</span><span class="params">(String videoQuality)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoQuality = videoQuality;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getVideoAddress</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoAddress</span><span class="params">(String videoAddress)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoAddress = videoAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getVideoPicture</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoPicture;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoPicture</span><span class="params">(String videoPicture)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoPicture = videoPicture;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getVideoGood</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoGood;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoGood</span><span class="params">(<span class="type">long</span> videoGood)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoGood = videoGood;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getVideoBad</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> videoBad;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVideoBad</span><span class="params">(<span class="type">long</span> videoBad)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.videoBad = videoBad;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="Service层："><a href="#Service层：" class="headerlink" title="Service层："></a>Service层：</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sporadic.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sporadic.pojo.Video;</span><br><span class="line"><span class="keyword">import</span> com.sporadic.pojo.Videocomment;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//视频上传</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uploadVideo</span><span class="params">(Video video)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="ServiceImpl层："><a href="#ServiceImpl层：" class="headerlink" title="ServiceImpl层："></a>ServiceImpl层：</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sporadic.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sporadic.mapper.VideoMapper;</span><br><span class="line"><span class="keyword">import</span> com.sporadic.pojo.Video;</span><br><span class="line"><span class="keyword">import</span> com.sporadic.pojo.Videocomment;</span><br><span class="line"><span class="keyword">import</span> com.sporadic.service.VideoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">VideoService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> VideoMapper mapper;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//视频上传</span></span><br><span class="line">    <span class="comment">//传递整个video实体类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uploadVideo</span><span class="params">(Video video)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.uploadVideo(video);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="xml："><a href="#xml：" class="headerlink" title="xml："></a>xml：</h3><div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sporadic.mapper.VideoMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    视频上传--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;uploadVideo&quot;</span>&gt;</span></span><br><span class="line">        insert into video(videoTitle, videoDescription, videoType,videoDuration, videoTime,</span><br><span class="line">        videoQuality, videoAddress, videoPicture) values (#&#123;videoTitle&#125;,#&#123;videoDescription&#125;,#&#123;videoType&#125;.</span><br><span class="line">            #&#123;videoDuration&#125;,#&#123;videoTime&#125;,#&#123;videoQuality&#125;,#&#123;videoAddress&#125;,#&#123;videoPicture&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="Controller层代码："><a href="#Controller层代码：" class="headerlink" title="Controller层代码："></a>Controller层代码：</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//视频上传</span></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/SingleFile/upload&quot;,method=RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">SingleFileUpLoad</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;MultipartFile&gt; list_files=((MultipartHttpServletRequest)request).getFiles(<span class="string">&quot;myfile&quot;</span>);</span><br><span class="line">        <span class="comment">//判断文件是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(list_files.isEmpty())&#123;</span><br><span class="line"><span class="comment">//            model.addAttribute(&quot;result_singlefile&quot;, &quot;文件为空&quot;);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;forward:/toUpload&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建输入输出流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//指定上传的位置为 d:/upload/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;d:/Download/&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile file : list_files) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取文件的输入流</span></span><br><span class="line">            inputStream = file.getInputStream();</span><br><span class="line">            <span class="comment">//获取上传时的文件名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">            <span class="comment">//注意是路径+文件名</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path + fileName);</span><br><span class="line">            <span class="comment">//如果之前的 String path = &quot;d:/upload/&quot; 没有在最后加 / ，那就要在 path 后面 + &quot;/&quot;</span></span><br><span class="line">            <span class="comment">//判断文件父目录是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(!targetFile.getParentFile().exists())&#123;</span><br><span class="line">                <span class="comment">//不存在就创建一个</span></span><br><span class="line">                targetFile.getParentFile().mkdir();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取文件的输出流</span></span><br><span class="line">            outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile);</span><br><span class="line">            <span class="comment">//最后使用资源访问器FileCopyUtils的copy方法拷贝文件</span></span><br><span class="line">            FileCopyUtils.copy(inputStream, outputStream);</span><br><span class="line">            <span class="comment">/*参数是通过源码</span></span><br><span class="line"><span class="comment">                public static int copy(InputStream in, OutputStream out) throws IOException &#123;</span></span><br><span class="line"><span class="comment">                    ......</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">           而得知的*/</span></span><br><span class="line">            <span class="comment">//告诉页面上传成功了</span></span><br><span class="line">                PrintWriter out=response.getWriter();</span><br><span class="line">                out.write(<span class="string">&quot;&lt;script type=\&quot;text/javascript\&quot;&gt;&quot;</span>);</span><br><span class="line">                out.write(<span class="string">&quot;alert(&#x27;视频上传成功！&#x27;);&quot;</span>);</span><br><span class="line">                out.write(<span class="string">&quot;location.href=&#x27;/toUpload&#x27;;&quot;</span>);</span><br><span class="line">                out.write(<span class="string">&quot;&lt;/script&gt;&quot;</span>);</span><br><span class="line">                out.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">//出现异常，则告诉页面失败</span></span><br><span class="line"><span class="comment">//            model.addAttribute(&quot;result_singlefile&quot;, &quot;上传失败&quot;);</span></span><br><span class="line">                PrintWriter out=response.getWriter();</span><br><span class="line">                out.write(<span class="string">&quot;&lt;script type=\&quot;text/javascript\&quot;&gt;&quot;</span>);</span><br><span class="line">                out.write(<span class="string">&quot;alert(&#x27;视频上传失败！&#x27;);&quot;</span>);</span><br><span class="line">                out.write(<span class="string">&quot;location.href=&#x27;/toUpload&#x27;;&quot;</span>);</span><br><span class="line">                out.write(<span class="string">&quot;&lt;/script&gt;&quot;</span>);</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//无论成功与否，都有关闭输入输出流</span></span><br><span class="line">        &#125;<span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/toUpload&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud微服务架构核心点介绍</title>
    <url>/2023/09/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E7%82%B9%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="SpringCloud微服务架构核心点介绍"><a href="#SpringCloud微服务架构核心点介绍" class="headerlink" title="SpringCloud微服务架构核心点介绍"></a>SpringCloud微服务架构核心点介绍</h1><h2 id="一、分布式配置中心"><a href="#一、分布式配置中心" class="headerlink" title="一、分布式配置中心"></a>一、分布式配置中心</h2><h3 id="1-由来"><a href="#1-由来" class="headerlink" title="1.由来"></a>1.由来</h3><p>微服务系统中，存在很多功能开关和各种参数的配置项，传统的配置文件、数据库等方式无法满足开发人员对配合管理的需求，此时，分布式配置中心应运而生。</p>
<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><p>统一管理、区分环境、实时刷新、权限控制、版本控制、灰度发布</p>
<h3 id="3-配置的统一管理"><a href="#3-配置的统一管理" class="headerlink" title="3.配置的统一管理"></a>3.配置的统一管理</h3><p>配置中心服务端负责配置的管理 (新增、修改、删除、发布)，集成了配置中心客户端的微服务程序可以统一从配置中心服务端拉取配置，从而实现整个微服务系统的统一配置管理</p>
<h3 id="4-区分不同环境的配置"><a href="#4-区分不同环境的配置" class="headerlink" title="4.区分不同环境的配置"></a>4.区分不同环境的配置</h3><p>一个微服务应用中的某些配置项，在不同的环境 (开发、测试、生产) 通常是不同的 ，作为分布式配置中心需要具有隔离不同环境的功能，使得同一个微服务在不同环境能拉取到对应的配置。</p>
<h3 id="5-配置动态实时刷新"><a href="#5-配置动态实时刷新" class="headerlink" title="5.配置动态实时刷新"></a>5.配置动态实时刷新</h3><p>当配置中心服务端中的配置发生了修改时，配置中心客户端需要能实时监听到配置的改变，使得微服务应用程序可以实时获取到最新配置并且不用重新部署应用程序。</p>
<h3 id="6-配置的权限控制"><a href="#6-配置的权限控制" class="headerlink" title="6.配置的权限控制"></a>6.配置的权限控制</h3><p>在配置中心中，可以针对不同的角色或用户设置对应的权限，比如张三可以新建配置项，但不能发布配置 ;比如小明可以查看配置项，但不能修改配置。</p>
<h3 id="7-配置的版本控制"><a href="#7-配置的版本控制" class="headerlink" title="7.配置的版本控制"></a>7.配置的版本控制</h3><p>在使用配置中心的过程中，难免会出现误操作，而这个时候就需要进行版本回退，所以作为配置中心，是一定要支持版本控制的。</p>
<h3 id="8-配置的灰度发布"><a href="#8-配置的灰度发布" class="headerlink" title="8.配置的灰度发布"></a>8.配置的灰度发布</h3><p>在需要发布一项配置时，如果需要发布到多个实例 (集群) ，那么此时可以只发布到部分实例，待测试通过后，再发布到全部实例，这就是配置的灰度发布</p>
<h3 id="9-常见的配置中心组件"><a href="#9-常见的配置中心组件" class="headerlink" title="9.常见的配置中心组件"></a>9.常见的配置中心组件</h3><p>Sping Cloud Config、阿里Nacos、携程Apollo、谷歌consul</p>
<h2 id="二、分布式注册中心"><a href="#二、分布式注册中心" class="headerlink" title="二、分布式注册中心"></a>二、分布式注册中心</h2><h3 id="1-什么是注册中心？"><a href="#1-什么是注册中心？" class="headerlink" title="1.什么是注册中心？"></a>1.什么是注册中心？</h3><p>注册中心相当于微服务架构中的地址通讯录，每个微服务会将服务及其地址注册到注册中心，服务消费者在调用某个微服务之前会先从注册中心查找服务地址，然后进行调用。</p>
<h3 id="2-注册中心的特点"><a href="#2-注册中心的特点" class="headerlink" title="2.注册中心的特点"></a>2.注册中心的特点</h3><p>服务的自动注册</p>
<p>服务的健康检查</p>
<p>服务的自动发现</p>
<h3 id="3-服务的自动注册"><a href="#3-服务的自动注册" class="headerlink" title="3.服务的自动注册"></a>3.服务的自动注册</h3><p>微服务应用在启动时，通过注册中心客户端组件，将服务相关信息自动注册给注册中心服务端</p>
<h3 id="4-服务的健康检查"><a href="#4-服务的健康检查" class="headerlink" title="4.服务的健康检查"></a>4.服务的健康检查</h3><p>当已经注册到注册中心的微服务实例宕机后，注册中心服务端能发现实例已经宕机，并把相关信息从注册中心删除掉</p>
<h3 id="5-服务的自动发现"><a href="#5-服务的自动发现" class="headerlink" title="5.服务的自动发现"></a>5.服务的自动发现</h3><p>服务消费者需要能实时监听到注册中心中服务信息的变更，以能在真正调用服务时不会出现错误</p>
<h3 id="6-常见的注册中心组件"><a href="#6-常见的注册中心组件" class="headerlink" title="6.常见的注册中心组件"></a>6.常见的注册中心组件</h3><p>Zookeeper、Eureka、Nacos</p>
<h2 id="三、服务网关"><a href="#三、服务网关" class="headerlink" title="三、服务网关"></a>三、服务网关</h2><h3 id="1-什么是服务网关"><a href="#1-什么是服务网关" class="headerlink" title="1.什么是服务网关"></a>1.什么是服务网关</h3><p>服务网关是整个微服务架构中对外的统一入口，所有的客户端都通过统一的网关使用微服务，服务网关起到了隔离外部访问和内部系统的作用服务网关是微服务架构中的一个标配组件。</p>
<h3 id="2-服务网关的特点"><a href="#2-服务网关的特点" class="headerlink" title="2.服务网关的特点"></a>2.服务网关的特点</h3><p>高并发，安全，路由转发，监控于限流，灰度发布，服务重试，服务别名。</p>
<h3 id="3-高并发"><a href="#3-高并发" class="headerlink" title="3.高并发"></a>3.高并发</h3><p>作为微服务架构中的对外入口，必须能支持高并发，能承担更高的并发量，并保证高性能</p>
<h3 id="4-安全"><a href="#4-安全" class="headerlink" title="4.安全"></a>4.安全</h3><p>服务网关通常具有权限认证、黑名单、白名单等保证网关安全的功能</p>
<h3 id="5-路由转发"><a href="#5-路由转发" class="headerlink" title="5.路由转发"></a>5.路由转发</h3><p>服务网关接收到外部请求后，要求服务网关能根据请求和配置将请求转发到对应的后端微服务上去</p>
<h3 id="6-监控与限流"><a href="#6-监控与限流" class="headerlink" title="6.监控与限流"></a>6.监控与限流</h3><p>作为整个系统的流量入口，服务网关要能监控流量情况，遇到突发情况时能及时限流，保证整个系统的稳定</p>
<h3 id="7-灰度发布"><a href="#7-灰度发布" class="headerlink" title="7.灰度发布"></a>7.灰度发布</h3><p>当某个微服务有新版本更新上线时，可以利用服务网关进行流量的切换，实现该微服务的灰度发布</p>
<h3 id="8-服务重试"><a href="#8-服务重试" class="headerlink" title="8.服务重试"></a>8.服务重试</h3><p>当服务网关调用某个微服务失败后，可以通过服务网关设置重试策略来重新尝试调用该服务</p>
<h3 id="9-服务别名"><a href="#9-服务别名" class="headerlink" title="9.服务别名"></a>9.服务别名</h3><p>可以在服务网关中给某个或某些微服务设置别名，从而对外屏蔽内部微服务相关信息</p>
<h3 id="10-常见服务网关组件"><a href="#10-常见服务网关组件" class="headerlink" title="10.常见服务网关组件"></a>10.常见服务网关组件</h3><p>Kong、Zuul、Spring Cloud Gateway</p>
<h2 id="四、负载均衡"><a href="#四、负载均衡" class="headerlink" title="四、负载均衡"></a>四、负载均衡</h2><h3 id="1-什么是负载均衡"><a href="#1-什么是负载均衡" class="headerlink" title="1.什么是负载均衡"></a>1.什么是负载均衡</h3><p>负载均衡是指将访问流量根据负载均衡算法分发到后端服务器的流量分发控制服务，通过负载均衡可以提高微服务的可用性以及性能</p>
<h3 id="2-常用负载均衡算法"><a href="#2-常用负载均衡算法" class="headerlink" title="2.常用负载均衡算法"></a>2.常用负载均衡算法</h3><p>简单轮询，加权轮询，简单随机，加权随机，一致性哈希，最小活跃数</p>
<h3 id="3-简单轮询"><a href="#3-简单轮询" class="headerlink" title="3.简单轮询"></a>3.简单轮询</h3><p>将请求按顺序分发给后端服务器上，不关心服务器当前的状态，比如后端服务器的性能、当前的负载</p>
<h3 id="4-加权轮询"><a href="#4-加权轮询" class="headerlink" title="4.加权轮询"></a>4.加权轮询</h3><p>根据服务器自身的性能给服务器设置不同的权重，将请求按顺序和权重分发给后端服务器，可以让性能高的机器处理更多的请求</p>
<h3 id="5-简单随机"><a href="#5-简单随机" class="headerlink" title="5.简单随机"></a>5.简单随机</h3><p>将请求随机分发给后端服务器上，请求越多，各个服务器接收到的请求越平均</p>
<h3 id="6-加权随机"><a href="#6-加权随机" class="headerlink" title="6.加权随机"></a>6.加权随机</h3><p>根据服务器自身的性能给服务器设置不同的权重，将请求按各个服务器的权重随机分发给后端服务器</p>
<h3 id="7-一致性哈希"><a href="#7-一致性哈希" class="headerlink" title="7.一致性哈希"></a>7.一致性哈希</h3><p>根据请求的客户端ip、或请求参数通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器，这样能保证同一个客 户端或相同参数的请求每次都使用同一台服务器</p>
<h3 id="8-最小活跃数"><a href="#8-最小活跃数" class="headerlink" title="8.最小活跃数"></a>8.最小活跃数</h3><p>统计每台服务器上当前正在处理的请求数，也就是请求活跃数，将请求分发给活跃数最少的后台服务器</p>
<h3 id="9-常见负载均衡组件"><a href="#9-常见负载均衡组件" class="headerlink" title="9.常见负载均衡组件"></a>9.常见负载均衡组件</h3><p>nginx、lvs、ribbon</p>
<h2 id="五、RPC调用"><a href="#五、RPC调用" class="headerlink" title="五、RPC调用"></a>五、RPC调用</h2><h3 id="1-什么是RPC调用"><a href="#1-什么是RPC调用" class="headerlink" title="1.什么是RPC调用"></a>1.什么是RPC调用</h3><p>RPC就是远程过程调用，对于Java程序而言，RPC就是远程方法调用，表示一个方法调用远程的另外一个方法，微服务架构中一个服务调用另外一个服务就可以用RPC调用</p>
<h3 id="2-RPC调用与HTTP调用区别"><a href="#2-RPC调用与HTTP调用区别" class="headerlink" title="2.RPC调用与HTTP调用区别"></a>2.RPC调用与HTTP调用区别</h3><p>HTTP调用使用的是HTTP协议，是网络7层中的应用层协议，HTTP协议规定了数据传输的格式，Restful风格就可以通过HTTP协议来实现</p>
<p>RPC不是网络层面的协议，而是更上层的更灵活的通信协议，RPC调用可以自定义数据格式、数据传输方式，只要能保证调用到远程方法即可</p>
<h3 id="3-常用的RPC调用组件或框架"><a href="#3-常用的RPC调用组件或框架" class="headerlink" title="3.常用的RPC调用组件或框架"></a>3.常用的RPC调用组件或框架</h3><p>Dubbo、gRPC、Thrift、Feign</p>
<h2 id="六、服务熔断"><a href="#六、服务熔断" class="headerlink" title="六、服务熔断"></a>六、服务熔断</h2><h3 id="1-什么是服务熔断？"><a href="#1-什么是服务熔断？" class="headerlink" title="1.什么是服务熔断？"></a>1.什么是服务熔断？</h3><p>服务熔断是指，当服务A调用的某个服务B不可用时，上游服务A为了保证自己不受影响，从而不再调用服务B，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复</p>
<h3 id="2-什么是熔断器"><a href="#2-什么是熔断器" class="headerlink" title="2.什么是熔断器"></a>2.什么是熔断器</h3><p>实现熔断功能的叫熔断器，代表组件为Hystrix、Sentinel</p>
<h3 id="3-熔断器的三种状态"><a href="#3-熔断器的三种状态" class="headerlink" title="3.熔断器的三种状态"></a>3.熔断器的三种状态</h3><p>Closed：关闭状态</p>
<p>Open：打开状态</p>
<p>Half-Open：半打开状态</p>
<h3 id="4-Closed：关闭状态"><a href="#4-Closed：关闭状态" class="headerlink" title="4.Closed：关闭状态"></a>4.Closed：关闭状态</h3><p>当调用失败次数达到阙值时则启动熔断器</p>
<h3 id="5-Open：打开状态"><a href="#5-Open：打开状态" class="headerlink" title="5.Open：打开状态"></a>5.Open：打开状态</h3><p>此时不会真正的调用下游服务，而是直接返回，当过了某段时间后，熔断器会进入到半打开状态</p>
<h3 id="6-Half-Open：半打开状态"><a href="#6-Half-Open：半打开状态" class="headerlink" title="6.Half-Open：半打开状态"></a>6.Half-Open：半打开状态</h3><p>此时会有部分请求访问下游服务，如果这些请求都调用成功了，则认为下游服务恢复了，那么则关闭熔断器，否则熔断器回到打开状态</p>
<h2 id="七、服务降级"><a href="#七、服务降级" class="headerlink" title="七、服务降级"></a>七、服务降级</h2><h3 id="1-什么是服务降级"><a href="#1-什么是服务降级" class="headerlink" title="1.什么是服务降级"></a>1.什么是服务降级</h3><p>服务降级是指，当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压力，这就是服务降级</p>
<h3 id="2-服务降级与服务熔断的区别"><a href="#2-服务降级与服务熔断的区别" class="headerlink" title="2.服务降级与服务熔断的区别"></a>2.服务降级与服务熔断的区别</h3><p>1.都是为了防止系统崩溃</p>
<p>2.都让用户体验到某些功能暂时不可用</p>
<p>3.熔断是下游服务故障触发的，降级是为了降低系统负载</p>
<h3 id="3-什么是服务雪崩"><a href="#3-什么是服务雪崩" class="headerlink" title="3.什么是服务雪崩"></a>3.什么是服务雪崩</h3><p>服务A调用服务B，服务B调用C，此时大量请求突然调用服务A，假如服务A本身能抗住这些请求，但是服务C抗不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断</p>
<h2 id="八、服务限流"><a href="#八、服务限流" class="headerlink" title="八、服务限流"></a>八、服务限流</h2><h3 id="1-什么是服务限流"><a href="#1-什么是服务限流" class="headerlink" title="1.什么是服务限流"></a>1.什么是服务限流</h3><p>服务限流是指在高并发请求下，为了保护系统可以对访问服务的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的</p>
<h3 id="2-常用的限流算法"><a href="#2-常用的限流算法" class="headerlink" title="2.常用的限流算法"></a>2.常用的限流算法</h3><p>固定窗口计数器、滑动窗口计数器、令牌桶、漏通</p>
<h2 id="九、全局锁"><a href="#九、全局锁" class="headerlink" title="九、全局锁"></a>九、全局锁</h2><h3 id="1-什么是全局锁"><a href="#1-什么是全局锁" class="headerlink" title="1.什么是全局锁"></a>1.什么是全局锁</h3><p>全局锁，就是我们常说的分布式锁，是分布式、微服务架构中的一种锁机制，通过全局锁可以很好的在分布式系统中互斥使用共享资源</p>
<h3 id="2-全局锁的实现原理"><a href="#2-全局锁的实现原理" class="headerlink" title="2.全局锁的实现原理"></a>2.全局锁的实现原理</h3><p>Zookeeper：利用Zookeeper的watch机制与临时节点特性</p>
<p>Redis：利用Redis的消费订阅机制与数据超时特性</p>
<h3 id="3-常用的全局锁实现组件"><a href="#3-常用的全局锁实现组件" class="headerlink" title="3.常用的全局锁实现组件"></a>3.常用的全局锁实现组件</h3><p>Redisson、Curator</p>
<h2 id="十、控制总线"><a href="#十、控制总线" class="headerlink" title="十、控制总线"></a>十、控制总线</h2><h3 id="1-什么是控制总线"><a href="#1-什么是控制总线" class="headerlink" title="1.什么是控制总线"></a>1.什么是控制总线</h3><p>控制总线也称消息总线，是微服务系统中用来连接系统中所有服务节点的，微服务中的所有服务节点可以通过控制总线来进行通讯</p>
<h3 id="2-控制总线的应用场景"><a href="#2-控制总线的应用场景" class="headerlink" title="2.控制总线的应用场景"></a>2.控制总线的应用场景</h3><p>目前，Sping Cloud Bus就是控制总线的具体实现，某个微服务可以通过Spirng Cloud来广播事件，而其他微服务可以接受到事件并进行相关处理。</p>
<h2 id="十一、分布式事务"><a href="#十一、分布式事务" class="headerlink" title="十一、分布式事务"></a>十一、分布式事务</h2><h3 id="1-什么是分布式事务"><a href="#1-什么是分布式事务" class="headerlink" title="1.什么是分布式事务"></a>1.什么是分布式事务</h3><p>在一次请求中，所涉及的分散在多个微服务上的操作要保证同时成功或同时失败，这就是分布式事务，比如创建订单减库存、银行转账等</p>
<h3 id="2-实现分布式事务的方式"><a href="#2-实现分布式事务的方式" class="headerlink" title="2.实现分布式事务的方式"></a>2.实现分布式事务的方式</h3><p>直接通过数据库</p>
<p>通过消息队列</p>
<p>两阶段提交</p>
<p>三阶段提交</p>
<h3 id="3-分布式事务中的三个角色"><a href="#3-分布式事务中的三个角色" class="headerlink" title="3.分布式事务中的三个角色"></a>3.分布式事务中的三个角色</h3><p>事务协调器、事务管理者、资源管理者</p>
<h3 id="4-常用的分布式事务框架"><a href="#4-常用的分布式事务框架" class="headerlink" title="4.常用的分布式事务框架"></a>4.常用的分布式事务框架</h3><p>seata、lcn、bytetcc</p>
<h2 id="十二、服务安全"><a href="#十二、服务安全" class="headerlink" title="十二、服务安全"></a>十二、服务安全</h2><h3 id="1-什么是服务安全？"><a href="#1-什么是服务安全？" class="headerlink" title="1.什么是服务安全？"></a>1.什么是服务安全？</h3><p>对于一个企业来说，微服务系统中的服务安全性越来越重要，服务的认证和授权是企业必需具备的，Spring Cloud Security是Spring Cloud提供的微服务安全组件</p>
<h3 id="2-服务安全的特性"><a href="#2-服务安全的特性" class="headerlink" title="2.服务安全的特性"></a>2.服务安全的特性</h3><p>1.可扩展、可配置的认证和授权</p>
<p>2.单点登录</p>
<p>3.防止会话固定、点击劫持、跨网站请求伪造等攻击</p>
<p>4.与Servlet API集成</p>
<h2 id="十三、链路追踪"><a href="#十三、链路追踪" class="headerlink" title="十三、链路追踪"></a>十三、链路追踪</h2><h3 id="1-什么是链路追踪"><a href="#1-什么是链路追踪" class="headerlink" title="1.什么是链路追踪"></a>1.什么是链路追踪</h3><p>链路追踪为微服务系统提供了完整的调用链路还原、调用请求量统计、链路拓扑、应用依赖分析等功能，可以帮助开发者快速分析和诊断微服务架构下的性能瓶颈</p>
<h3 id="2-链路追踪的功能"><a href="#2-链路追踪的功能" class="headerlink" title="2.链路追踪的功能"></a>2.链路追踪的功能</h3><p>分布式调用链查询和诊断<br>应用性能实时汇总<br>分布式拓扑动态发现<br>多语言开发程序接入<br>丰富的下游对接场景</p>
<h3 id="3-常用的链路追踪的技术"><a href="#3-常用的链路追踪的技术" class="headerlink" title="3.常用的链路追踪的技术"></a>3.常用的链路追踪的技术</h3><p>Sleuth、Zipkin</p>
<h2 id="十四、集群管理"><a href="#十四、集群管理" class="headerlink" title="十四、集群管理"></a>十四、集群管理</h2><h3 id="1-什么是集群管理？"><a href="#1-什么是集群管理？" class="headerlink" title="1.什么是集群管理？"></a>1.什么是集群管理？</h3><p>集群管理是指，对于微服务系统中的某个服务集群所提供的针对集群管理的功能，Spring CloudCluster的职责就是集群管理</p>
<h3 id="2-集群管理有哪些功能"><a href="#2-集群管理有哪些功能" class="headerlink" title="2.集群管理有哪些功能"></a>2.集群管理有哪些功能</h3><p>领导者选举<br>一致性存储<br>集群状态管理<br>一次性tokens</p>
<h2 id="十五、事务驱动"><a href="#十五、事务驱动" class="headerlink" title="十五、事务驱动"></a>十五、事务驱动</h2><h3 id="1-什么是事务驱动？"><a href="#1-什么是事务驱动？" class="headerlink" title="1.什么是事务驱动？"></a>1.什么是事务驱动？</h3><p>事件驱动就是消息驱动，在Spring cloud中提供了Spring Cloud Stream来实现事件驱动，有了事件驱动，在微服务系统中可以更方便的通过发送消息来进行通信</p>
<h3 id="2-事件驱动中的概念"><a href="#2-事件驱动中的概念" class="headerlink" title="2.事件驱动中的概念"></a>2.事件驱动中的概念</h3><p>目标绑定器，目标指的是kafka或rabbitmq</p>
<p>绑定桥梁，连接消息系统和应用程序</p>
<p>消息，应用程序和消息系统之间传递的数据</p>
<h3 id="3-事务驱动的特点"><a href="#3-事务驱动的特点" class="headerlink" title="3.事务驱动的特点"></a>3.事务驱动的特点</h3><p>异步处理<br>流量削峰<br>服务解耦</p>
<h2 id="十六、云连接器"><a href="#十六、云连接器" class="headerlink" title="十六、云连接器"></a>十六、云连接器</h2><h3 id="1-什么是云连接器"><a href="#1-什么是云连接器" class="headerlink" title="1.什么是云连接器"></a>1.什么是云连接器</h3><p>云连接器可以用来更方便的连接部署在云上的各种服务，Spring Cloud中Spring Cloud Connectors就是云连接器的组件实现</p>
<h3 id="2-目前支持的云平台"><a href="#2-目前支持的云平台" class="headerlink" title="2.目前支持的云平台"></a>2.目前支持的云平台</h3><p>Spring Cloud Cloud Foundry<br>Spring Cloud Heroku</p>
<h2 id="十七、函数计算"><a href="#十七、函数计算" class="headerlink" title="十七、函数计算"></a>十七、函数计算</h2><h3 id="1-什么是函数计算"><a href="#1-什么是函数计算" class="headerlink" title="1.什么是函数计算"></a>1.什么是函数计算</h3><p>函数计算也称为函数式编程，是实现Serverless的一种手段，企业如果能使用函数计算能大大节约成本，在Spring Cloud中提供了Spring CloudFunction来开发基于云平台的函数计算</p>
<h3 id="2-函数计算的特点"><a href="#2-函数计算的特点" class="headerlink" title="2.函数计算的特点"></a>2.函数计算的特点</h3><p>支持响应式等编程风格</p>
<p>输入输出类型透明转化</p>
<p>流数据处理</p>
<p>同一个jvm中运行多版本函数</p>
<p>打包函数到指定云平台</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse新建servlet项目教程</title>
    <url>/2022/10/02/eclipse%E6%96%B0%E5%BB%BAservlet%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>此文是eclipse新建servlet项目教程，分享给刚入门java web的小伙伴，此文主要讲述了如何配置以及运行的一套流程。</p>
<h1 id="1-打开eclipse选择存放路径"><a href="#1-打开eclipse选择存放路径" class="headerlink" title="1.打开eclipse选择存放路径"></a>1.打开eclipse选择存放路径</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830174819796.png"
                     
                >

<h1 id="2-新建动态网页项目"><a href="#2-新建动态网页项目" class="headerlink" title="2.新建动态网页项目"></a>2.新建动态网页项目</h1><p>在左上角File-&gt;New-&gt;Dynamic Web Project新建</p>
<h1 id="3-新建项目"><a href="#3-新建项目" class="headerlink" title="3.新建项目"></a>3.新建项目</h1><h2 id="1）新建项目包名之后导入Tomcat包，选择下载的8-5那个版本"><a href="#1）新建项目包名之后导入Tomcat包，选择下载的8-5那个版本" class="headerlink" title="1）新建项目包名之后导入Tomcat包，选择下载的8.5那个版本"></a>1）新建项目包名之后导入Tomcat包，选择下载的8.5那个版本</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830175303083.png"
                     
                >

<h2 id="2）选择8-5版本"><a href="#2）选择8-5版本" class="headerlink" title="2）选择8.5版本"></a>2）选择8.5版本</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830175405573.png"
                     
                >

<h2 id="3）项目结构"><a href="#3）项目结构" class="headerlink" title="3）项目结构"></a>3）项目结构</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830175459939.png"
                     
                >

<h2 id="4）新建一个servlet类"><a href="#4）新建一个servlet类" class="headerlink" title="4）新建一个servlet类"></a>4）新建一个servlet类</h2><h3 id="右键New一个servlet类"><a href="#右键New一个servlet类" class="headerlink" title="右键New一个servlet类"></a>右键New一个servlet类</h3><h2 id="5）设置新建的servlet类"><a href="#5）设置新建的servlet类" class="headerlink" title="5）设置新建的servlet类"></a>5）设置新建的servlet类</h2><h3 id="包名可以自己设置一个，类名同理"><a href="#包名可以自己设置一个，类名同理" class="headerlink" title="包名可以自己设置一个，类名同理"></a>包名可以自己设置一个，类名同理</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830180127753.png"
                     
                >

<h2 id="6）配置启动项"><a href="#6）配置启动项" class="headerlink" title="6）配置启动项"></a>6）配置启动项</h2><p>鼠标移动到包名上，右键Buile Path—&gt;Configure Buile Path</p>
<p>选择到Librares，点击modulepath后右边新建一个</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830180433911.png"
                     
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830180650690.png"
                     
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830180706604.png"
                     
                >

<p>两种启动方法：</p>
<h1 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h1><h1 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830180824300.png"
                     
                >

<h1 id="下一步："><a href="#下一步：" class="headerlink" title="下一步："></a>下一步：</h1><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830180903403.png"
                     
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830181110665.png"
                     
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Servlet-Img/image-20220830181127123.png"
                     
                >]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows中杀死占用某个端口的进程</title>
    <url>/2022/09/24/Windows%E4%B8%AD%E6%9D%80%E6%AD%BB%E5%8D%A0%E7%94%A8%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>最近在写Java web的项目的时候，总是会出现Tomcat端口被占用的问题，这是因为Tomcat的8080端口在启动之后代码缺陷忘记停止进程，导致后面想再次启动时可能会出现端口被占用的bug，那么怎么去解决这一bug呢？</p>
<h3 id="第一步，打开cmd命令窗口，输入命令，根据端口号查找对应的进程号"><a href="#第一步，打开cmd命令窗口，输入命令，根据端口号查找对应的进程号" class="headerlink" title="第一步，打开cmd命令窗口，输入命令，根据端口号查找对应的进程号"></a>第一步，打开cmd命令窗口，输入命令，根据端口号查找对应的进程号</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80</span><br></pre></td></tr></table></figure></div>

<p>发现 8080 端口被 PID(进程号)为 9268 的进程占用。</p>
<h3 id="第二步，-据进程号寻找进程名称"><a href="#第二步，-据进程号寻找进程名称" class="headerlink" title="第二步， 据进程号寻找进程名称"></a>第二步， 据进程号寻找进程名称</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">tasklist | findstr 9268</span><br></pre></td></tr></table></figure></div>

<p>根据进程号从任务管理器中查找该程序，手动杀死即可。</p>
<p>但是我发现，在任务管理器中找不到该程序。只好从命令行杀死该程序了，命令如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程</span><br></pre></td></tr></table></figure></div>

<p>这样就把占用8080端口的进程给干掉了</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora+PicGo+阿里云OSS搭建博客图床</title>
    <url>/2023/05/22/Typora-PicGo-%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="Typora-PicGo-阿里云OSS搭建博客图床"><a href="#Typora-PicGo-阿里云OSS搭建博客图床" class="headerlink" title="Typora+PicGo+阿里云OSS搭建博客图床"></a>Typora+PicGo+阿里云OSS搭建博客图床</h1><p><strong>首先我们理清一个概念：什么叫图床？</strong></p>
<p>拿今天的例子来讲，在我们网Typora里插入图片的适合，PicGo会自动上传图片到图床，Typora可以于PicGo单向绑定，并且返回一个图片的链接，这个链接是一个网址，是可以访问的。</p>
<p>这个时候你的图片就是一个网址，不再是本地路径。你也可以在任何能联网的地方，用任何设备访问这张图片了。</p>
<p>即便是本地的那张图片移动或者删除了，也不会影响图床里的这张图片，markdown本地文件里面的图片也不会失效了。</p>
<p>那么今天开始教程：</p>
<p>本次选用的是<strong>Typora+PicGo+阿里云OSS</strong>，除了前两个免费软件之外，阿里云的付费也非常便宜！所以强烈推荐这写作三件套。</p>
<h3 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h3><h3 id="1-Typora"><a href="#1-Typora" class="headerlink" title="1.Typora"></a>1.Typora</h3><p>想必大家都听过Typora这款软件，一款支持实时预览的MarkDown文本编辑器，而且它为编辑体验的考虑细致到了令人叹为观止的程度。感兴趣的话大家可以去官网搜索这款软件，也可以学习更多的内容，所以就不扩展讲述了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522201215816.png"
                      alt="image-20230522201215816"
                ></p>
<h3 id="2-PicGo"><a href="#2-PicGo" class="headerlink" title="2.PicGo"></a>2.PicGo</h3><p>PicGo是一款开源的图床管理工具，十分流行，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522201257002.png"
                      alt="image-20230522201257002"
                ></p>
<h3 id="3-配置阿里云OSS"><a href="#3-配置阿里云OSS" class="headerlink" title="3.配置阿里云OSS"></a>3.配置阿里云OSS</h3><p>在浏览器进入阿里云，在左上角进入对象储存OSS，按照步骤一一进入</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522204452700.png"
                      alt="image-20230522204452700"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522204529906.png"
                      alt="image-20230522204529906"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522204957644.png"
                      alt="image-20230522204957644"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img-blog.csdnimg.cn/img_convert/484978392ac99c96125a6fc7d5e2aadf.png"
                      alt="image-20220111195753835"
                ></p>
<p>按照上述步骤创建完之后，你的bucket应该就出现在了左侧</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522205315773.png"
                      alt="image-20230522205315773"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522205559737.png"
                      alt="image-20230522205559737"
                ></p>
<p>这个就是在后续的PicGo配置中会用到，所以可以保存一下，那么进行下一步。</p>
<p>找到你的Key，看到右上角，在里面选择AccessKey管理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522205736118.png"
                      alt="image-20230522205736118"
                ></p>
<p>这里选择这个继续使用AccessKey</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522205816990.png"
                      alt="image-20230522205816990"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img-blog.csdnimg.cn/img_convert/4ec57e443224d250970d42ceb2092a5d.png"
                      alt="image-20220111201037036"
                ></p>
<p>创建一个之后，记住你的AccessKeyId和AccessKeySecret，你也可以放在一个记事本里保存起来。</p>
<h3 id="4-充值一下阿里云"><a href="#4-充值一下阿里云" class="headerlink" title="4.充值一下阿里云"></a>4.充值一下阿里云</h3><p>阿里云OSS的各项收费是<strong>独立</strong>的！</p>
<p>对于<strong>图床</strong>而言，有两种收费形式</p>
<ul>
<li>以<strong>充值的方式</strong>使用<strong>储存容量</strong>以及<strong>流量</strong>(默认状态)</li>
<li>按年&#x2F;月收费，购买一定存储包。<strong>流量额外收费</strong></li>
</ul>
<p>也就是说，即便你购买了下图的存储包，你依旧要为<strong>访问图床的流量</strong>付钱！</p>
<p>可以看一下容量和流量收费的价格：</p>
<ul>
<li>储存容量：0.12元&#x2F;GB&#x2F;月</li>
<li>图片<strong>上传</strong>到阿里OSS流量：免费</li>
<li><strong>外网流出</strong>流量(如typora访问图床图片)：闲时0.25元&#x2F;GB，<strong>忙</strong>时0.50元&#x2F;GB</li>
</ul>
<p>是不是特别便宜，按照这样算下来一年就是1.44元。</p>
<p>注意：记得给阿里云充值账户，欠费的话就用不了了。</p>
<p>到这里，阿里云OSS基本就配置完毕了</p>
<h3 id="5-配置PicGo"><a href="#5-配置PicGo" class="headerlink" title="5.配置PicGo"></a>5.配置PicGo</h3><p>下载打开PicGo主界面，是这样子的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522210247035.png"
                      alt="image-20230522210247035"
                ></p>
<p>选择图床设置，选择阿里云OSS，依次填写信息：</p>
<p>设定Keyld：填写刚刚获得的AccessKeyID</p>
<p>设定KeySecret：填写AccessKeyIDSecret</p>
<p>设定储存空间名：填写bucket名称</p>
<p>这里填写的是bucket名称，不是浏览器里的域名</p>
<p>确认存储区域：填写你的地域节点，注意复制的格式</p>
<p>指定存储路径：其实就是自定义一个文件夹的名字，以&#x2F;结尾</p>
<p>它会自动在你的bucket里面创建一个文件夹，并把图片上传进去，例如我的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/image-20230522210357412.png"
                      alt="image-20230522210357412"
                ></p>
<p>弄完之后记得点击确定，并且设置为默认图床。</p>
<h3 id="6-配置Typora"><a href="#6-配置Typora" class="headerlink" title="6.配置Typora"></a>6.配置Typora</h3><p>打开右上角的文件，偏好设置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230522210709.png"
                      alt="image-20230522210709037"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230522210821.png"
                      alt="image-20230522210821871"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230522211010.png"
                      alt="image-20230522211010764"
                ></p>
<p>最后验证一下，只要你的Typora里出现你的链接就算是配置完成啦！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230522211116.png"
                     
                ></p>
<p>那么今天的教程就到这里，实际上的写作三件套在日常中还是很适用的，例如作者搭配这些运用到hexo博客上，可以说是非常好用，一条龙服务。</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>idea快捷键</title>
    <url>/2022/09/02/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>idea快捷键——提高码字速度</p>
<p>🌾快捷键（提高码字速度）<br>1.快速生成main方法:psvm +Tab或 main+Tab</p>
<p>2.快速生成System.out.prinltn():sout+Tab</p>
<p>3.删除一行:Ctrl+Y</p>
<p>4.切换java文件（前提是工程有多个.java文件）</p>
<p>Alt+右箭头 或 Alt+左箭头</p>
<p>5,复制选中行到下一行:Ctrl+D</p>
<p>6.撤销上一步操作:Ctrl+Z</p>
<p>7.取消撤销:Ctrl+Shift+Z</p>
<p>8.将选中的行合并成一行:Ctrl+shift+J</p>
<p>9.Ctrl+N:查找类文件</p>
<p>10.显示文件结构:Ctrl+F12</p>
<p>11.显示当前文件夹路径:Ctrl+Alt+F12</p>
<p>12.显示当前类的继承层次:Ctrl+H</p>
<p>13.定位至下一个错误:F2</p>
<p>14.定位到前一个错误:Shift+F2</p>
<p>15.展开代码:Ctrl+&#x3D;</p>
<p>16.折叠代码:Ctrl+-</p>
<p>17.选中所有：Ctrl+A</p>
<p>18.复制:Ctrl+C</p>
<p>19.剪切:Ctrl+X:</p>
<p>20.粘贴:Ctrl+V</p>
<p>21.定位到文件的某一行:Ctrl+G</p>
<p>22.选中的行多行注释:Ctrl+Shift+&#x2F;</p>
<p>23.选中的行注释或取消注释:Ctrl+&#x2F;</p>
<p>24.运行当前文件:Ctrl+Shift+F10</p>
<p>25.提示方法的参数:Ctrl+P</p>
<p>26.跳到文件尾:Ctrl+End</p>
<p>27.跳到文件头:Ctrl+Home</p>
<p>28.选中的行代码格式化:Ctrl+Alt+L</p>
<p>29.在当前文件进行文本查找:Ctrl+R</p>
<p>30.选中的行打断点或取消断点:Ctrl+F8</p>
<p>🤡自定义快捷键<br>File-&gt;Setting-&gt;KeyMap</p>
<p>🐢搜索插件方法及安装<br>File-&gt;Settings-&gt;Plugins</p>
<p>✨快捷键提示（让你脱离鼠标）<br>安装插件：Key Promoter X</p>
<p>右侧列表展开，会展示你近期使用的功能进行，需要经常使用的我们就可以记住快捷键，提高效率。</p>
<p>🍎设置背景<br>安装插件：Backgroud Image Plus +</p>
<p>设置壁纸：File-&gt;Settings-&gt;Appearance-&gt;BackgoundImage</p>
<p> 设置随机切换壁纸</p>
<p>Settings-&gt;Background Image Plus</p>
<p>📈翻译<br>安装插件：Translation</p>
<p>是不是非常的方便！！！ </p>
<p>🍓简体中文<br>安装插件：Chinese (Simplified)</p>
<p>🌈七彩括号<br>安装插件：Rainbow Brackets</p>
<p>面对这样的一个表达式：</p>
<p>boolean flag &#x3D; (true?false:(false?true:(false &#x3D;&#x3D; true?false:true)))</p>
<p>轻轻松松阅读！！！ </p>
<p>🤙小地图<br>安装插件：Code Glance</p>
<p>阅读很长的代码，滚轮都滚冒烟了。</p>
<p>🎯代码统计<br>安装插件：Statistic</p>
<p>💎生成方法时序图<br>安装插件：SequenceDiagram</p>
<p>🥝代码补全<br>安装插件：Codota AI</p>
<p>IDEA自带的补全代码已经很强大，AI补全代码更加强大，越用越好用。</p>
<p>🖐防沉迷<br>安装插件：StopCoding</p>
<p>🏓LeetCode刷题<br>安装插件：LeetCode Editor</p>
<p>🎽快速生成文档注释<br>安装插件：JavaDoc</p>
<p>Windows上可以通过Alt+Insert，Mac可通过Ctrl+Enter。</p>
<p>🐳扫描代码问题<br>安装插件：SonarLint</p>
<p>帮助你检查代码的问题，例如性能，安全、重复等问题。新手必备。 </p>
<p>🧣阿里巴巴编码规范检查工具<br>安装插件 ：Alibaba Java Coding Guidelines</p>
<p>提高代码质量，必不可少。</p>
<p>🍋日志信息着色<br>安装插件：Grep Console</p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>jsp页面加载完自动跳转代码</title>
    <url>/2022/10/25/jsp%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>这个是Java web常用的脚本，当默认的index.jsp加载完毕之后，页面会自动跳转到指定路径，用于绝大多数情况。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>idea插件分享</title>
    <url>/2023/11/25/idea%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="idea插件分享"><a href="#idea插件分享" class="headerlink" title="idea插件分享"></a>idea插件分享</h1><p>原文链接：<a class="link"   href="https://blog.csdn.net/liliangpin/article/details/131526467" >30 款狂拽酷炫的 IDEA 插件，拉满生产力_猿同学的博客-CSDN博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol>
<li><p>Codota——代码智能提示</p>
<p>只要打出首字母就能联想出一整条语句，还可以显示每条语句的实用频率。</p>
</li>
<li><p>Alibaba Java Code Guidelines——阿里巴巴Java代码规范</p>
<p>针对没有Code Review的公司，按照阿里巴巴Java规范来开发。</p>
</li>
<li><p>Translation——必备的翻译插件</p>
<p>在日常的开发活动中，看文档一直是个问题，此插件可以直接右键翻译。</p>
</li>
<li><p>Rainbow Brackets——让你的括号变成不一样的彩虹颜色，防止错乱括号</p>
<p>成对的括号显示相同的颜色，可以解决视觉上的冲突，方便定位查看。</p>
</li>
<li><p>CodeGlance——缩略图</p>
<p>当代码很多的时候，方便查看，可以在界面右边滑动定位查看很方便。</p>
</li>
<li><p>Material Theme UI——IDEA主题插件</p>
</li>
<li><p>Maven Helper——方便maven项目解决jar冲突</p>
<p>这是一个解决Maven依赖冲突，可以快速查找项目中的依赖冲突，给出解决方案！</p>
</li>
<li><p>RestfulTool——一套Restful服务开发辅助工具集</p>
<p>每次报错了拿着前端的请求路径，不用一个个的controller里找了，直接Ctrl+Alt+&#x2F;就可以精确定位</p>
</li>
<li><p>FindBugs——检查代码bug隐患，并给出原因</p>
</li>
<li><p>lombok——减少代码重复编写，并提供比较好的解决方案</p>
<p>实体类中的get&#x2F;set&#x2F;构造&#x2F;toString&#x2F;hashCode等方法，都不需要我们再手写了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于最近很火的ChatGPT解读</title>
    <url>/2023/07/18/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E5%BE%88%E7%81%AB%E7%9A%84ChatGPT%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>ChatGPT介绍 OpenAI</p>
<p>ChatGPT是一种基于GPT（Generative Pre-train Transformer）模型的大型语言模型，由OpenAI公司开发。它是目前世界上最先进的自然语言处理技术之一。</p>
<p>ChatGPT是基于GPT-3.5架构进行训练的，拥有1750亿个参数，是目前公开的最大的语言模型之一。</p>
<p>ChatGPT可以用于各种对话应用，包括智能客服、聊天机器人等。它可以实现自然的对话流程，并能够回答各种类型的问题。除此之外，ChatGPT还可以进行文本生成、摘要、翻译等任务。</p>
<p>01</p>
<p>ChatGPT表演时间</p>
<p><strong>Show Time</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230718145000.png"
                      alt="图片"
                ></p>
<p>问题：你如何看待ChatGPT？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230718144959.png"
                      alt="图片"
                ></p>
<p>问题：写一篇微信公众号推文</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230718145002.png"
                      alt="图片"
                ></p>
<p>问题：写一个爬虫脚本，可以批量下载资源</p>
<p>02</p>
<p>ChatGPT使用事项</p>
<p>这里可以粗略的介绍一下ChatGPT如何使用：首先你得获取一个能翻墙的VPN，因为openAi是国外的，所以需要翻墙才能进入ChatGPT网站（关于VPN就不透露太多奥~），另外小编在这里推荐一个网站，里面包含了100个ChatGPT账号。</p>
<p>网站链接：</p>
<p><strong><a class="link"   href="https://www.cmdpe.com/post/163.html" >https://www.cmdpe.com/post/163.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p>
<p>03</p>
<p>相信大家看了上述内容一定对ChatGPT很好奇把，但是使用ChatGPT仍然是一把双刃剑，好的方面能提高我们的学习能力，坏的方面说不定会成为一种依赖，所以在这里我觉得正确的去使用它才最重要！</p>
<p>ChatGPT确实火，在网络上各种声音都有，但是我觉得chatGPT及相关技术确实会对人类科技的进步产生非常大的影响，同时对于个人来说也会有非常大的影响。我作为一个体验过ChatGPT的大学生来说，我并不认为ChatGPT能够取代人类，它只能用作我们的首席助手。</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>在Navicat Premium数据库管理工具导入Excel文件数据</title>
    <url>/2022/11/01/%E5%9C%A8Navicat-Premium%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E5%AF%BC%E5%85%A5Excel%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>如果你的电脑上有Navicat Premium数据库，不妨看看这个功能：在Navicat Premium数据库管理工具导入Excel文件数据，那么具体怎么操作呢，让我们开始今天的教程。</p>
<p>首先我们来看一个我的项目案例：这是一个jsp的购物网项目，需要导入大量的商品数据，所以如果纯靠Navicat Premium数据库管理工具导入是不现实的，需要花费大量的时间，这个时候office办公软件——Excel能很好的满足我们的储存数据需求，但是如何将Excel表格里的数据导入管理工具当中呢？</p>
<img src = "/asset_img/Navicat-Img/img1.jpg">

<p>我们先新建一个Excel文件，第一行我们可以用来输入标题，例如商品编号、商品名称、商品描述、商品价格、商品库存和商品图片地址。然后下面就可以输入我们的主要数据啦！</p>
<img src = "/asset_img/Navicat-Img/img5.jpg">

<p>然后再次来到Navicat Premium数据库管理工具当中，可以新建一个数据库再新建一个表格，因为我们这个导入是直接导入表格数据，如下：</p>
<img src = "/asset_img/Navicat-Img/img2.jpg">

<p>然后再选择导入，选择导入路径</p>
<img src = "/asset_img/Navicat-Img/img9.jpg">

<img src = "/asset_img/Navicat-Img/img6.jpg">

<p>这里有很多格式可以选，我们选择Excel文件</p>
<img src = "/asset_img/Navicat-Img/img14.jpg">

<p>这里的选项可以按照自己的需求来，我是没有选择的</p>
<img src = "/asset_img/Navicat-Img/img3.jpg">

<p>然后就来到了选择目标表，我们新建的表格就奏效了，选择我们新建的那个表格</p>
<img src = "/asset_img/Navicat-Img/img12.jpg">

<p>这里的话定义字段，意思就是对应Excel表格上我们定义的标题，这里智能的列举出来了，我们只要把标题对应到数据库表格里的目标字段就行。</p>
<img src = "/asset_img/Navicat-Img/img8.jpg">

<p>操作后的截图，按照需求选择主键，方便管理，这里选择的是PRODUCT_ID，商品编号为主键。</p>
<img src = "/asset_img/Navicat-Img/img7.jpg">

<p>这边导入格式我推荐是追加或者更新，大家可以根据自己的需求选择，然后就可以开始导入了，导入之后刷新即可看到我们Excel表格里面的所有数据啦！</p>
<img src = "/asset_img/Navicat-Img/img13.jpg">

<img src = "/asset_img/Navicat-Img/img11.jpg">

]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>利用深度学习提高人脸识别的准确率</title>
    <url>/2023/05/05/%E5%88%A9%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8F%90%E9%AB%98%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%9A%84%E5%87%86%E7%A1%AE%E7%8E%87/</url>
    <content><![CDATA[<p>人脸识别技术在安防领域得到了广泛的应用，但是传统的人脸识别算法存在着准确率低、受光线、角度、表情等影响的问题。近年来，深度学习技术的发展使得人脸识别算法的准确率得到了大幅度的提高。本文将介绍如何利用深度学习技术提高人脸识别的准确率。</p>
<h1 id="一、人脸识别的难点"><a href="#一、人脸识别的难点" class="headerlink" title="一、人脸识别的难点"></a>一、人脸识别的难点</h1><p>人脸识别的难点在于人脸的差异性以及环境的复杂性。同一个人的不同表情、姿态、光照条件下的人脸图像都会有所不同，这对于人脸识别算法来说是一个极大的挑战。传统的人脸识别算法主要依靠人工提取特征，如主成分分析(Polynomial Component Analysis, PCA)、线性判别分析(Linear Discriminant Analysis, LDA)等方法。但是这些方法的准确率受到了很大的限制。</p>
<h1 id="二、深度学习在人脸识别中的应用"><a href="#二、深度学习在人脸识别中的应用" class="headerlink" title="二、深度学习在人脸识别中的应用"></a>二、深度学习在人脸识别中的应用</h1><p>深度学习技术以其优秀的泛化能力和自适应能力，在人脸识别中得到了大量的应用。DeepFace是Facebook于2014年提出的一种基于深度学习的人脸识别算法。该算法使用了一个9层卷积神经网络(CNN)来提取人脸特征，然后使用线性SVM分类器进行分类。DeepFace的准确率达到了97.35%。</p>
<p>FaceNet是Google于2015年提出的一种基于三元组损失函数的人脸识别算法。该算法使用了一个深度卷积神经网络来提取人脸特征，并使用三元组损失函数来学习特征向量空间的度量。FaceNet的准确率达到了99.63%。</p>
<h1 id="三、如何利用深度学习提高人脸识别准确率"><a href="#三、如何利用深度学习提高人脸识别准确率" class="headerlink" title="三、如何利用深度学习提高人脸识别准确率"></a>三、如何利用深度学习提高人脸识别准确率</h1><h2 id="1-采集大量数据"><a href="#1-采集大量数据" class="headerlink" title="1.采集大量数据"></a>1.采集大量数据</h2><p>深度学习算法需要大量的训练数据来学习模型，因此在人脸识别中，采集大量的人脸图像数据是非常重要的。可以采用在线的公开数据集，如Labeled Faces in the Wild、CelebA等，在项目中自行采集数据。</p>
<h2 id="2-使用深度学习框架"><a href="#2-使用深度学习框架" class="headerlink" title="2.使用深度学习框架"></a>2.使用深度学习框架</h2><p>深度学习框架为开发人员提供了大量的高层次API和工具，可快速构建和训练深度学习模型。在人脸识别中，常用的深度学习框架包括Tensorflow、PyTorch等。</p>
<h2 id="3-选择合适的模型"><a href="#3-选择合适的模型" class="headerlink" title="3.选择合适的模型"></a>3.选择合适的模型</h2><p>选择合适的模型是提高人脸识别准确率的关键。当前常用的模型包括VGGNet、ResNet、Inception等。针对人脸识别可以选择在ImageNet上预训练的模型，然后在人脸数据集上进行微调。</p>
<h2 id="4-使用数据增强技术"><a href="#4-使用数据增强技术" class="headerlink" title="4.使用数据增强技术"></a>4.使用数据增强技术</h2><p>数据增强技术可以通过对输入数据进行随机变换，如旋转、平移、缩放、翻转等来扩充数据集，从而提高模型的鲁棒性和泛化能力。</p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>忘忧Studio树洞功能开启测试阶段，欢迎大家积极参与！</title>
    <url>/2023/09/22/%E5%BF%98%E5%BF%A7Studio%E6%A0%91%E6%B4%9E%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E7%A7%AF%E6%9E%81%E5%8F%82%E4%B8%8E%EF%BC%81/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230922101602.jpeg"
                      alt="img"
                ></p>
<p>前言：</p>
<p>在这个喧嚣的世界里，有时候我们需要一个安静的地方，一个可以倾诉自己内心的地方。这就是为什么树洞成为了很多人心中的圣地。在这里，你可以匿名地分享你的故事、烦恼、想法和心情，得到别人的关注和支持，而不必担心被别人知道你的身份。</p>
<p>我们的微信公众号也有一个树洞，这里是一个开放的社区，欢迎任何人前来分享自己的故事。我们相信，每个人都有自己的故事，而这些故事，往往可以帮助其他人更好地理解和面对生活中的挑战。</p>
<p>在这里，你可以找到一群志同道合的人，他们和你一样，都在寻找一个可以倾诉的地方。你可以向他们倾诉你的烦恼，得到他们的支持和帮助。同时，你也可以通过倾听他人的故事，学习到更多的知识和经验。</p>
<p>无论你遇到什么问题，都不要害怕向我们求助。我们会认真地阅读每一条留言，并尽可能地给你提供帮助和支持。在这里，你不是一个人，我们会一直陪伴着你，帮助你走过人生的每一个阶段。</p>
<p>所以，如果你有什么话想说，就来找我们吧！让我们一起倾听彼此的故事，共同成长。</p>
<p>投稿方式：</p>
<p>”那些现实不曾发出的声音，请把它留在这里。“</p>
<p>评论区下方匿名评论，大家可以留下你的故事、烦恼、想法和心情，作者将会完好保存，本篇文章长期有效，欢迎大家投稿分享~</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>忘忧树洞</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度如何计算？</title>
    <url>/2022/10/05/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%EF%BC%9F/</url>
    <content><![CDATA[<p>时间复杂度怎么算？如何计算时间复杂度？<br>时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。</p>
<h1 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h1><h2 id="⑴-找出算法中的基本语句；"><a href="#⑴-找出算法中的基本语句；" class="headerlink" title="⑴ 找出算法中的基本语句；"></a>⑴ 找出算法中的基本语句；</h2><p>算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。</p>
<h2 id="⑵-计算基本语句的执行次数的数量级；"><a href="#⑵-计算基本语句的执行次数的数量级；" class="headerlink" title="⑵ 计算基本语句的执行次数的数量级；"></a>⑵ 计算基本语句的执行次数的数量级；</h2><p>只需保留f(n)中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。</p>
<h2 id="⑶-用大Ο记号表示算法的时间性能。"><a href="#⑶-用大Ο记号表示算法的时间性能。" class="headerlink" title="⑶ 用大Ο记号表示算法的时间性能。"></a>⑶ 用大Ο记号表示算法的时间性能。</h2><p>将基本语句执行次数的数量级放入大Ο记号中。</p>
<p>如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"></span><br><span class="line">　　x++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"></span><br><span class="line">　<span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line"></span><br><span class="line">　　x++;</span><br></pre></td></tr></table></figure></div>

<p>第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n²)，则整个算法的时间复杂度为Ο(n+n²)&#x3D;Ο(n²)。</p>
<p><strong>注意加法原则：T(n)&#x3D;O(f(n))+O(g(n))&#x3D;O(max(fn,gn))</strong></p>
<p><strong>常见的算法时间复杂度由小到大依次为：</strong></p>
<p><strong>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n²)＜Ο(n³)＜…＜Ο(2^n)＜Ο(n!)&lt;O(n^n)</strong></p>
<p>Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。Ο(log2n)、Ο(n)、Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者是有效算法，把这类问题称为P类问题，而把后者称为NP问题。</p>
<p>对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个<em>循环的时间复杂度为 O(n×m)。</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aFunc</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 循环次数为 n</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>); <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时时间复杂度为 O(n × 1)，即 O(n)。</p>
<p>对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aFunc</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 循环次数为 n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 循环次数为 n</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>); <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure></div>
<p>此时时间复杂度为 O(n × n × 1)，即 O(n^2)。</p>
<p>对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aFunc</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="comment">// 第一部分时间复杂度为 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">　　    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">　　　　    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">　　    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 第二部分时间复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">　　    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。</p>
<p>对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aFunc</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 第一条路径时间复杂度为 O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;输入数据大于等于零\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 第二条路径时间复杂度为 O(n)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入数据小于零\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。</p>
]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试题库</title>
    <url>/2023/05/28/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/</url>
    <content><![CDATA[<h1 id="一，基础"><a href="#一，基础" class="headerlink" title="一，基础"></a>一，基础</h1><h2 id="1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？"><a href="#1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？" class="headerlink" title="1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？"></a>1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？</h2><p>Java的数据类型：基本数据类型和引用数据类型<br>        基本数据类型：byte（1），short（2），int（4），long（8），float（4），double（8），char（2），boolean（1）<br>        引用数据类型：类，接口，数组</p>
<h2 id="2、Java语言的几大特性是什么？分别怎么理解？-封装、继承、多态的好处"><a href="#2、Java语言的几大特性是什么？分别怎么理解？-封装、继承、多态的好处" class="headerlink" title="2、Java语言的几大特性是什么？分别怎么理解？(封装、继承、多态的好处)"></a>2、Java语言的几大特性是什么？分别怎么理解？(封装、继承、多态的好处)</h2><p>继承、封装、多态</p>
<p>继承：<br>            继承是从已有类得到继承信息新创类的过程。<br>            提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。<br>            继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p>
<p>封装：<br>            通常认为分装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。<br>            面向对象的本质就是将现实世界描绘成一系列的完全自治、封闭的对象。<br>            在类中编写的方法就是对实现细节的一种封装，编写的一个类就是对数据和数据操作的封装。<br>            可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</p>
<p>多态：<br>            多态性是指允许不同子类型的对象对同一消息做出不同的响应。<br>            简单地说就是用同样的对象引用调用同样的方法，但做了不同的事情。<br>            多态性分为编译时的多态性和运行时的多态性。<br>            如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：<br>            当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的。<br>            方法重载（overload）实现的是编译时的多态性（也就是前绑定），而方法的重写（override）实现的是运行时的  多态性（也称为后绑定）。<br>            运行时的多态时面向对象最精髓的东西，要实现多态需要做两件事：<br>            1）、方法重写（子类继承父类并重写父类中已有的或抽象的方法）<br>            2）、对象造型（用父类引用引用子类对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）</p>
<h2 id="3、Java的权限修饰符有哪些？都能加在哪些地方？分别代表什么意义？"><a href="#3、Java的权限修饰符有哪些？都能加在哪些地方？分别代表什么意义？" class="headerlink" title="3、Java的权限修饰符有哪些？都能加在哪些地方？分别代表什么意义？"></a>3、Java的权限修饰符有哪些？都能加在哪些地方？分别代表什么意义？</h2><p>Java的权限修饰符有4种：<br>            public、protected、default、private<br>        都能加在哪些地方：<br>            类、方法、成员变量<br>        分别代表的意义：<br>            public：公共的，任意位置都能访问<br>            protected：当前类、同一个包下、子类都能访问，其他包下不能访问<br>            default：当前类、同一个包下可访问，子类和其他包下不能访问<br>            private：私有的，只能当前类中访问</p>
<h2 id="4、什么是重写？什么是重载？"><a href="#4、什么是重写？什么是重载？" class="headerlink" title="4、什么是重写？什么是重载？"></a>4、什么是重写？什么是重载？</h2><p>重写：<br>            重写发生在子类和父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型；<br>            比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常<br>重载：<br>            重载发生在一个类中，同名的方法如果有不同的参数列表，则视为重载</p>
<h2 id="5、final关键字能加在哪些地方？分别代表什么？"><a href="#5、final关键字能加在哪些地方？分别代表什么？" class="headerlink" title="5、final关键字能加在哪些地方？分别代表什么？"></a>5、final关键字能加在哪些地方？分别代表什么？</h2><p>属性：属性不可变<br>方法：方法不可覆盖<br>类：被其修饰的类不可继承</p>
<h2 id="6、static关键字能加在哪些地方？分别代表什么？"><a href="#6、static关键字能加在哪些地方？分别代表什么？" class="headerlink" title="6、static关键字能加在哪些地方？分别代表什么？"></a>6、static关键字能加在哪些地方？分别代表什么？</h2><p>成员变量：使其变成静态变量，该类的所以实例都将共享此变量<br>    方法：使其变成静态方法，类加载后，便可以直接调用此方法，而不需要一个该类的实例<br>    代码块：类加载时，会执行这一段代码</p>
<h2 id="7、接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？（注意JDK1-8接口中是可以出现非抽象方法的：default方法、静态方法）"><a href="#7、接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？（注意JDK1-8接口中是可以出现非抽象方法的：default方法、静态方法）" class="headerlink" title="7、接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？（注意JDK1.8接口中是可以出现非抽象方法的：default方法、静态方法）"></a>7、接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？（注意JDK1.8接口中是可以出现非抽象方法的：default方法、静态方法）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口：</span><br><span class="line">    在接口类中，成员变量必须是常量，也就是final修饰的</span><br><span class="line">    接口中的方法默认都是 public abstract 都是抽象的</span><br><span class="line">抽象类：</span><br><span class="line">    抽象方法（包含）</span><br><span class="line">    成员变量（可包含，子类可以直接继承）</span><br><span class="line">    成员方法（可包含，子类可以直接继承，提高子类的功能）</span><br><span class="line">    常量（可包含，子类可以直接继承）</span><br><span class="line">    静态方法（可拥有，子类可以直接继承，抽象类的类名也可以直接调用）</span><br><span class="line">    构造方法（可包含，因为抽象类中可能包含成员变量，成员变量需要初始化和二次赋值）</span><br><span class="line">区别：</span><br><span class="line">    1、接口中不能定义构造器；抽象类中可以定义构造器</span><br><span class="line">    2、接口中方法全部都是抽象方法；抽象类中可以有抽象方法和具体方法</span><br><span class="line">    3、接口中的成员都是 public 的；抽象类中的成员可以是 private、默认、protected、public</span><br><span class="line">    4、接口中定义的成员变量实际上都是常量；抽象类中可以定义成员变量</span><br><span class="line">    5、接口中不能有静态方法；抽象类中可以包含静态方法</span><br><span class="line">    6、一个类可以实现多个接口；一个类只能继承一个抽象类</span><br></pre></td></tr></table></figure></div>

<h2 id="8、Java异常体系是什么-运行时异常和检查-编译-异常有什么区别？常见的运行时异常有哪些？"><a href="#8、Java异常体系是什么-运行时异常和检查-编译-异常有什么区别？常见的运行时异常有哪些？" class="headerlink" title="8、Java异常体系是什么? 运行时异常和检查(编译)异常有什么区别？常见的运行时异常有哪些？"></a>8、Java异常体系是什么? 运行时异常和检查(编译)异常有什么区别？常见的运行时异常有哪些？</h2><p>异常体系：<br>            Thorwable类是所以异常和错误的父类<br>            两个直接子类为 Error和 Exception ，分别表示错误和异常。<br>            其中异常类 Exception 又分为运行时异常和编译时异常<br>        运行时异常和检查(编译)异常的区别：<br>            编译时异常：<br>                是Java要求必须处理的，如果程序在编译时期未处理，该程序编译时就会发生错误无法编译，try…catch或throw抛出。<br>            运行时异常：<br>                是代码在运行是才会出现的异常，编译时不需要try…catch。<br>                如：除数是0，数组角标越界，其产生频繁，处理麻烦，若显示声明或者捕获将会对程序的可读性和运行效率影响很大。<br>                    所以由系统自动检测并将它们交给缺少的异常处理程序。如果有处理要求也可显示捕获。</p>
<h2 id="9、-x3D-x3D-和-equals的异同？"><a href="#9、-x3D-x3D-和-equals的异同？" class="headerlink" title="9、&#x3D;&#x3D; 和 equals的异同？"></a>9、&#x3D;&#x3D; 和 equals的异同？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">==：</span><br><span class="line">			== 是运算符，如果比较的对象是基本数据类型，则比较的是数值是否相等；</span><br><span class="line">			如果比较的是引用数据类型，则比较的是对象的地址值</span><br><span class="line">equals：</span><br><span class="line">			equals 是方法，用来比较两个对象的内容是否相等</span><br><span class="line">			equals 方法不能用于基本数据类型的变量，如果没有对 equals 方法进行重写，</span><br><span class="line">			则比较的是引用类型的变量所指向的对象的地址值</span><br></pre></td></tr></table></figure></div>

<h2 id="10、-amp-与-amp-amp-、-与-的区别？"><a href="#10、-amp-与-amp-amp-、-与-的区别？" class="headerlink" title="10、&amp;与&amp;&amp;、|与||的区别？"></a>10、&amp;与&amp;&amp;、|与||的区别？</h2><p>&amp;：左右两边的布尔值都是true，整个表达式的值才是true<br>        &amp;&amp;：如果左边的表达式的值为false，右边的表达式会被直接短路掉，不会进行运算，整个表达式的值就是false<br>        |：左右两边的布尔值只要有一个为true，整个表达式的值就是true<br>        ||：如果左边的表达式的值为true，右边的表达式会被直接短路掉，不会进行运算，整个表达式的值就是true</p>
<h2 id="11、String可以修改本身吗？为什么？"><a href="#11、String可以修改本身吗？为什么？" class="headerlink" title="11、String可以修改本身吗？为什么？"></a>11、String可以修改本身吗？为什么？</h2><p>不可以<br>        字符串内部其实就是一个使用final关键字定义的char[]数组，数组长度一档声明则不可改变<br>        字符串一旦声明则不可改变，变的只是引用变量所指向的对象</p>
<h2 id="12、StringBuffer和StringBuilder的区别是什么？"><a href="#12、StringBuffer和StringBuilder的区别是什么？" class="headerlink" title="12、StringBuffer和StringBuilder的区别是什么？"></a>12、StringBuffer和StringBuilder的区别是什么？</h2><p>StringBuilder实在单线程环境下使用的，因为它的使用方法都没有被 synchronized 修饰，因此理论上它的效率比 StringBuffer 高</p>
<h2 id="13、valueOf和toString的区别？"><a href="#13、valueOf和toString的区别？" class="headerlink" title="13、valueOf和toString的区别？"></a>13、valueOf和toString的区别？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">toString：变换的值是 null 的情况，则会抛出 NullPointerException 异常</span><br><span class="line">valueOf：会首先对转换的对象进行非空判断，如果为 null 则返回 &quot;null&quot; 字符串，</span><br><span class="line">以至于不抛出 NullPointerException 异常</span><br></pre></td></tr></table></figure></div>

<h2 id="14、大量字符串用-“-”-号进行拼接效率高吗？为什么？应该用什么替代？为什么？"><a href="#14、大量字符串用-“-”-号进行拼接效率高吗？为什么？应该用什么替代？为什么？" class="headerlink" title="14、大量字符串用 “+” 号进行拼接效率高吗？为什么？应该用什么替代？为什么？"></a>14、大量字符串用 “+” 号进行拼接效率高吗？为什么？应该用什么替代？为什么？</h2><p>不高<br>        大量字符串用 “+” 号进行拼接，每次拼接一次都会创建一个 StringBuilder 对象，时间和空间开销太大<br>        大量字符串拼接可以使用 StringBuilder 中的 append() 方法代替<br>        append( )方法其实是创建了一个新的数组，扩大了长度，将需要添加的字符串给复制到这个新的数组中</p>
<h2 id="15、创建一个类的实例都有哪些办法？"><a href="#15、创建一个类的实例都有哪些办法？" class="headerlink" title="15、创建一个类的实例都有哪些办法？"></a>15、创建一个类的实例都有哪些办法？</h2><p>1、new 关键字。工厂模式是对这种方式的包装<br>        2、类实现克隆接口，克隆一个实例<br>        3、用该类的加载器，newinstance()方法。反射，反射使用实例：Spring的依赖注入、切面编程中的动态代理<br>        4、sun.misc。Unsafe类，allocateInstance()方法创建一个实例<br>        5、实现序列化接口的类，通过IO流反序列化读取一个类，获得实例</p>
<h2 id="16、Java集合的体系是什么样的？"><a href="#16、Java集合的体系是什么样的？" class="headerlink" title="16、Java集合的体系是什么样的？"></a>16、Java集合的体系是什么样的？</h2><p>Java集合的体系分为两大部分：Collection 和 Map<br>        Collection 接口下常见的子类有 List、Set 接口<br>            List 接口下有 ArrayList、LinkedList 等实现类<br>            Set 接口下有 HashSet、LinkedHashSet、TreeSet 等实现类<br>        Map 接口下有 HashMap、TreeMap、Hashtable 等实现类</p>
<h2 id="17、Set和List分别有哪些特点？Set去重的原理？"><a href="#17、Set和List分别有哪些特点？Set去重的原理？" class="headerlink" title="17、Set和List分别有哪些特点？Set去重的原理？"></a>17、Set和List分别有哪些特点？Set去重的原理？</h2><p>List 中存储的数据是有顺序，并且允许重复；Set 中存储的数据是无序的，且不允许有重复<br>        Set的去重是通过 hash 和 eq 结合实现的<br>            当两个变量的哈希值不相同时，就认为这两个变量不同<br>            当两个变量哈希值一样时，调用 eq 方法，放返回值为 true 时，去除一个；返回 false 时，不去重</p>
<h2 id="18、ArrayList底层原理是什么？扩容原理？"><a href="#18、ArrayList底层原理是什么？扩容原理？" class="headerlink" title="18、ArrayList底层原理是什么？扩容原理？"></a>18、ArrayList底层原理是什么？扩容原理？</h2><p>构造方法：<br>            空参构造：new 一个空参 ArrayList 的时候，系统内部使用了一个 new Object[0]数组<br>            带参构造1：传入一个 int 值，该值作为数组的长度值。如果该值小于0，则抛出一个运行时异常。<br>                       如果等于0，则使用一个空数组。如果大于0，则创建一个长度为该值的新数组<br>            带参构造2：如果调用构造方法时传入了一个 Collection 的子类，那么先判断该集合是否为null，为null则抛出空指针异常。<br>                       如果不是null则将该集合转为数组a，然后将该数组赋值为成员变量array，将该数组的长度作为成员变量size。<br>        add 方法：<br>            1、首先将成员变量 array 赋值给局部变量 a，将成员变量 size 赋值给局部变量 s<br>            2、判断集合长度 s 是否等于数组的长度（如果集合的长度已经等于数组的长度了，说明数组已满，该重新分配新数组了），<br>               重新分配数组的时候需要计算新分配内存的空间大小，如果当前的长度小于 MIN_CAPACITY_INCREMENT&#x2F;2 ，<br>               （这个常量值是12，除以2就是6，也就是如果当前集合长度小于6）则分配12个长度，如果集合长度大于6则分配当前长度s的一半<br>            3、将新添加的 object 对象作为数组的 a[s] 个元素<br>            4、修改集合长度 size 为 s+1<br>            5、modCotun++，该变量是父类中声明的，用于记录集合修改的次数，<br>               记录集合修改的次数是为了在用迭代器迭代集合时避免并发修改异常，或者说用于判断是否出现并发修改异常的<br>            6、return true，这个返回值意义不大，因为一直返回true，除非报了一个运行时异常<br>        remove 方法：<br>            1、先将成员变量 array 和 size 赋值给局部变量 a 和 s<br>            2、判断形参 index 是否大于等于集合的长度，如果成立则抛出运行时异常<br>            3、获取数组中角标为 index 的对象 result，该对象作为方法的返回值<br>            4、调用 System 的 arraycopy 方法，将删除的元素后面的所有元素全部往前移一位<br>            5、因为删了一个元素，而且集合整体向前移动了一位，因此要将集合最后一个元素置为 null，否则就会内存泄漏<br>            6、重新给成员变量 array 和 size 赋值<br>            7、记录修改次数<br>            8、返回删除的元素<br>        clear 方法：<br>            如果集合长度不等于0，则将数组所有的值都为 null，然后将成员变量 size 设置为0，最后将修改记录加1</p>
<h2 id="19、LinkedList底层原理是什么？和ArrayList的区别是什么？"><a href="#19、LinkedList底层原理是什么？和ArrayList的区别是什么？" class="headerlink" title="19、LinkedList底层原理是什么？和ArrayList的区别是什么？"></a>19、LinkedList底层原理是什么？和ArrayList的区别是什么？</h2><p>LinkedList底层原理：<br>            LinkedList 的底层是通过双向链表实现的。<br>            链表的单元是节点，链表由多个节点构成，每个节点都包含三个部分，<br>            头节点指向上一个节点的尾节点，中间节点指向该节点，尾节点指向下一个节点的头节点<br>        和ArrayList的区别：<br>            1、数据结构实现：ArrayList是动态数组的数据结构实现；LinkedList是双向链表的数据结构实现<br>            2、随机访问效率：ArrayList比LinkedList在随机访问的时候效率要高，<br>                             因为LinkedList是线性的数据存储方式，使用需要移动指针从前向后一次查找<br>            3、增加和删除效率：在非首尾的增删操作，LinkedList要比ArarryList的效率高，因为ArrayList增删操作要影响数组内其他数据的角标<br>            综合来说，在需要频繁读取集中的元素时，更推荐使用ArrayList，而在增删操作比较多时，更加推荐使用LinkedList</p>
<h2 id="20、HashMap的底层原理是什么？扩容原理？"><a href="#20、HashMap的底层原理是什么？扩容原理？" class="headerlink" title="20、HashMap的底层原理是什么？扩容原理？"></a>20、HashMap的底层原理是什么？扩容原理？</h2><p>HashMap的底层采用了一个数组，该数组的默认大小为16且每一个元素都是一个链表的头节点，<br>        每当添加一个元素，就先计算元素Key的hash值，以此确定存放在数组的位置，<br>        如果出现了同一hash值的元素时，这时新元素就会挂在老元素的下面，形成链表，<br>        当链表的长度太长，大于8时，链表就会转换为红黑树，就能提高查找的效率<br>        扩容阈值：<br>            当前容量 * 加载因子 &#x3D; 阈值，默认的加载因子为0.75<br>        扩容的机制：<br>            当数组中的元素达到阈值时，第一次扩容即16 * 0.75 &#x3D; 12时，就会触发扩容机制，扩大到元素组的2倍<br>        加载因子：<br>            - 加载因子的大小决定了HashMap的数据密度。<br>            - 加载因子越大HashMap的数据密度也大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入的次数增多，性能下降。<br>            - 加载因子越小，就越容易触发扩容，数据密度也就越小，发生碰撞的几率越小，数组中的链表就越短，查询和插入时比较的次数也越小，<br>              性能会更高，但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预留大一点的空间。<br>            - 所以会将加载因子设置为0.7-0.75，此时平均检索长度接近于常数。</p>
<h2 id="21、concurrentHashMap原理是什么？"><a href="#21、concurrentHashMap原理是什么？" class="headerlink" title="21、concurrentHashMap原理是什么？"></a>21、concurrentHashMap原理是什么？</h2><p>底层采用分段的数组+链表实现，线程安全<br>        通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。<br>        Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术<br>        有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁<br>        扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容</p>
<h2 id="22、JDK8对于HashMap做了哪些优化？"><a href="#22、JDK8对于HashMap做了哪些优化？" class="headerlink" title="22、JDK8对于HashMap做了哪些优化？"></a>22、JDK8对于HashMap做了哪些优化？</h2><p>JDK8之前采用的是数组加链表，JDK8之后采用的是数据加链表加红黑树</p>
<h2 id="23、什么是socket？什么是IO-x2F-NIO-x2F-BIO-x2F-AIO？区别是什么？"><a href="#23、什么是socket？什么是IO-x2F-NIO-x2F-BIO-x2F-AIO？区别是什么？" class="headerlink" title="23、什么是socket？什么是IO&#x2F;NIO&#x2F;BIO&#x2F;AIO？区别是什么？"></a>23、什么是socket？什么是IO&#x2F;NIO&#x2F;BIO&#x2F;AIO？区别是什么？</h2><p>socket：<br>            socket是一个接口，在用户进程与TCP&#x2F;IP协议之间充当中间人，完成TCP&#x2F;IP协议的书写<br>        IO：<br>            在Java中，用流的方式完成IO。<br>            所有IO都被视为单个的字节的移动，通过一个称为Stream的对象一次移动一个字节。<br>            流I&#x2F;O用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。<br>        NIO：<br>             NIO不需要为每个连接开启一个线程，而是统一由Selector管理，当连接没有IO操作时，不需要阻塞线程等待数据，<br>             只有当Selector检测到呢个Channel有有效的IO请求时，再为其开启线程操作，节省线程的开销，操作结束后返回结果，故为同步非阻塞。<br>        BIO：<br>            在BIO通信模式下，服务端每收到一个链接（socket），就会创建专门的线程（serverssocket）响应该连接。<br>            这个连接会一直存在等待读取发来的数据，这个过程会阻塞搜在线程，不能做别的事，直到操作结束后返回结果值，因此这是同步阻塞。<br>            BIO模式下，服务端连接多个客户端时，会开启多个线程响应连接。<br>        AIO：<br>            没有线程阻塞，与AIO不同的是NIO会主动轮询操作系统数据是否准备完毕，而AIO则是等待系统主动通知，再去读取数据</p>
<h2 id="24、什么是反射？可以用来干嘛？列举一下反射应用场景？什么是暴力反射？"><a href="#24、什么是反射？可以用来干嘛？列举一下反射应用场景？什么是暴力反射？" class="headerlink" title="24、什么是反射？可以用来干嘛？列举一下反射应用场景？什么是暴力反射？"></a>24、什么是反射？可以用来干嘛？列举一下反射应用场景？什么是暴力反射？</h2><p>反射：<br>            反射的核心是 JVM 在运行时才动态加载类或调用方法&#x2F;访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁<br>            Java 中的反射首先是能够获取到 Java 中要反射类的字节码，获取字节码有三种方法：<br>            1、Class.forName(className)        2、类名.class    3、this.getClass()<br>            然后将字节码中的方法，变量，构造函数等映射成相应的Method，Filed，Constructor等类，这些类中提供了丰富的方法供使用<br>        反射的作用：<br>            1、在运行时判定任意一个对象的所属类<br>            2、在运行时构造任意一个类的对象<br>            3、在运行时判定任意一个类所有具有的成员变量和方法<br>            4、在运行时调用任意一个对象的方法<br>            5、生成动态代理<br>        应用场景：<br>            反射最重要的用途就是开发各种通用框架。<br>            很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，<br>            它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。<br>        暴力反射：<br>            反射里的Constructor,Field,Method三个类都有一个 getDeclaredXxx 方法,<br>            可以不受权限控制的获取类的构造函数,字段,方法,如果想要私有构造函数创建对象,字段赋值,方法调用的话,<br>            会自动的访问类的isAccessable,默认的是false,<br>            所以,想要访问类中的私有成员的时候,就要调用setAccessable()方法,将其改为true,这样,就可以对类中的私有成员进行操作了</p>
<h2 id="25、算法了解过吗？冒泡排序、选择排序、快排原理？"><a href="#25、算法了解过吗？冒泡排序、选择排序、快排原理？" class="headerlink" title="25、算法了解过吗？冒泡排序、选择排序、快排原理？"></a>25、算法了解过吗？冒泡排序、选择排序、快排原理？</h2><p>冒泡排序：<br>            1、比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>            2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>            3、针对所有的元素重复以上的步骤，除了最后一个；<br>            4、重复步骤1~3，直到排序完成。<br>        选择排序：<br>            首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，<br>            然后，再从剩余未排序元素中继续寻找最小(大)元素，再放到已排序序列的末尾。<br>            以此类推，直到所有元素均排序完毕<br>        快速排序：<br>            1、从数列中挑出一个元素，称为 “基准”(pivot)；<br>            2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。<br>               在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作；<br>            3、递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<h2 id="26、JDK1-8的新特性有哪些-lamda表达式、stream流、函数式接口、接口中默认方法、方法引用等等"><a href="#26、JDK1-8的新特性有哪些-lamda表达式、stream流、函数式接口、接口中默认方法、方法引用等等" class="headerlink" title="26、JDK1.8的新特性有哪些?(lamda表达式、stream流、函数式接口、接口中默认方法、方法引用等等)"></a>26、JDK1.8的新特性有哪些?(lamda表达式、stream流、函数式接口、接口中默认方法、方法引用等等)</h2><p>Lambda表达式，函数式接口，方法引用和构造器调用，Stream API，接口中的默认方法和静态方法，新时间日期API</p>
<h2 id="27、IO流体系"><a href="#27、IO流体系" class="headerlink" title="27、IO流体系"></a>27、IO流体系</h2><p>1、按流向分：<br>            输入流：程序可以从内存中读取数据的流<br>            输出流：程序可以向磁盘中写入数据的流<br>        2、按数据传输单位分：<br>            字节流：以字节为单位传输数据的流<br>            字符流：以字符为单位传输数据的流</p>
<h2 id="28、如何实现分布式主键自增？"><a href="#28、如何实现分布式主键自增？" class="headerlink" title="28、如何实现分布式主键自增？"></a>28、如何实现分布式主键自增？</h2><p>Redis和IdWork工具类</p>
<h1 id="二、JVM"><a href="#二、JVM" class="headerlink" title="二、JVM"></a>二、JVM</h1><h2 id="1、JDK和JRE的区别是什么？"><a href="#1、JDK和JRE的区别是什么？" class="headerlink" title="1、JDK和JRE的区别是什么？"></a>1、JDK和JRE的区别是什么？</h2><p>JDK：开发工具<br>JRE：运行时环境</p>
<h2 id="2、JVM内存模型是什么样的？"><a href="#2、JVM内存模型是什么样的？" class="headerlink" title="2、JVM内存模型是什么样的？"></a>2、JVM内存模型是什么样的？</h2><p>1、线程隔离私有数据区<br>            1、程序计数器<br>            2、栈<br>                1、线程栈<br>                2、本地方法栈<br>        2、线程数据共享区<br>            1、堆<br>                1、新生代区<br>                2、老年代区<br>            2、方法区</p>
<h2 id="3、JVM双亲委派加载机制，为什么JVM这么做？有违反双亲委派的例子吗？"><a href="#3、JVM双亲委派加载机制，为什么JVM这么做？有违反双亲委派的例子吗？" class="headerlink" title="3、JVM双亲委派加载机制，为什么JVM这么做？有违反双亲委派的例子吗？"></a>3、JVM双亲委派加载机制，为什么JVM这么做？有违反双亲委派的例子吗？</h2><p>双亲委派加载机制：<br>            加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，<br>            如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类<br>        为什么JVM这么做：<br>            1、可以防止核心API库被随意篡改<br>            2、避免类的重复加载：当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次，保证被加载类的唯一性<br>        违反双亲委派的例子：<br>            服务供应商接口 SPI，常见的 SPI 有 JDBC、JNDI、JAXP 等</p>
<h2 id="4、类的加载流程是什么样的，每个阶段解释一下"><a href="#4、类的加载流程是什么样的，每个阶段解释一下" class="headerlink" title="4、类的加载流程是什么样的，每个阶段解释一下"></a>4、类的加载流程是什么样的，每个阶段解释一下</h2><p>1、加载：<br>            通过一个类的全限定名获取该类的二进制流；<br>            将该二进制流的静态存储结构转化为方法区运行时数据结构；<br>            在内存中生成该类的Class对象，作为该类的数据访问入口；<br>        2、链接:<br>            验证：验证的目的是为了确保Class文件的字节流中的信息不会危害到虚拟机；<br>            准备：准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。<br>                  准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<br>            解析：主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。<br>        3、初始化：<br>            初始化是类加载的最后一步，真正开始执行类中定义的Java程序代码</p>
<h2 id="5、JVM的GC的主要区域以及各自的GC机制是什么样的？"><a href="#5、JVM的GC的主要区域以及各自的GC机制是什么样的？" class="headerlink" title="5、JVM的GC的主要区域以及各自的GC机制是什么样的？"></a>5、JVM的GC的主要区域以及各自的GC机制是什么样的？</h2><p>GC的主要区域：<br>            堆内存<br>        各自的GC机制：<br>            新生代区：Minor GC<br>                1、当Eden区满了时，触发一次MG，即：<br>                    还存活的对象从Eden或者Survivor From&#x2F;Survivor To区中用copy复制算法移至Survivor To&#x2F;Survivor From区中<br>                    Eden中剩下的待回收的对象进行回收，且存活对象的MG次数+1，当对象上的MG次数大于15次时，该对象将会移至老年代区<br>                2、JVM每次只会使用Eden和其中的一块Suivivor区域来为对象服务，所以无论什么时候，总是有一块Survivor区域是空闲的<br>                   因此，新生代实际可用的内存空间为90%的新生代空间，所以这种回收机制是比较浪费内存的，优点是简单高效<br>            老年代区：Full GC<br>                当老年代没有内存空间容纳新进来的对象时，触发一次FG，即：<br>                    1、首先stop the world：暂停GC回收线程外的所有线程；<br>                    2、然后使用标记-清除&#x2F;整理算法，标记出</p>
<h2 id="6、JVM的GC算法都有哪些？"><a href="#6、JVM的GC算法都有哪些？" class="headerlink" title="6、JVM的GC算法都有哪些？"></a>6、JVM的GC算法都有哪些？</h2><p>1、确定哪些是垃圾的算法：<br>            1、引用计数法：<br>                每被引用一次，引用次数+1， 弊端：无法解决对象相互循环引用而无法被回收问题<br>            2、GC Root可达性算法：<br>                从根节点出发，给所有可达对象做标记（解决对象相互循环引用而无法被回收问题）<br>                Java中可作为GC Root的对象有：<br>                    1、虚拟机栈中引用的对象（本地变量表）<br>                    2、方法区中静态属性引用的对象<br>                    3、方法区中常量引用的对象<br>                    4、本地方法栈中引用的对象（Native对象）<br>        2、最终回收垃圾的算法<br>            1、标记-清除：效率较高，但最后得到的内存空间不连续<br>            2、标记-整理：最后得到的内存空间是连续的，但整理压缩耗费性能，效率较低<br>            3、复制算法：将内存空间分为两块，每次只使用其中的一块，回收时，将存活的对象复制到另一块中，简单高效，但是浪费内存空间<br>            针对以上的回收算法的利弊，引出分代算法，新生代区使用复制算法，老年代区使用标记-清除&#x2F;标记-整理算法</p>
<h1 id="三、Spring-amp-SpringBoot"><a href="#三、Spring-amp-SpringBoot" class="headerlink" title="三、Spring &amp; SpringBoot"></a>三、Spring &amp; SpringBoot</h1><h2 id="1、说下对SpringIOC的理解，怎么理解控制反转？IOC容器中Bean的生命周期？"><a href="#1、说下对SpringIOC的理解，怎么理解控制反转？IOC容器中Bean的生命周期？" class="headerlink" title="1、说下对SpringIOC的理解，怎么理解控制反转？IOC容器中Bean的生命周期？"></a>1、说下对SpringIOC的理解，怎么理解控制反转？IOC容器中Bean的生命周期？</h2><p>IOC：<br>            是spring的核心，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在对象内部直接控制<br>        控制反转：<br>            所有的类都会在spring容器中登记，告诉spring你是什么，你需要什么，然后spring会在系统运行到适当的时候，把你要的东西主动给你，<br>            同时也把你交给其他需要你的东西。<br>            所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。<br>            对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转<br>        生命周期：<br>            1、通过构造器或工厂方法创建Bean的实例<br>            2、为Bean的属性赋值或对其他Bean的引用<br>            3、调用Bean的初始化方法<br>            4、使用Bean<br>            5、当容器关闭时，调用Bean的销毁方法</p>
<h2 id="2、Spring如何解决IOC中的循环依赖问题？"><a href="#2、Spring如何解决IOC中的循环依赖问题？" class="headerlink" title="2、Spring如何解决IOC中的循环依赖问题？"></a>2、Spring如何解决IOC中的循环依赖问题？</h2><p>三级缓存。<br>        比如说：<br>            实例化A的时候，先将A创建（早期对象）放入一个池子中。<br>            这个时候虽然属性没有赋值，但是容器已经能认识这个是A对象，只是属性全是null而已。在<br>            populateBean 方法中对属性赋值的时候，发现A依赖了B，那么就先去创建B了，又走一遍bean的创建过程（创建B）。<br>            同样也会把B的早期对象放入缓存中。<br>            当B又走到 populateBean 方法的时候，发现依赖了A，<br>            又去创建A，但是这个时候去创建A，发现我们在缓存能找到A（早期对象）。<br>            就可以把B的A属性赋值了，这个时候B就初始化完成了。<br>            现在回到A调用的populateBean方法中。<br>            返回的就是B对象了，对A的B属性进行赋值就可以了。</p>
<h2 id="3、说下对SpringAOP的理解、有哪些通知？使用场景有哪些？（底层原理：两种动态代理）"><a href="#3、说下对SpringAOP的理解、有哪些通知？使用场景有哪些？（底层原理：两种动态代理）" class="headerlink" title="3、说下对SpringAOP的理解、有哪些通知？使用场景有哪些？（底层原理：两种动态代理）"></a>3、说下对SpringAOP的理解、有哪些通知？使用场景有哪些？（底层原理：两种动态代理）</h2><p>AOP 面向切面编程：<br>            将与业务无关，却为业务模块所共同调用的逻辑封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于可操作性和可维护性<br>        有哪些通知：<br>            1、前置通知：在目标方法执行之前执行执行的通知<br>            2、环绕通知：在目标方法执行之前和之后都可以执行额外代码的通知<br>            3、后置通知：在目标方法执行之后执行的通知<br>            4、异常通知：在目标方法抛出异常时执行的通知<br>            5、最终通知：最终通知无论如何都会在目标方法调用过后执行，即使目标方法没有正常的执行完成<br>        使用场景有哪些：<br>            事务、日志、缓存</p>
<h2 id="4、说下SpringMvc的流程（从访问一个URL到得到页面结果的具体流程：DispatcherServlet的职责流程）"><a href="#4、说下SpringMvc的流程（从访问一个URL到得到页面结果的具体流程：DispatcherServlet的职责流程）" class="headerlink" title="4、说下SpringMvc的流程（从访问一个URL到得到页面结果的具体流程：DispatcherServlet的职责流程）"></a>4、说下SpringMvc的流程（从访问一个URL到得到页面结果的具体流程：DispatcherServlet的职责流程）</h2><p>1、用户发送请求至前端控制器DispatcherServlet<br>        2、前端控制器DispatcherServlet收到请求调用HandlerMapping处理器映射器<br>        3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)，一并返回给DispatcherServlet<br>        4、DispatcherServlet调用HandlerAdapter处理器适配器<br>        5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)<br>        6、Controller执行完成返回ModelAndView<br>        7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet<br>        8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器<br>        9、ViewReslover解析后返回具体View<br>        10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）<br>        11、DispatcherServlet响应用户</p>
<h2 id="5、对Spring声明式事务的理解？Spring的事务隔离级别？Spring事务传播行为？"><a href="#5、对Spring声明式事务的理解？Spring的事务隔离级别？Spring事务传播行为？" class="headerlink" title="5、对Spring声明式事务的理解？Spring的事务隔离级别？Spring事务传播行为？"></a>5、对Spring声明式事务的理解？Spring的事务隔离级别？Spring事务传播行为？</h2><p>理解：<br>            Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的<br>        Spring的事务隔离级别：<br>            默认、读未提交、读已提交、可重复读、串行化<br>        Spring事务传播行为：<br>            1、required（默认属性）<br>                如果存在一个事务，则支持当前事务，如果没有事务，则开启一个新的事务<br>            2、Mandatory<br>                支持当前事务，如果当前没有事务，就抛出异常<br>            3、Never<br>                以非事务方式执行，如果当前存在事务，则抛出异常<br>            4、Not_supports<br>                以非事务方式执行操作，如果当前存在事务，把当前事务挂起<br>            5、requires_new<br>                新建事务，如果当前存在事务，则把当前事务挂起<br>            6、Supports<br>                支持当前事务，如果当前没有事务，就以非事务方式执行<br>            7、Nested<br>                支持当前事务，新增Savepoint点，与当前事务同步提交或者回滚</p>
<h2 id="6、什么情况下会让spring事务失效"><a href="#6、什么情况下会让spring事务失效" class="headerlink" title="6、什么情况下会让spring事务失效"></a>6、什么情况下会让spring事务失效</h2><p>1、发生自调用，类里面使用this调用本类中的方法，此时这个this不是代理对象，所以事务失效<br>        2、方法不是public的<br>        3、数据库不支持事务<br>        4、没有被spring管理<br>        5、异常被try、catch，事务不会回滚</p>
<h2 id="7、Spring有哪些核心注解？分别的作用？"><a href="#7、Spring有哪些核心注解？分别的作用？" class="headerlink" title="7、Spring有哪些核心注解？分别的作用？"></a>7、Spring有哪些核心注解？分别的作用？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller：Web控制器模式注解</span><br><span class="line">@Service：服务模式注解</span><br><span class="line">@Configuration：配置类模式注解</span><br><span class="line">@Component：通用组件模式注解</span><br><span class="line">@Autowired：    Bean依赖注入，支持多种依赖查找方式</span><br><span class="line">@Bean：替换XML元素&lt;bean/&gt;</span><br><span class="line">@Import：限定@Autowired依赖注入范围(导入对应的 @Configuration 标识类)</span><br><span class="line">@ComponentScan：扫描制定package下标注Spring模式注解的类</span><br></pre></td></tr></table></figure></div>

<h2 id="8、Spring和SpringBoot的关系？"><a href="#8、Spring和SpringBoot的关系？" class="headerlink" title="8、Spring和SpringBoot的关系？"></a>8、Spring和SpringBoot的关系？</h2><p>Spring Boot不是一门新技术。从本质上来说，Spring Boot就是Spring，它做了一些对Spring Bean的默认配置。<br>        它消除了设置 Spring 应用程序所需的 XML配置，为更快，更高效的开发生态系统铺平了道路。</p>
<h2 id="9、SpringBoot的自动装配原理是什么？"><a href="#9、SpringBoot的自动装配原理是什么？" class="headerlink" title="9、SpringBoot的自动装配原理是什么？"></a>9、SpringBoot的自动装配原理是什么？</h2><p>@EnableAutoConfiguration 这个注解通过 @springbootapplication 这个注解被间接的标记在了springboot的启动类上，<br>        在springapplication.run(…)的内部就会执行selectimports()方法，<br>        找到所有javaconfig自动配置类的全限定类名对应的class，然后将所有的自动配置类加载到spring容器中</p>
<h2 id="10、SpringBoot的核心注解是哪个？详细说下"><a href="#10、SpringBoot的核心注解是哪个？详细说下" class="headerlink" title="10、SpringBoot的核心注解是哪个？详细说下"></a>10、SpringBoot的核心注解是哪个？详细说下</h2><p>核心注解是@SpringBootApplication，它主要由 @SpringBootConfiguration，@EnableAutoConfiguration、@ComponentScan 这三个构成<br>            @SpringBootConfiguration：<br>                里面就只有一个 @Configuration 主要注解，也就是把该类变成一个配置类所以 @SpringBootConfiguration 就相当于 @Configuration<br>            @EnableAutoConfiguration：<br>                是由 @AutoConfigurationPackage 和 @Import(EnableAutoConfigurationImportSelector.class) 这两个组成的<br>                    @AutoConfigurationPackage ：<br>                        是自动配置包，包括了一个@Import注解，给容器导入了自动配置包的注册器<br>                        AutoConfigurationPackages.Registrar.class：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器<br>                    @Import(AutoConfigurationImportSelector.class)：<br>                        导入自动配置导入选择器组件<br>                        AutoConfigurationImportSelector.class：自动配置导入选择器，主要是从类路径下的META-INF&#x2F;spring.factories中获取资源<br>            @ComponentScan：扫描包，该注解默认会扫描该类所在的包下所有的配置类</p>
<h2 id="11、SpringBoot项目的启动加载流程大概说下"><a href="#11、SpringBoot项目的启动加载流程大概说下" class="headerlink" title="11、SpringBoot项目的启动加载流程大概说下"></a>11、SpringBoot项目的启动加载流程大概说下</h2><p>第一部分：<br>            SpringApplication初始化模块，配置一些基本的环境变量、资源、监听器、构造器<br>        第二部分：<br>            实现了应用具体的启动方案，包括流程的监听模块，加载配置环境模块以及上下文环境模块<br>        第三部分：<br>            自动化配置模块，这个模块是实现SpringBoot的自动装配</p>
<h2 id="12、SpringBoot项目读取配置文件的方式有几种？"><a href="#12、SpringBoot项目读取配置文件的方式有几种？" class="headerlink" title="12、SpringBoot项目读取配置文件的方式有几种？"></a>12、SpringBoot项目读取配置文件的方式有几种？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Value</span><br><span class="line">    @ConfigurationProperties</span><br></pre></td></tr></table></figure></div>

<h2 id="13、如何自定义SpringBoot-starter？"><a href="#13、如何自定义SpringBoot-starter？" class="headerlink" title="13、如何自定义SpringBoot starter？"></a>13、如何自定义SpringBoot starter？</h2><p>1、引入 SpringBoot 自动化配置依赖<br>        2、创建配置属性类<br>        3、创建 Starter 包的服务类<br>        4、创建自动配置类<br>        5、配置 spring.factories</p>
<h1 id="四、Mysql-amp-Mybatis？"><a href="#四、Mysql-amp-Mybatis？" class="headerlink" title="四、Mysql &amp; Mybatis？"></a>四、Mysql &amp; Mybatis？</h1><h2 id="1、什么是索引？"><a href="#1、什么是索引？" class="headerlink" title="1、什么是索引？"></a>1、什么是索引？</h2><p>本质是帮助MySQL高效获取数据的数据结构</p>
<h2 id="2、Mysql的数据结构是什么（mysql索引的数据结构）？为什么用这种结构？（如何提高磁盘IO效率）"><a href="#2、Mysql的数据结构是什么（mysql索引的数据结构）？为什么用这种结构？（如何提高磁盘IO效率）" class="headerlink" title="2、Mysql的数据结构是什么（mysql索引的数据结构）？为什么用这种结构？（如何提高磁盘IO效率）"></a>2、Mysql的数据结构是什么（mysql索引的数据结构）？为什么用这种结构？（如何提高磁盘IO效率）</h2><p>Mysql的数据结构：<br>            MySql中主要应用的索引数据结构为B+Tree<br>        为什么用这种结构：<br>            由于数据存储于物理磁盘，所以要尽量减少从磁盘IO数据的次数<br>            IO次数取决于B+Tree的高度<br>            B+Tree把真实的数据放到叶子节点，数据项占的空间越小，数据项的数量越多，树的高度越低</p>
<h2 id="3、Mysql的数据IO查找流程是什么样的？"><a href="#3、Mysql的数据IO查找流程是什么样的？" class="headerlink" title="3、Mysql的数据IO查找流程是什么样的？"></a>3、Mysql的数据IO查找流程是什么样的？</h2><p>1、对于聚集索引（主键索引）来说，也就是通过主键查询，一次查询就能查询到具体的行数据信息；<br>        2、对于非聚集索引来说（唯一索引、普通索引、全文索引），<br>        如果需要查询的数据列在索引中，如A+B联合索引，根据A去查询B，则通过一次查询就能直接拿到索引上的数据，也就是覆盖索引现象；<br>        如果需要查询的数据不在索引中，则需要先去普通索引树中进行第一次查找得到行数据的主键值，<br>        然后通过主键值去主键索引树中第二次搜索得到真实数据，这种需要二次查询的现象叫做回表查询</p>
<h2 id="4、B-tree和Btree由什么组成？他们的异同？"><a href="#4、B-tree和Btree由什么组成？他们的异同？" class="headerlink" title="4、B+tree和Btree由什么组成？他们的异同？"></a>4、B+tree和Btree由什么组成？他们的异同？</h2><p>异同：<br>            1、B+tree是Btree的变体<br>            2、在Btree的基础上增加了叶子节点的顺序访问指针，B+Tree提高了顺序访问的性能<br>            3、Btree每个节点的指针上限为2d+1，B+Tree每个节点的指针上限为2d<br>            4、B+Tree非叶子节点只存储索引值，叶子节点存储真实数据，Btree所有节点上都存储数据</p>
<h2 id="5、Mysql两种存储引擎（InnoDB和Mysiam）的区别？这两种引擎B-tree的叶子结点和非叶子结点分别存储的什么？"><a href="#5、Mysql两种存储引擎（InnoDB和Mysiam）的区别？这两种引擎B-tree的叶子结点和非叶子结点分别存储的什么？" class="headerlink" title="5、Mysql两种存储引擎（InnoDB和Mysiam）的区别？这两种引擎B+tree的叶子结点和非叶子结点分别存储的什么？"></a>5、Mysql两种存储引擎（InnoDB和Mysiam）的区别？这两种引擎B+tree的叶子结点和非叶子结点分别存储的什么？</h2><p>区别：<br>            1、InnoDB支持事务和外键，MySIAM不支持<br>            2、InnoDB支持行锁，MySIAM只支持表锁<br>            3、InnoDB的真实数据和索引都存储在同一个文件中，MMySIAM存储在两个文件中<br>            4、InnoDB不支持全文索引，MySIAM支持<br>        InnoDB：<br>            叶节点data域保存了完整的数据记录<br>        MySIAM：<br>            叶节点的data域存放的是数据记录的地址</p>
<h2 id="6、Mysql索引有哪些类型？什么场景使用哪种索引？"><a href="#6、Mysql索引有哪些类型？什么场景使用哪种索引？" class="headerlink" title="6、Mysql索引有哪些类型？什么场景使用哪种索引？"></a>6、Mysql索引有哪些类型？什么场景使用哪种索引？</h2><p>普通索引、唯一索引、主键索引、联合索引、全文索引</p>
<h2 id="7、如何进行Mysql优化？（sql优化层面和服务器优化层面）"><a href="#7、如何进行Mysql优化？（sql优化层面和服务器优化层面）" class="headerlink" title="7、如何进行Mysql优化？（sql优化层面和服务器优化层面）"></a>7、如何进行Mysql优化？（sql优化层面和服务器优化层面）</h2><p>SQL层面：<br>            1、尽量避免使用select *<br>            2、规范sql语句大小写，sql时有缓存的，避免每次都需要解析<br>            3、使用exsits代替in<br>            4、mysql sql解析执行过程是从右到左，from后面能过滤掉更多数据的基础表放在后面，where后面能过滤掉更多数据的查询条件放在后面<br>            5、查询条件中用相同类型去查询，比如避免数值列用字符串查询条件<br>            6、合理使用索引<br>            7、explain命令进行sql慢查询排查<br>        服务器优化层面：<br>            1、读写分离：主节点写，从节点读<br>            2、分库：根据业务或者其他维度把数据存放到不同数据库<br>            3、分表：<br>                1、水平分表：字段都一样，分多张表存放不同时间范围或不同维度的数据，如实时数据表、历史数据表<br>                2、垂直分表：将不同字段放在多张表，使用外键关联<br>            4、常用分库分表中间件：阿里的Cobar及开源社区基于Cobar维护的Mycat</p>
<h2 id="8、Sql调优你会从何入手（措施）？"><a href="#8、Sql调优你会从何入手（措施）？" class="headerlink" title="8、Sql调优你会从何入手（措施）？"></a>8、Sql调优你会从何入手（措施）？</h2><p>explain命令进行sql慢查询排查：<br>            1、id：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，id相同，执行顺序从上至下，id值越大，优先级越高，越先执行<br>            2、select_type：查询类型 SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT<br>                SIMPLE：表示简单杳询，其中不包括连接查询和子查询；<br>                PRIMARY：表示主查询，或者最外层的查询语句；<br>                SUBQUERY：子查询中的第一个SELECT语句；<br>                DERIVED：导出表的SELECT (FROM语句的子查询)；<br>                UNION：表示连接查询的第2个或后面的查询语句；<br>                UNION RESULT：连接查询的结果；<br>            3、table：正在访问哪个表<br>            4、partitions：匹配的分区<br>            5、type：访问的类型，效率从快到慢：<br>                NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;ref_or_null&gt;index_merge&gt;range&gt;index&gt;ALL<br>            6、possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到<br>            7、key：实际使用到的索引，如果为NULL，则没有使用索引<br>            8、key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度<br>            9、ref：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值<br>            10、rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数，这个数量越小越好<br>            11、filtered：查询的表行占表的百分比<br>            12、Extra：包含不适合在其它列中显示但十分重要的额外信息</p>
<h2 id="9、Mysql中如何合理使用索引？有哪些会使索引失效的情况？"><a href="#9、Mysql中如何合理使用索引？有哪些会使索引失效的情况？" class="headerlink" title="9、Mysql中如何合理使用索引？有哪些会使索引失效的情况？"></a>9、Mysql中如何合理使用索引？有哪些会使索引失效的情况？</h2><p>何合理使用索引<br>            1、为合适的列添加索引(主键、唯一索引、组合索引)<br>            2、尽量建立联合索引，也省空间成本<br>            3、尽量使用覆盖索引<br>            4、避免会使索引失效的操作<br>        会使索引失效的情况：<br>            1、索引列有null值不走索引<br>            2、使用is null或is not null不走索引<br>            3、各种负向查询not ，not in， not like ，&lt;&gt; ,!&#x3D; ,!&gt; ,!&lt;  不会使用索引<br>            4、like将%放左边不走索引<br>            5、查询条件的数据类型做了隐式转换<br>            6、使用in或union代替or，or两侧有非索引列就不会走索引<br>            7、尽量保持索引列干净，不在索引列上使用函数转换、运算<br>            8、联合索引要遵循最左匹配原则<br>            9、使用比较运算或between会使联合索引从使用比较运算的下一个索引处断开</p>
<h2 id="10、Mysql如何排查慢查询（哪个关键字）？分别会列出来哪些信息项？"><a href="#10、Mysql如何排查慢查询（哪个关键字）？分别会列出来哪些信息项？" class="headerlink" title="10、Mysql如何排查慢查询（哪个关键字）？分别会列出来哪些信息项？"></a>10、Mysql如何排查慢查询（哪个关键字）？分别会列出来哪些信息项？</h2><p>explain命令进行sql慢查询排查：<br>            1、id：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，id相同，执行顺序从上至下，id值越大，优先级越高，越先执行<br>            2、select_type：查询类型 SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT<br>                SIMPLE：表示简单杳询，其中不包括连接查询和子查询；<br>                PRIMARY：表示主查询，或者最外层的查询语句；<br>                SUBQUERY：子查询中的第一个SELECT语句；<br>                DERIVED：导出表的SELECT (FROM语句的子查询)；<br>                UNION：表示连接查询的第2个或后面的查询语句；<br>                UNION RESULT：连接查询的结果；<br>            3、table：正在访问哪个表<br>            4、partitions：匹配的分区<br>            5、type：访问的类型，效率从快到慢：<br>                NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;ref_or_null&gt;index_merge&gt;range&gt;index&gt;ALL<br>            6、possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到<br>            7、key：实际使用到的索引，如果为NULL，则没有使用索引<br>            8、key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度<br>            9、ref：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值<br>            10、rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数，这个数量越小越好<br>            11、filtered：查询的表行占表的百分比<br>            12、Extra：包含不适合在其它列中显示但十分重要的额外信息</p>
<h2 id="11、事务的特性是什么？Mysql事务隔离级别有哪几种？分别会产生什么问题？Mysql默认隔离级别是什么？Oracle呢？"><a href="#11、事务的特性是什么？Mysql事务隔离级别有哪几种？分别会产生什么问题？Mysql默认隔离级别是什么？Oracle呢？" class="headerlink" title="11、事务的特性是什么？Mysql事务隔离级别有哪几种？分别会产生什么问题？Mysql默认隔离级别是什么？Oracle呢？"></a>11、事务的特性是什么？Mysql事务隔离级别有哪几种？分别会产生什么问题？Mysql默认隔离级别是什么？Oracle呢？</h2><p>事务的特性：<br>            原子性、一致性、隔离性、永久性<br>        Mysql事务隔离级别：<br>            读未提交、不可重复读、可重复读、串行化<br>        分别会产生什么问题：<br>            读未提交：一个事物读到了另一个事务尚未提交的数据，不符合事务的隔离性<br>            不可重复读：同一个事务中针对同一行记录两次读出来的结果不一样，原因就是第二次读到了其他事务修改提交的数据<br>            可重复读：同一个事务中针对同一范围内的数据两次读出来的结果不一样，原因就是第二次读到了其他事务新增提交的数据<br>        mysql默认隔离级别：<br>            可重复读，但是一般会设置为不可重复读，因为在实际业务中常常是，一个事务中需要读到别的事务提交修改的数据<br>        oraclel默认隔离级别：<br>            不可重复读</p>
<h2 id="12、Mysql的行锁、表锁，悲观锁、乐观锁？"><a href="#12、Mysql的行锁、表锁，悲观锁、乐观锁？" class="headerlink" title="12、Mysql的行锁、表锁，悲观锁、乐观锁？"></a>12、Mysql的行锁、表锁，悲观锁、乐观锁？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">行锁：</span><br><span class="line">        访问数据库的时候，锁定整个行数据，防止并发错误。</span><br><span class="line">    表锁：</span><br><span class="line">        访问数据库的时候，锁定整个表数据，防止并发错误。</span><br><span class="line">    乐观锁：</span><br><span class="line">        乐观的认为本次事务操作数据不会有别的事务干扰，操作数据前不进行加锁，只是预先记录版本号，真正修改数据时再进行比对，</span><br><span class="line">        如果版本号没变则修改数据，版本号变了则表面别的事务在本次事务过程中修改了数据，本次事务不修改数据。</span><br><span class="line">    悲观锁：</span><br><span class="line">        悲观的认为本次事务一定会有别的事务干扰，操作数据前必须先加锁</span><br></pre></td></tr></table></figure></div>

<h2 id="13、Mysql的vachar和char的区别？"><a href="#13、Mysql的vachar和char的区别？" class="headerlink" title="13、Mysql的vachar和char的区别？"></a>13、Mysql的vachar和char的区别？</h2><p>vachar：<br>            长度为可变的，实际使用多少空间就占多少空间。<br>        char：<br>            列长度固定，为创建表时声明的长度，长度值范围是1到255，当char值未填满指定长度时，其他空间会用空格进行填充，检索CHAR值时需删除尾随空格。</p>
<h2 id="14、什么是内连接-inner-join-、外连接（left-join）？"><a href="#14、什么是内连接-inner-join-、外连接（left-join）？" class="headerlink" title="14、什么是内连接(inner join)、外连接（left join）？"></a>14、什么是内连接(inner join)、外连接（left join）？</h2><p>内连接：<br>            只显示左右两表中匹配条件的行，在结果表中删除与其他被连接表中没有匹配行的所有行<br>        左外连接：<br>            把左边表的数据全部取出来，而右边表的数据有相等的，显示出来，如果没有，显示NULL</p>
<h2 id="15、平时Mysql的sql练习要练到位！！"><a href="#15、平时Mysql的sql练习要练到位！！" class="headerlink" title="15、平时Mysql的sql练习要练到位！！"></a>15、平时Mysql的sql练习要练到位！！</h2><p>牛客网，练习SQL语句</p>
<h2 id="16、Mybatis底层的原理？一级缓存和二级缓存是什么？"><a href="#16、Mybatis底层的原理？一级缓存和二级缓存是什么？" class="headerlink" title="16、Mybatis底层的原理？一级缓存和二级缓存是什么？"></a>16、Mybatis底层的原理？一级缓存和二级缓存是什么？</h2><p>Mybatis底层的原理：<br>            动态代理<br>        一级缓存：<br>            Mybatis中sqlSession对象的缓存，当执行查询以后，查询的结果会同时存入到SqlSession提供的一块区域中，该区域的结构是一个Map，<br>            当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，的话直接拿出来用，<br>            当SqlSession对象消失时，mybatis的一级缓存也就消失了，<br>            同时一级缓存是SqlSession范围的缓存，当调用SqlSession的修改、添加、删除、commit(),close等方法时，就会清空一级缓存。<br>        二级缓存：<br>            Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存，但是其中缓存的是数据而不是对象</p>
<h2 id="17、mybatis-和-的区别？"><a href="#17、mybatis-和-的区别？" class="headerlink" title="17、mybatis #{}和${}的区别？"></a>17、mybatis #{}和${}的区别？</h2><p>#{}方式能够很大程度防止sql注入<br>        ${}的方式无法防止Sql注入</p>
<h2 id="18、Mysql存储过程、存储函数、触发器分别用来干嘛的？创建语法是什么？"><a href="#18、Mysql存储过程、存储函数、触发器分别用来干嘛的？创建语法是什么？" class="headerlink" title="18、Mysql存储过程、存储函数、触发器分别用来干嘛的？创建语法是什么？"></a>18、Mysql存储过程、存储函数、触发器分别用来干嘛的？创建语法是什么？</h2><p>存储过程：<br>            存储过程把经常使用的SQL语句或业务逻辑封装起来,预编译保存在数据库中,当需要时从数据库中直接调用,省去了编译的过程。<br>            提高了运行速度同时降低网络数据传输量<br>        存储函数：<br>            参数可以有多个,也可以没有参数，必须有且只有一个返回值<br>        触发器：<br>            触发器的执行不是由程序调用，也不是由手工启动，而是由事件来触发、激活从而实现执行</p>
<h2 id="19、union和unionAll有什么区别？"><a href="#19、union和unionAll有什么区别？" class="headerlink" title="19、union和unionAll有什么区别？"></a>19、union和unionAll有什么区别？</h2><p>Union：<br>            对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序<br>            在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果<br>        Union All：<br>            对两个结果集进行并集操作，包括重复行，不进行排序<br>            如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了</p>
<h2 id="20、创建表、删除表、更新表字段语句？"><a href="#20、创建表、删除表、更新表字段语句？" class="headerlink" title="20、创建表、删除表、更新表字段语句？"></a>20、创建表、删除表、更新表字段语句？</h2><p>创建表：<br>            create table 表名<br>        删除表：<br>            drop table 表名<br>        更新表字段：<br>            修改字段名称：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 数据类型;<br>            修改字段数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型;</p>
<h2 id="21、mysql左外连接语句的写法？"><a href="#21、mysql左外连接语句的写法？" class="headerlink" title="21、mysql左外连接语句的写法？"></a>21、mysql左外连接语句的写法？</h2><p>Select A.name,B.name from A Left Join B on A.id&#x3D;B.id;</p>
<h2 id="22、听过InnoDB的Mvcc技术吗？说下是什么？"><a href="#22、听过InnoDB的Mvcc技术吗？说下是什么？" class="headerlink" title="22、听过InnoDB的Mvcc技术吗？说下是什么？"></a>22、听过InnoDB的Mvcc技术吗？说下是什么？</h2><p>Mvcc：<br>            多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，<br>            取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能</p>
<h2 id="23、Java实现动态代理有哪些方式？区别是什么？"><a href="#23、Java实现动态代理有哪些方式？区别是什么？" class="headerlink" title="23、Java实现动态代理有哪些方式？区别是什么？"></a>23、Java实现动态代理有哪些方式？区别是什么？</h2><p>Java实现动态代理有哪些方式：<br>            jdk动态代理、cglib动态代理<br>        区别：<br>            jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。<br>            总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效。<br>            还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。<br>            如果没有上述前提，jdk动态代理不能应用。<br>            由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</p>
<h1 id="五、多线程"><a href="#五、多线程" class="headerlink" title="五、多线程"></a>五、多线程</h1><h2 id="1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？"><a href="#1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？" class="headerlink" title="1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？"></a>1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？</h2><p>创建线程的方式：<br>            1、实现Runnable接口<br>            2、继承Thread类<br>        好处：<br>            1、适合多个相同程序代码的线程去处理同一个资源<br>            2、可以避免由于Java的单继承性带来的局限性<br>            3、增强了程序的健壮性，代码能够被多个线程共享，代码与数据是独立的</p>
<h2 id="2、线程的状态有哪些？"><a href="#2、线程的状态有哪些？" class="headerlink" title="2、线程的状态有哪些？"></a>2、线程的状态有哪些？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、新建状态</span><br><span class="line">2、就绪状态</span><br><span class="line">3、运行状态</span><br><span class="line">4、阻塞状态</span><br><span class="line">5、死亡状态</span><br></pre></td></tr></table></figure></div>

<h2 id="3、run-和start-方法有哪些区别？"><a href="#3、run-和start-方法有哪些区别？" class="headerlink" title="3、run()和start()方法有哪些区别？"></a>3、run()和start()方法有哪些区别？</h2><p>run()：<br>            是来完成实际的业务逻辑，当run()方法结束后，此线程就会终止<br>        start()：<br>            是用来开启一个线程的，使线程处于就绪状态，即可以被JVM来调度执行</p>
<h2 id="4、实现线程间通讯的方法有哪些？"><a href="#4、实现线程间通讯的方法有哪些？" class="headerlink" title="4、实现线程间通讯的方法有哪些？"></a>4、实现线程间通讯的方法有哪些？</h2><p>1、wait()：<br>            让线程处于冻结状态，被wait的线程会被存储到线程池中<br>        2、notify()：<br>            唤醒线程池中的一个线程<br>        3、notifyAll()：<br>            唤醒线程池中的所有线程</p>
<h2 id="5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？"><a href="#5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？" class="headerlink" title="5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？"></a>5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？</h2><p>分别的作用：<br>            wait()：<br>                让线程处于冻结状态，被wait的线程会被存储到线程池中<br>            notify()：<br>                唤醒线程池中的一个线程<br>            notifyAll()：<br>                唤醒线程池中的所有线程<br>        可以用在同步代码块之外吗：<br>            不行<br>        为什么：<br>            因为这些方法是用于操作线程状态的方法，必须要明确到底操作的是哪个锁上的线程</p>
<h2 id="6、Sleep和Wait的区别？"><a href="#6、Sleep和Wait的区别？" class="headerlink" title="6、Sleep和Wait的区别？"></a>6、Sleep和Wait的区别？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep():</span><br><span class="line">        1、属于Thread类，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态</span><br><span class="line">        2、sleep方法没有释放锁</span><br><span class="line">        3、sleep必须捕获异常</span><br><span class="line">        4、sleep可以在任何地方使用</span><br><span class="line">    wait：</span><br><span class="line">        1、属于Object，一旦一个对象调用了wait方法，必须采用notify()和notifyAll()方法唤醒该进程</span><br><span class="line">        2、wait方法释放了锁</span><br><span class="line">        3、wait不需要捕获异常</span><br><span class="line">        4、wait、notify、notifyAll只能在同步控制方法或者同步控制块中使用</span><br></pre></td></tr></table></figure></div>

<h2 id="7、什么是线程安全问题？什么情况下会产生？如何解决？"><a href="#7、什么是线程安全问题？什么情况下会产生？如何解决？" class="headerlink" title="7、什么是线程安全问题？什么情况下会产生？如何解决？"></a>7、什么是线程安全问题？什么情况下会产生？如何解决？</h2><p>线程安全问题：<br>            多个线程同时访问共享数据时可能会出现问题，称为线程安全问题<br>        什么情况下会产生：<br>            当多线程访问共享数据时，由于CPU的切换，导致一个线程只执行了关键代码的一部分，还没执行完此时另一个线程参与进来，导致共享数据发生异常<br>        如何解决：<br>            通过线程同步机制synchronized + 锁来解决线程安全问题</p>
<h2 id="8、什么是死锁？如何防止产生死锁？"><a href="#8、什么是死锁？如何防止产生死锁？" class="headerlink" title="8、什么是死锁？如何防止产生死锁？"></a>8、什么是死锁？如何防止产生死锁？</h2><p>什么是死锁：<br>            死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去<br>        如何防止产生死锁：<br>            1、设置超时时间<br>            2、使用JUC包提供的并发类，而不是自己设计锁<br>            3、尽量降低锁的粒度<br>            4、尽量使用同步代码块，而不是同步方法<br>            5、给线程其有意义的名字<br>            6、避免的嵌套<br>            7、分配锁资源之前先看能不能回收回来资源<br>            8、专锁专用</p>
<h2 id="9、Synchronized关键字的底层原理是什么"><a href="#9、Synchronized关键字的底层原理是什么" class="headerlink" title="9、Synchronized关键字的底层原理是什么?"></a>9、Synchronized关键字的底层原理是什么?</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">当一个线程第一次运行到 <span class="keyword">synchronized</span> 代码，获取到了 myObject 对象的 monitor 的锁，然后计数器就会加<span class="number">1</span>，</span><br><span class="line">然后第二次运行到 <span class="keyword">synchronized</span> 代码，会再次获取 myObject 对象的 monitor 的锁，这个就是重入加锁了，然后计数器会再次加<span class="number">1</span>，变成<span class="number">2</span>，</span><br><span class="line">这个时候，其他的线程运行到第一次 <span class="keyword">synchronized</span> 代码，会发现 myObject 对象的 monitor 锁的计数器是大于<span class="number">0</span>的，</span><br><span class="line">就意味着被别人给加锁了，然后此时线程就会进入 block 阻塞状态，什么都干不了，就是等待获取锁</span><br><span class="line">如果第一个线程出了 <span class="keyword">synchronized</span> 修饰范围的话，就会有一个 moninorexit 的指令，此时，在底层获取锁的线程就会对那个对象</span><br><span class="line">的 monitor 的计数器减<span class="number">1</span>，如果有多次重入加锁，就会对应多次减<span class="number">1</span>，直到最后，计数器是<span class="number">0</span></span><br><span class="line">然后，后面 block 阻塞的线程，会再次尝试获取锁，但是只有一个线程可以获取锁</span><br></pre></td></tr></table></figure></div>

<h2 id="10、Synchronized可以用在哪些地方？分别的锁对象是什么？"><a href="#10、Synchronized可以用在哪些地方？分别的锁对象是什么？" class="headerlink" title="10、Synchronized可以用在哪些地方？分别的锁对象是什么？"></a>10、Synchronized可以用在哪些地方？分别的锁对象是什么？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、同步代码块：锁对象为括号中的对象</span><br><span class="line">    <span class="number">2</span>、同步方法：锁对象为当前对象<span class="built_in">this</span></span><br><span class="line">    <span class="number">3</span>、静态同步方法：锁对象为class字节码文件对象</span><br></pre></td></tr></table></figure></div>

<h2 id="11、Synchronized和JUC下Lock锁的异同？"><a href="#11、Synchronized和JUC下Lock锁的异同？" class="headerlink" title="11、Synchronized和JUC下Lock锁的异同？"></a>11、Synchronized和JUC下Lock锁的异同？</h2><p>1、Lock是JUC包下提供的封装好的锁，是类的概念，而synchronized是一个虚拟机层面的关键字。<br>        2、Lock显示的加锁和解锁，且解锁要在finally代码块中，否则可能会死锁，而synchronized为隐式的上锁和解锁。<br>        3、Lock锁提供了尝试获取锁和设置获取锁时间的机制，可返回取锁状态，当获取不到锁的时候也可以选择放弃取锁，<br>          而synchronized无法判断返回取锁状态，取锁不成功只能阻塞，没有Lock灵活。<br>        4、Lock锁阻塞可被打断，而synchronized阻塞不可被打断。<br>        5、Lock可实现可重入、可公平锁，而synchronized是可重入、非公平锁。<br>        6、Lock可以很灵活的根据线程角色类型去创建Condition监视器对象，调用await()、signal()、signalAll()进行线程通讯调度，<br>          而synchronized使用Object对象本身作为监视器对象去调用wait() 、notify()、notifyAll()进行线程通讯调度。<br>        7、Lock提供了更丰富的锁分类，如读锁、写锁，可以更细粒度的关注线程安全问题。</p>
<h2 id="12、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？"><a href="#12、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？" class="headerlink" title="12、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？"></a>12、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？</h2><p>非公平，会阻塞</p>
<h2 id="13、Synchronized在JDK1-6做了什么优化？"><a href="#13、Synchronized在JDK1-6做了什么优化？" class="headerlink" title="13、Synchronized在JDK1.6做了什么优化？"></a>13、Synchronized在JDK1.6做了什么优化？</h2><p>自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁</p>
<h2 id="13、同步代码块中执行完wait-x2F-notify-x2F-notifyAll后会立马释放锁吗？"><a href="#13、同步代码块中执行完wait-x2F-notify-x2F-notifyAll后会立马释放锁吗？" class="headerlink" title="13、同步代码块中执行完wait&#x2F;notify&#x2F;notifyAll后会立马释放锁吗？"></a>13、同步代码块中执行完wait&#x2F;notify&#x2F;notifyAll后会立马释放锁吗？</h2><p>不会，必须等其所在的同步代码块执行完才会释放锁</p>
<h2 id="14、Lock锁有哪些实现？分别的特点是什么？"><a href="#14、Lock锁有哪些实现？分别的特点是什么？" class="headerlink" title="14、Lock锁有哪些实现？分别的特点是什么？"></a>14、Lock锁有哪些实现？分别的特点是什么？</h2><p>1、ReentrantLock<br>        2、ReentrantReadWriteLock类中的静态内部类ReadLock(读-写锁)<br>        3、ReentrantReadWriteLock类中的静态内部类WriteLock(读-写锁)</p>
<h2 id="15、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？"><a href="#15、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？" class="headerlink" title="15、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？"></a>15、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">JUC下Lock的监视器对象：</span><br><span class="line">    Condition</span><br><span class="line">异同：</span><br><span class="line">    Lock可以很灵活的根据线程角色类型去创建Condition监视器对象，调用await()、signal()、signalAll()进行线程通讯调度，</span><br><span class="line">      而synchronized使用Object对象本身作为监视器对象去调用wait() 、notify()、notifyAll()进行线程通讯调度。</span><br></pre></td></tr></table></figure></div>

<h2 id="16、什么是线程可重入？Synchronized具备吗？Lock呢？"><a href="#16、什么是线程可重入？Synchronized具备吗？Lock呢？" class="headerlink" title="16、什么是线程可重入？Synchronized具备吗？Lock呢？"></a>16、什么是线程可重入？Synchronized具备吗？Lock呢？</h2><p>重入锁就是一个线程能否获取一个已经由它自己持有的锁。如果可以，就是可重入锁，否则为不可重入锁。它的作用就是能够避免重复获取的时候出现死锁<br>        synchronized 是可重入锁<br>        Lock 是可重入锁</p>
<h2 id="17、什么是AQS？"><a href="#17、什么是AQS？" class="headerlink" title="17、什么是AQS？"></a>17、什么是AQS？</h2><p>是一个用于构建锁和同步容器的队列同步器，它是整个JUC包下Lock体系的核心，<br>        如ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore都是基于它来实现的，<br>        它解决了在实现同步容器时设计的大量细节问题，<br>        它的核心构成部分为：使用一个 先进先出的FIFO的队列存储排队等待锁的线程，使用一个用volatile修饰的int类型的state同步状态来记录<br>        当前是否有线程持有锁，0表示没有线程获得锁，1表示有，上锁state就加1，释放锁就对应减1，有重入锁现象，这个值就大于1，然后需要逐级去释放。</p>
<h2 id="18、什么是CAS？什么是CAS的ABA问题？如何解决？"><a href="#18、什么是CAS？什么是CAS的ABA问题？如何解决？" class="headerlink" title="18、什么是CAS？什么是CAS的ABA问题？如何解决？"></a>18、什么是CAS？什么是CAS的ABA问题？如何解决？</h2><p>CAS：<br>            CAS其实就是乐观锁的一种实现方式<br>        ABA问题：<br>            1、线程1读取出指定内存地址的数据A，加载到寄存器，此时读取出来的原值不仅将作为要被计算的值A，还会作为比较值A。<br>            2、此时线程1的cpu被线程2抢占了，线程2也从同样的内存地址中读取了同样的数据A，线程2还比线程1先执行完，线程2产生了新数据B，<br>              并且遵守了CAS原理把新数据B存入该内存地址。 （这个时候内存的值由A被该为B）<br>            3、还没完，线程2执行完之后，线程1又没抢过其它线程，此时cpu被线程3抢占，之后步骤和第 2 步一样，线程3从同样的内存地址中读取了数据B，<br>              线程3还比线程1先执行完，线程3产生了新数据A（没错，与一开始的A相等，但值相等并不意味着此A就是彼A，已经被替换了），<br>              并且遵守了CAS原理把新数据A存入该内存地址。（这个时候内存的值由B又变为A）<br>            4、这个时候线程1执行完了，要遵守CAS原理存入数据，然后比较值A是原来的A（简称原A），而执行内存地址中的A是被替换过的了，<br>              但原A的值与内存中的A值是相等的，根据CAS，线程1会把新的执行结果存入该内存地址<br>              在实际业务中，两个数的值相等，但这两个数并不是同一个数<br>        解决方案：<br>            加个版本号，多一步比较版本号即可解决</p>
<h2 id="19、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Simephore）"><a href="#19、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Simephore）" class="headerlink" title="19、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Simephore）"></a>19、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Simephore）</h2><p>CountdownLatch：<br>            利用它可以实现类似计数器的功能<br>        Cyclicbarrier：<br>            字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行<br>        Simephore：<br>            信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可</p>
<h2 id="20、说下volatile关键字，有什么作用？原理是什么？"><a href="#20、说下volatile关键字，有什么作用？原理是什么？" class="headerlink" title="20、说下volatile关键字，有什么作用？原理是什么？"></a>20、说下volatile关键字，有什么作用？原理是什么？</h2><p>是一个变量类型修饰符，被voltile修饰的变量具有以下特性：<br>        可见性：<br>            保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>            实现(缓存共享协议)：<br>                对于用volatile形容的变量，线程写入本地内存中的同时会将数据立即刷新到主内存中。<br>                他线程读取该变量时，发现被volatile修饰，会将本地变量值置为无效，然后从主内存中读取。<br>        有序性：<br>            禁止进行指令重排序。为提高执行效率，在不影响最终执行结果的前提下，代码在编译成字节码的时候有可能进行指令重新<br>            排序，这在单线程情况下是没有问题的，但是在多线程的情况下会出现问题。volatile修饰的变量则可以避免这个问题。<br>        不保证原子性：<br>            volatile 只能保证对单次读&#x2F;写的原子性。i++ 这种操作不能保证原子性。关于volatile 原子性可以理解为把对volatile<br>            变量的单个读&#x2F;写，看成是使用同一个锁对这些单个读&#x2F;写操作做了同步。</p>
<h2 id="21、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？"><a href="#21、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？" class="headerlink" title="21、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？"></a>21、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？</h2><p>ThreadLocal：<br>            ThreadLocal是除了加锁这种同步方式之外的另一种可以规避出现多线程安全问题的思路。<br>            ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，<br>            在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题<br>        主要方法：<br>            get（）、set（）、remove（）<br>        实现原理：<br>            每个线程都有属于自己的一个ThreadLocalMap，可通过Thread获得，这个map存储着以threadLock对象为key、以设置的值为value的键值对。<br>            调用get或者set还有remove方法都是操作这个map<br>        内存泄漏：<br>            对于线程池里面不会销毁的线程, 里面总会存在着&lt;ThreadLocal, LocalVariable&gt;的强引用,<br>            因为 final static 修饰的 ThreadLocal 并不会释放,<br>            而 ThreadLocalMap 对于 Key 虽然是弱引用, 但是强引用不会释放, 弱引用当然也会一直有值,<br>            同时创建的 LocalVariable 对象也不会释放, 就造成了内存泄露;<br>        解决方案：<br>            为了避免出现内存泄露的情况, ThreadLocal 提供了一个清除线程中对象的方法, 即 remove,<br>            其实内部实现就是调用 ThreadLocalMap 的 remove 方法:</p>
<h2 id="22、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？"><a href="#22、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？" class="headerlink" title="22、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？"></a>22、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？</h2><p>线程池的七大核心参数：<br>            1、核心线程数：<br>                没达到核心线程数时，会创建新的线程。当达到核心线程数时，任务会进去队列<br>            2、最大核心线程数：<br>                当达到核心线程数时，会去创建额外的线程来执行任务，最多不超过最大线程数<br>            3、存活时间：<br>                当任务处理完成，额外的线程存活一段时间后，会自行销毁<br>            4、存活时间单位：<br>                空闲等待时间的单位<br>            5、阻塞队列：<br>                利用什么队列来存放任务，有界队列、无界队列等<br>            6、线程池工厂：<br>                线程创建工厂<br>            7、拒绝策略：<br>                分为四大策略：<br>                    1、AbortPolicy（默认策略）：直接抛出异常，阻止系统正常运行<br>                    2、CallerRunsPolicy 策略：等线程池处理不了的任务，谁提交的任务，就给谁拿回去，让其自己执行<br>                    3、DiscardPolicy 策略：直接抛弃策略，异常也不会抛，什么都不做<br>                    4、DiscardOldestPolicy 策略：丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务<br>        有几种默认的线程池：<br>            1、newCachedThreadPool：<br>                可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程<br>            2、newFixedThreadPool：<br>                指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中<br>            3、newSingleThreadExecutor：<br>                单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。<br>            4、newScheduleThreadPool：<br>                定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行</p>
<h2 id="23、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？"><a href="#23、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？" class="headerlink" title="23、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？"></a>23、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">单例模式写法：</span><br><span class="line">            <span class="number">1</span>、懒汉式</span><br><span class="line">                直到使用前才会创建实例</span><br><span class="line">            <span class="number">2</span>、饿汉式</span><br><span class="line">                类加载的时候就创建实例</span><br><span class="line">        懒汉式中保证线程安全：</span><br><span class="line">            在 getInstance() 方法添加 <span class="keyword">synchronized</span> 关键字，可以解决线程安全问题</span><br><span class="line">        为什么要用双重检查模式：</span><br><span class="line">            第一次校验：</span><br><span class="line">                由于单例模式只需要创建一次实例，如果后面再次调用getInstance方法时，则直接返回之前创建的实例，</span><br><span class="line">                因此大部分时间不需要执行同步方法里面的代码，大大提高了性能。</span><br><span class="line">                如果不加第一次校验的话，那跟上面的懒汉模式没什么区别，每次都要去竞争锁。</span><br><span class="line">　　　　     第二次校验：</span><br><span class="line">                如果没有第二次校验，假设线程t1执行了第一次校验后，判断为<span class="literal">null</span>，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为<span class="literal">null</span>。</span><br><span class="line">                接下来t2获得锁，创建实例。</span><br><span class="line">                这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为<span class="literal">null</span>（不会再次判断），获得锁后，直接创建实例。</span><br><span class="line">                结果就会导致创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。</span><br></pre></td></tr></table></figure></div>

<h1 id="六、Redis-amp-多级缓存"><a href="#六、Redis-amp-多级缓存" class="headerlink" title="六、Redis &amp; 多级缓存"></a>六、Redis &amp; 多级缓存</h1><h2 id="1、Redis是一个什么样的数据库？读写速度怎么样？"><a href="#1、Redis是一个什么样的数据库？读写速度怎么样？" class="headerlink" title="1、Redis是一个什么样的数据库？读写速度怎么样？"></a>1、Redis是一个什么样的数据库？读写速度怎么样？</h2><p>非关系型型数据库<br>        Redis将数据存储在内存上，避免了频繁的IO操作</p>
<h2 id="2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举"><a href="#2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举" class="headerlink" title="2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举"></a>2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举</h2><br/>

<p>数据类型：<br>            1、string（字符串）：<br>                一个key对应一个value<br>            2、hash（哈希）：<br>                是一个键值对集合<br>            3、list（列表）：<br>                简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）<br>            4、set（集合）：<br>                string类型的无序集合,且不允许重复的成员<br>            5、zset(有序集合)：<br>                string类型元素的集合,且不允许重复的成员<br>                不同的是每个元素都会关联一个double类型的分数<br>                redis正是通过分数来为集合中的成员进行从小到大的排序<br>                zset的成员是唯一的,但分数(score)却可以重复<br>        项目有哪些应用场景：<br>            1、计数器：<br>                对 string 进行自增自减运算，从而实现计数器功能<br>                redis 内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。如每日登录次数计数<br>            2、热点数据缓存：<br>                将热点数据放到内存中。如首页排行榜数据，具有很大访问频次，使用zset可以实现基于score分数排序<br>            3、会话缓存：<br>                用redis统一存储多台应用服务器的会话信息<br>                当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，<br>                从而更容易实现高可用性以及可伸缩性<br>            4、取数据交集、并集：<br>                基于 redis set 的特性可以对共同好友进行很方便的查询<br>            5、分布式事务锁的使用：<br>                基于 set lock requestId nx ex time 模式可以很方便编写分布式事务锁</p>
<h2 id="3、Redis的持久化机制是什么样的？"><a href="#3、Redis的持久化机制是什么样的？" class="headerlink" title="3、Redis的持久化机制是什么样的？"></a>3、Redis的持久化机制是什么样的？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）、什么是RDB？RDB的持久化机制（Save、bgSave）?</span><br><span class="line">			RDB：</span><br><span class="line">				把内存中的所有数据都记录到磁盘中。</span><br><span class="line">				当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</span><br><span class="line">				快照文件称为RDB文件，默认是保存在当前运行目录。</span><br><span class="line">			save：</span><br><span class="line">				save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</span><br><span class="line">			bgSave：</span><br><span class="line">				bgSave命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</span><br><span class="line"></span><br><span class="line">		<span class="number">2</span>）、触发RDB的时间点是什么？</span><br><span class="line">			save：关机时会save一次，会阻塞主线程，影响效率。</span><br><span class="line">			bgsave：与配置有关：save m n，当m秒内有n个key发生修改会触发，后台会fork出一个子线程完成快照</span><br><span class="line"></span><br><span class="line">		<span class="number">3</span>）、RDB的优缺点分别有哪些？</span><br><span class="line">			优点：</span><br><span class="line">				由于快照是二进制的，所以加载速度很快</span><br><span class="line">			缺点：</span><br><span class="line">				由于快照的时间间隔比较长，所以有可能会丢失大量数据</span><br><span class="line"></span><br><span class="line">		<span class="number">4</span>）、什么是AOF？分为几个阶段？(命令写入缓冲区、同步至日志文件、文件重写)</span><br><span class="line">			AOF：</span><br><span class="line">				将redis数据以 操作 + 数据的命令形式存在日志文件中(appendonly.aof)，默认是关闭的</span><br><span class="line">			三个阶段：</span><br><span class="line">				<span class="number">1</span>、命令写入缓冲区</span><br><span class="line">				<span class="number">2</span>、文件命令同步（刷盘策略）</span><br><span class="line">				<span class="number">3</span>、文件重写</span><br><span class="line"></span><br><span class="line">		<span class="number">5</span>）、AOF命令同步至日志文件分为哪几种？</span><br><span class="line">			<span class="number">1</span>、always </span><br><span class="line">			<span class="number">2</span>、everyseconds</span><br><span class="line">			<span class="number">3</span>、no</span><br><span class="line"></span><br><span class="line">		<span class="number">6</span>）、AOF文件重写时间点？重写做了什么？</span><br><span class="line">			重写的时机：</span><br><span class="line">				<span class="number">1</span>、文件大小超过64M</span><br><span class="line">				<span class="number">2</span>、跟上次文件大小相比，增长比例超过<span class="number">100</span>%，也就是原来的<span class="number">2</span>倍</span><br><span class="line">			重写干了什么：</span><br><span class="line">				删除没用的命令、合并多条命令以缩小文件大小</span><br><span class="line"></span><br><span class="line">		<span class="number">7</span>）、AOF的优缺点分别有哪些？</span><br><span class="line">			优点：</span><br><span class="line">				数据实时性高，不易丢失数据</span><br><span class="line">			缺点：</span><br><span class="line">				加载速度慢，文件体积大</span><br><span class="line"></span><br><span class="line">		<span class="number">8</span>）、AOF和RDB同时开启会优先使用哪种进行数据恢复？</span><br><span class="line">			AOF</span><br><span class="line"></span><br><span class="line">		<span class="number">9</span>）、RDB-AOF混合模式是什么？优点有哪些？</span><br><span class="line">			RDB-AOF混合模式：</span><br><span class="line">				是在AOF重写阶段创建一个同时包含RDB数据和AOF数据的AOF文件，其中RDB数据位于AOF文件的开头，</span><br><span class="line">				他存储了服务器开始执行重写操作时Redis服务器的数据状态（RDB 快照方案），</span><br><span class="line">				重写操作执行之后的Redis命令，则会继续 append 在AOF文件末尾，一般这部分数据都会比较小。</span><br><span class="line">			优点：</span><br><span class="line">				这样在Redis重启的时候，则可以先加载RDB的内容，然后再加载AOF的日志内容，这样重启的效率则会得到很大的提升，</span><br><span class="line">				而且由于在运行阶段 Redis 命令都会以 append 的方式写入AOF文件，保证了数据的实时性和安全性</span><br></pre></td></tr></table></figure></div>

<h2 id="4、Redis主从结构能解决什么问题？"><a href="#4、Redis主从结构能解决什么问题？" class="headerlink" title="4、Redis主从结构能解决什么问题？"></a>4、Redis主从结构能解决什么问题？</h2><p>提高并发读写效率</p>
<h2 id="5、Redis主从同步具体流程是什么？"><a href="#5、Redis主从同步具体流程是什么？" class="headerlink" title="5、Redis主从同步具体流程是什么？"></a>5、Redis主从同步具体流程是什么？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）、建立连接</span><br><span class="line">		<span class="number">2</span>）、数据同步（全量同步、增量同步）【runid运行ID、offset偏移量、复制积压缓冲区】</span><br><span class="line">			<span class="number">1</span>、全量同步具体场景有哪些？流程？如何避免全量同步次数（全量同步非常耗时）</span><br><span class="line">				具体场景：</span><br><span class="line">					<span class="number">1</span>、slave节点第一次连接master节点时</span><br><span class="line">          <span class="number">2</span>、slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</span><br><span class="line">				流程：</span><br><span class="line">					<span class="number">1</span>、从服务器向主服务器发送SYNC请求</span><br><span class="line">					<span class="number">2</span>、主服务器创建快照，并将快照生成期间产生的写命令存储到缓冲区</span><br><span class="line">					<span class="number">3</span>、主服务器向从服务器发送同步快照命令</span><br><span class="line">					<span class="number">4</span>、从服务器加载解析快照</span><br><span class="line">					<span class="number">5</span>、主服务器将从服务器同步快照期间产生的写命令存储到缓冲区</span><br><span class="line">					<span class="number">6</span>、主服务器向从服务器发送缓冲区中存储的命令</span><br><span class="line">					<span class="number">7</span>、从服务器加载缓冲</span><br><span class="line">					<span class="number">8</span>、完成，主服务器向从服务器同步写操作命令</span><br><span class="line">				如何避免全量同步次数：</span><br><span class="line">					增大复制缓冲区的配置</span><br><span class="line"></span><br><span class="line">			<span class="number">2</span>、增量同步具体场景有哪些？流程？</span><br><span class="line">				具体场景:</span><br><span class="line">					slave节点断开又恢复，并且在repl_baklog中能找到offset时</span><br><span class="line">				流程：</span><br><span class="line">					Slave完成初始化后开始正常工作时，Master每执行一个写命令就会向Slave发送相同的写命令，然后Slave接收并执行</span><br><span class="line">		<span class="number">3</span>）、命令传播</span><br></pre></td></tr></table></figure></div>

<h2 id="6、如何优化主从同步效率？"><a href="#6、如何优化主从同步效率？" class="headerlink" title="6、如何优化主从同步效率？"></a>6、如何优化主从同步效率？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）、从尽量避免全量同步的方面入手（安全重启使runid不发生变化、调大复制积压缓冲区）</span><br><span class="line">			安全重启使runid不发生变化、调大复制积压缓冲区</span><br><span class="line"></span><br><span class="line">		2）、避免slave从结点太多造成复制风暴（使用树状拓补结构）</span><br><span class="line">			1.主节点分散多机器（将master分散到不同机器上部署）</span><br><span class="line">			2.还有我们可以采用高可用手段（slave晋升master）</span><br></pre></td></tr></table></figure></div>

<h2 id="7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？"><a href="#7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？" class="headerlink" title="7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？"></a>7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Redis的故障恢复机制:</span><br><span class="line">			哨兵机制</span><br><span class="line">		工作范围:</span><br><span class="line">			监控、故障转移、通知</span><br><span class="line">		工作流程：	</span><br><span class="line">			<span class="number">1</span>、每个 Sentinel 进程每秒向整个集群中的主服务器，从服务器以及其他 Sentinel 进程发送一个 PING 命令</span><br><span class="line">			<span class="number">2</span>、如果一个实例距离最后一次有效回复 PING 命令的时间超过所指定的值， 则这个实例会被 Sentinel 进程标记为主观下线</span><br><span class="line">			<span class="number">3</span>、如果一个主服务器被标记为主观下线，则正在监视这个主服务器的所有 Sentinel 进程要每秒确认主服务器的确进入了主观下线状态</span><br><span class="line">			<span class="number">4</span>、当有足够数量的 Sentinel 进程在指定的时间范围内确认主服务器进入了主观下线状态， 则主服务器会被标记为客观下线</span><br><span class="line">			<span class="number">5</span>、每个 Sentinel 进程会以每 <span class="number">10</span> 秒向集群中的所有主服务器、从服务器发送 INFO 命令，更新redis主从最新的一个拓补情况</span><br><span class="line">			<span class="number">6</span>、当主服务器被 Sentinel 进程标记为客观下线时，Sentinel 进程向下线的主服务器的所有从服务器发送 INFO 命令的频率会从 <span class="number">10</span> 秒一次改为每秒一次</span><br><span class="line">			<span class="number">7</span>、若没有足够数量的 Sentinel 进程同意主服务器下线，主服务器的客观下线状态就会被移除。</span><br><span class="line">			  若主服务器重新向 Sentinel 进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</span><br><span class="line">		作用：</span><br><span class="line">			<span class="number">1</span>、监控：<span class="number">3</span>个心跳</span><br><span class="line">				<span class="number">10</span>秒一次：更新redis主从最新的一个拓补情况</span><br><span class="line">				<span class="number">3</span>秒一次：用于Sentinel哨兵节点之间交流对redis数据节点的看法</span><br><span class="line">				<span class="number">1</span>秒一次：用于发出ping，检测redis节点是否还存活（主观下线、客观下线）</span><br><span class="line">			<span class="number">2</span>、故障转移：当对主节点进行客观下线后，选举出一个新的主节点，并且将其他节点连接上新的主节点，最后将原来的master标记为从结点</span><br><span class="line">			<span class="number">3</span>、通知：用于master发生了变动，将变化推送给客户端</span><br></pre></td></tr></table></figure></div>

<h2 id="8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？"><a href="#8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？" class="headerlink" title="8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？"></a>8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">缓存雪崩：</span><br><span class="line">			Redis挂掉了，请求全部走数据库。</span><br><span class="line">			对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库</span><br><span class="line">			解决方案：</span><br><span class="line">				<span class="number">1</span>、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</span><br><span class="line">				<span class="number">2</span>、如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中</span><br><span class="line">				<span class="number">3</span>、允许的话，设置热点数据永远不过期</span><br><span class="line">				<span class="number">4</span>、要保证redis的高可用，可以使用主从+哨兵或redis cluster，避免服务器不可用</span><br><span class="line">				<span class="number">5</span>、使用redis的持久化RDB+AOF组合策略，防止缓存丢失并且可以快速恢复数据</span><br><span class="line"></span><br><span class="line">		缓存击穿：</span><br><span class="line">			缓存中没有但数据库中有的数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，</span><br><span class="line">			引起数据库压力瞬间增大，造成过大压力</span><br><span class="line">			解决方案：</span><br><span class="line">				<span class="number">1</span>）、设置热点数据不过期；</span><br><span class="line">				<span class="number">2</span>）、第一时间去数据库获取数据填充到redis中，但是这个过程需要加锁，防止所有线程都去读取数据库，</span><br><span class="line">					一旦有一个线程去数据库获取数据了，其他线程取锁失败后可设置一个合理睡眠时间之后再去尝试去redis中获取数据；</span><br><span class="line">		缓存穿透：</span><br><span class="line">			缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为 -<span class="number">1</span> 的数据或id为特别大不存在的数据。</span><br><span class="line">			这时的用户很可能是攻击者，攻击会导致数据库压力过大</span><br><span class="line">			解决方案：</span><br><span class="line">				<span class="number">1</span>、接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=<span class="number">0</span>的直接拦截；</span><br><span class="line">				<span class="number">2</span>、从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-<span class="literal">null</span>，</span><br><span class="line">				  缓存有效时间可以设置短点，设置太长会导致正常情况也没法使用。这样可以防止攻击用户反复用同一个id暴力攻击；</span><br><span class="line">				<span class="number">3</span>、引入布隆过滤器，过滤一些异常的请求。</span><br></pre></td></tr></table></figure></div>

<h2 id="9、Redis是单线程的，为什么读写效率还那么高？"><a href="#9、Redis是单线程的，为什么读写效率还那么高？" class="headerlink" title="9、Redis是单线程的，为什么读写效率还那么高？"></a>9、Redis是单线程的，为什么读写效率还那么高？</h2><p>基于非阻塞的IO多路复用机制的线程模型</p>
<h2 id="10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）"><a href="#10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）" class="headerlink" title="10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）"></a>10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）</h2><p>基于非阻塞的IO多路复用机制的线程模型，单线程</p>
<h2 id="11、Redis过期数据的删除策略是什么？有哪些？"><a href="#11、Redis过期数据的删除策略是什么？有哪些？" class="headerlink" title="11、Redis过期数据的删除策略是什么？有哪些？"></a>11、Redis过期数据的删除策略是什么？有哪些？</h2><p>定时删除、惰性过期、定期过期</p>
<h2 id="12、Redis的数据淘汰策略是什么？有哪些？"><a href="#12、Redis的数据淘汰策略是什么？有哪些？" class="headerlink" title="12、Redis的数据淘汰策略是什么？有哪些？"></a>12、Redis的数据淘汰策略是什么？有哪些？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、volatile-lru：</span><br><span class="line">			从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</span><br><span class="line">		2、volatile-ttl：</span><br><span class="line">			从已设置过期时间的数据集中挑选将要过期的数据淘汰</span><br><span class="line">		3、volatile-random：</span><br><span class="line">			从已设置过期时间的数据集中任意选择数据淘汰</span><br><span class="line">		4、allkeys-lru：</span><br><span class="line">			从数据集中挑选最近最少使用的数据淘汰</span><br><span class="line">		5、allkeys-random：</span><br><span class="line">			从数据集中任意选择数据淘汰</span><br><span class="line">		6、no-enviction（驱逐）：</span><br><span class="line">			禁止驱逐数据</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="13、Redis的慢查询如何排查？"><a href="#13、Redis的慢查询如何排查？" class="headerlink" title="13、Redis的慢查询如何排查？"></a>13、Redis的慢查询如何排查？</h2><p>Redis 慢查询可通过配置两个参数进行：<br>            slowlog-log-slower-than：设置慢查询预设的超时阈值，单位是微秒<br>            slowlog-max-len：表示慢查询日志存储的条数</p>
<h2 id="14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）"><a href="#14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）" class="headerlink" title="14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）"></a>14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">正确使用redis分布式事务锁需要保证两个原子性：</span><br><span class="line">			1、上锁和设置过期时间需要保证原子性；</span><br><span class="line">			2、 判断锁ID是否为自己所有和解锁需要保证原子性</span><br></pre></td></tr></table></figure></div>

<h2 id="15、Redis的双写一致性如何保证？"><a href="#15、Redis的双写一致性如何保证？" class="headerlink" title="15、Redis的双写一致性如何保证？"></a>15、Redis的双写一致性如何保证？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">采用延时双删策略：</span><br><span class="line">			<span class="number">1</span>、先淘汰缓存</span><br><span class="line">			<span class="number">2</span>、再写数据库</span><br><span class="line">			<span class="number">3</span>、休眠<span class="number">1</span>秒，再次淘汰缓存</span><br></pre></td></tr></table></figure></div>

<h2 id="16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）"><a href="#16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）" class="headerlink" title="16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）"></a>16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）</h2><p>好处：<br>            可以避免缓存雪崩（缓存失效，大量请求直达DB），提高系统的可用性<br>        流程：<br>            1、反向代理nginx将请求负载均衡到业务nginx集群<br>            2、接着业务Nginx读取本地缓存（本地缓存可以使用Lua），如果本地缓存命中则直接返回，<br>              使用应用Nginx本地缓存可以提升整体的吞吐量，降低后端的压力，尤其应对热点问题非常有效<br>            3、如果Nginx本地缓存没有命中，则会读取相应的分布式缓存（如Redis缓存，另外可以考虑使用主从架构来提升性能和吞吐量），<br>              如果分布式缓存命中则直接返回相应的数据（并会写到Nginx本地缓存）<br>            4、如果分布式缓存也没有命中，则会回源到Tomcat集群，在回源到Tomcat集群时也可以使用轮询和一致性哈希作为负载均衡算法<br>            5、在Tomcat中，首先读取本地堆缓存，如果有则直接返回（并会写到Redis集群）<br>            6、如果所有的缓存都没有命中只能查询DB或相关服务获取相关数据并返回<br>            7、返回的数据异步写到Redis</p>
<h2 id="17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？"><a href="#17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？" class="headerlink" title="17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？"></a>17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">个数：</span><br><span class="line">			16384</span><br><span class="line">		数据进行入槽方式：</span><br><span class="line">			对Key的有效部分进行运算产生hash值，再拿hash对16384进行取余，余数是多少，所属的槽就是哪个</span><br><span class="line">		实现动态扩容方式：</span><br><span class="line">			1、重新分配哈希槽</span><br><span class="line">			2、输入要分配多少个哈希槽（数量）</span><br><span class="line">			3、输入指定要分配哈希槽的节点ID</span><br><span class="line">			4、选择需要分配的哈希槽来源，分配哈希槽有两种方式：</span><br><span class="line">				1、将所有节点用作哈希槽的源节点</span><br><span class="line">				2、在指定的节点拿出指定数量的哈希槽分配到目标节点</span><br></pre></td></tr></table></figure></div>

<h1 id="七、Rabbitmq"><a href="#七、Rabbitmq" class="headerlink" title="七、Rabbitmq"></a>七、Rabbitmq</h1><h2 id="1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）"><a href="#1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）" class="headerlink" title="1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）"></a>1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、简单模式：</span><br><span class="line">			单发送单消费</span><br><span class="line">		2、工作模式：</span><br><span class="line">			单发送多接收</span><br><span class="line">		3、发布、订阅模式：</span><br><span class="line">			生产者端发送消息，多个消费者同时接收所有的消息</span><br><span class="line">		4、路由模式：</span><br><span class="line">			生产者按 routing key 发送消息，不同的消费者端按不同的 routing key 接收消息</span><br><span class="line">		5、Topic：</span><br><span class="line">			生产者端不只按固定的 routing key 发送消息，而是按字符串“匹配”发送，消费者端同样如此</span><br></pre></td></tr></table></figure></div>

<h2 id="2、Rabbitmq如何保证mq消息可靠性？（3大方面）"><a href="#2、Rabbitmq如何保证mq消息可靠性？（3大方面）" class="headerlink" title="2、Rabbitmq如何保证mq消息可靠性？（3大方面）"></a>2、Rabbitmq如何保证mq消息可靠性？（3大方面）</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、保证消息投递到MQ不丢：</span><br><span class="line">			开启生产者消息确认机制</span><br><span class="line">			<span class="number">1</span>）、开启 ConfirmCallBack 回调：消息投递至交换机的回调（成功、失败、异常）</span><br><span class="line">			<span class="number">2</span>）、开启 ReturnCallBack 回调：消息从交换机未路由到队列的回调</span><br><span class="line">		<span class="number">2</span>、保证消息到达MQ之后不丢（MQ宕机了也不影响）：</span><br><span class="line">			消息持久化(三者默认就是持久化的)</span><br><span class="line">			<span class="number">1</span>）、交换机的持久化</span><br><span class="line">			<span class="number">2</span>）、队列的持久化</span><br><span class="line">			<span class="number">3</span>）、消息的持久化</span><br><span class="line">		<span class="number">3</span>、保证消费者不丢(必须至少消费一次)：</span><br><span class="line">			开启消费者消息确认机制</span><br><span class="line">			<span class="number">1</span>）、none：没有确认机制，如果出现异常也会直接丢弃</span><br><span class="line">			<span class="number">2</span>）、manual：手动确认</span><br><span class="line">				<span class="number">1</span>、可以自己灵活的控制消息的确认和拒收</span><br><span class="line">				<span class="number">2</span>、注意：开启这个机制后一定要记得手动回执，否则将造成消息大量堆积问题</span><br><span class="line">			<span class="number">3</span>）、auto：自动确认</span><br><span class="line">				优点：</span><br><span class="line">					出现异常返回nack，正常执行返回ack，无需编写业务代码、无侵入（原理：AOP）</span><br><span class="line">				缺点：</span><br><span class="line">					当消费消息出现异常返回nack时会一直反复投递，解决：开启消费者重试机制（有一个最大重试次数）</span><br><span class="line">				消费者重试机制：</span><br><span class="line">					消息消费失败，消费者会自己发起重试，重试间隔和最大重试次数可灵活配置</span><br><span class="line">				    当超过最大重试次数时，消费者对于消息会有几种执行策略：</span><br><span class="line">						<span class="number">1</span>、直接丢弃：该消息从MQ删除</span><br><span class="line">						<span class="number">2</span>、放回队列：将消息放回至队列，然后投递给消费者，消费者进行重试，如此循环往复</span><br><span class="line">						<span class="number">3</span>、投递至指定的交换机（常用）：将消息投递至专用的交换机，绑定队列后进行精准消费</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="3、Rabbitmq如何实现延时消息？（2种）"><a href="#3、Rabbitmq如何实现延时消息？（2种）" class="headerlink" title="3、Rabbitmq如何实现延时消息？（2种）"></a>3、Rabbitmq如何实现延时消息？（2种）</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、利用死信交换机实现延时投递</span><br><span class="line">			原理：</span><br><span class="line">				消息超时未被消费会被投递至死信队列</span><br><span class="line">			设置超时：</span><br><span class="line">				<span class="number">1</span>、针对消息设置延时时间</span><br><span class="line">				<span class="number">2</span>、针对队列设置延时时间</span><br><span class="line">		<span class="number">2</span>、利用延时交换机插件实现延时投递</span><br><span class="line">			原理：</span><br><span class="line">				交换机延时路由，到达指定时间会被路由至队列</span><br></pre></td></tr></table></figure></div>

<h2 id="4、什么是死信队列？什么样的消息会进入死信队列？"><a href="#4、什么是死信队列？什么样的消息会进入死信队列？" class="headerlink" title="4、什么是死信队列？什么样的消息会进入死信队列？"></a>4、什么是死信队列？什么样的消息会进入死信队列？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">死信队列：</span><br><span class="line">			当消息在一个队列中变成一个死信之后，如果配置了死信队列，它将被重新publish到死信交换机，</span><br><span class="line">			死信交换机将死信投递到一个队列上，这个队列就是死信队列</span><br><span class="line">		什么样的消息会进入死信队列</span><br><span class="line">			<span class="number">1</span>、超时过期的消息</span><br><span class="line">			<span class="number">2</span>、被拒绝或者nack的消息</span><br><span class="line">			<span class="number">3</span>、队列放不下的消息</span><br></pre></td></tr></table></figure></div>

<h2 id="5、Rabbitmq如何解决消息堆积问题？（3种思路）"><a href="#5、Rabbitmq如何解决消息堆积问题？（3种思路）" class="headerlink" title="5、Rabbitmq如何解决消息堆积问题？（3种思路）"></a>5、Rabbitmq如何解决消息堆积问题？（3种思路）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、针对同一队列增加多个消费者进行消息消费</span><br><span class="line">		2、针对同一消费者开启多个线程进行消息消费</span><br><span class="line">		3、加大队列的存储容量：</span><br><span class="line">			惰性队列</span><br><span class="line">			1）、原理：直接将消息写到磁盘</span><br><span class="line">			2）、优点：存储容量大，减少从内存刷消息数据至磁盘的次数，性能更稳定</span><br><span class="line">			3）、缺点：性能取决于磁盘IO</span><br></pre></td></tr></table></figure></div>

<h2 id="6、如何保证消息的幂等性？（从业务层面进行判断）"><a href="#6、如何保证消息的幂等性？（从业务层面进行判断）" class="headerlink" title="6、如何保证消息的幂等性？（从业务层面进行判断）"></a>6、如何保证消息的幂等性？（从业务层面进行判断）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、数据要写mysql，先根据主键查一下，如果这数据都有了，就别插入了，update一下</span><br><span class="line">		2、如果是写redis，那没问题了，反正每次都是set，天然幂等性</span><br><span class="line">		3、让生产者发送每条数据的时候，里面加一个全局唯一的id，然后你这里消费到了之后，先根据这个id去数据库查一下，之前消费过吗？</span><br><span class="line">		  如果没有消费过，就处理，然后这个id写到数据库。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可</span><br></pre></td></tr></table></figure></div>

<h1 id="八、微服务"><a href="#八、微服务" class="headerlink" title="八、微服务"></a>八、微服务</h1><h2 id="1、概念问题"><a href="#1、概念问题" class="headerlink" title="1、概念问题"></a>1、概念问题</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）、什么是微服务？解决微服务各种问题都用了哪些组件？</span><br><span class="line">			微服务：</span><br><span class="line">				一种良好的分布式架构方案</span><br><span class="line">				<span class="number">1</span>、优点：拆分粒度更小、服务更独立、耦合度更低</span><br><span class="line">				<span class="number">2</span>、缺点：架构非常复杂，运维、监控、部署难度提高</span><br><span class="line">			组件：</span><br><span class="line">				<span class="number">1</span>、Nacos：</span><br><span class="line">					服务注册中心和配置中心</span><br><span class="line">				<span class="number">2</span>、Ribbon：</span><br><span class="line">					服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</span><br><span class="line">				<span class="number">3</span>、Feign：</span><br><span class="line">					基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</span><br><span class="line">				<span class="number">4</span>、Hystrix：</span><br><span class="line">					发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</span><br><span class="line">				<span class="number">5</span>、Gateway：</span><br><span class="line">					如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</span><br><span class="line"></span><br><span class="line">		<span class="number">2</span>）、什么是单体架构、什么是分布式架构、什么是微服务架构？</span><br><span class="line">			单体架构：</span><br><span class="line">				将业务的所有功能集中在一个项目中开发，打成一个包部署</span><br><span class="line">				优点：</span><br><span class="line">					架构简单</span><br><span class="line">					部署成本低</span><br><span class="line">				缺点：</span><br><span class="line">					耦合度高（维护困难、升级困难）</span><br><span class="line">			分布式架构：</span><br><span class="line">				根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务</span><br><span class="line">				优点：</span><br><span class="line">					降低服务耦合</span><br><span class="line">					有利于服务升级和拓展</span><br><span class="line">				缺点：</span><br><span class="line">					服务调用关系错综复杂</span><br><span class="line">			微服务的架构：</span><br><span class="line">				给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</span><br><span class="line">				因此，可以认为微服务是一种经过良好架构设计的分布式架构方案</span><br><span class="line"></span><br><span class="line">		<span class="number">3</span>）、微服务有哪些特点？</span><br><span class="line">			单一职责：</span><br><span class="line">				微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</span><br><span class="line">			自治：</span><br><span class="line">				团队独立、技术独立、数据独立，独立部署和交付</span><br><span class="line">			面向服务：</span><br><span class="line">				服务提供统一标准的接口，与语言和技术无关</span><br><span class="line">			隔离性强：</span><br><span class="line">				服务调用做好隔离、容错、降级，避免出现级联问题</span><br></pre></td></tr></table></figure></div>

<h2 id="2、远程调用"><a href="#2、远程调用" class="headerlink" title="2、远程调用"></a>2、远程调用</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="number">1</span>）、什么是Feign，用来做什么的？Feign底层调用是怎么实现的？底层协议是什么？优势是什么？</span><br><span class="line">	Feign：</span><br><span class="line">		Feign是一个声明式WebService客户端。</span><br><span class="line">		使用Feign能让编写Web Service客户端更加简单，它的使用方法就是定义一个接口，然后在上面添加注解，同时也支持JAX-RS标准</span><br><span class="line">	作用：</span><br><span class="line">		使编写 java http 客户端变得容易，封装了Http调用流程，更适合面向接口化的编程习惯</span><br><span class="line">	底层调用实现流程;</span><br><span class="line">		<span class="number">1</span>、基于面向接口的动态代理方式生成实现类</span><br><span class="line">		<span class="number">2</span>、根据Contract协议规则，解析接口类的注解信息，解析成内部表现</span><br><span class="line">		<span class="number">3</span>、基于RequestBean，动态生成Request</span><br><span class="line">		<span class="number">4</span>、使用Encoder将Bean转换成Http报文正文（消息解析和转码逻辑）</span><br><span class="line">		<span class="number">5</span>、拦截器负责对请求和返回进行装饰处理</span><br><span class="line">		<span class="number">6</span>、日志记录</span><br><span class="line">		<span class="number">7</span>、基于重试器发送HTTP请求</span><br><span class="line">		<span class="number">8</span>、发送Http请求</span><br><span class="line">	底层协议：</span><br><span class="line">		Https协议</span><br><span class="line">	优势： </span><br><span class="line">      		<span class="number">1.</span>feign 采用的是基于接口的注解</span><br><span class="line">		<span class="number">2.</span>feign 整合了 ribbon，具有负载均衡的能力</span><br><span class="line">		<span class="number">3.</span>整合了 Hystrix，具有熔断的能力</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）、服务间调用，其中一个服务宕机了，这个时候怎么做呢？</span><br><span class="line">	<span class="number">1</span>、超时处理</span><br><span class="line">	<span class="number">2</span>、舱壁模式（隔离）</span><br><span class="line">	<span class="number">3</span>、熔断，降级</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）、Ribbon是什么？负载均衡策略有哪些？底层原理是什么？默认是哪种？</span><br><span class="line">	Ribbon：</span><br><span class="line">		主要功能是提供客户端的软件负载均衡算法</span><br><span class="line">	负载均衡策略：</span><br><span class="line">		<span class="number">1</span>、随机策略：</span><br><span class="line">			随机选择server</span><br><span class="line">		<span class="number">2</span>、轮询策略：</span><br><span class="line">			按照顺序选择server（ribbon默认策略）</span><br><span class="line">		<span class="number">3</span>、重试策略：</span><br><span class="line">			在一个配置时间段内，当选择server不成功，则一直尝试选择一个可用的server</span><br><span class="line">		<span class="number">4</span>、最低并发策略：</span><br><span class="line">			逐个考察server，如果server断路器打开，则忽略，再选择其中并发链接最低的server</span><br><span class="line">		<span class="number">5</span>、可用过滤策略：</span><br><span class="line">			过滤掉一直失败并被标记为 circuit tripped 的 server，过滤掉那些高并发链接的 server（active connections超过配置的阈值）</span><br><span class="line">		<span class="number">6</span>、响应时间加权重策略：</span><br><span class="line">			根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低</span><br><span class="line">		<span class="number">7</span>、区域权重策略：</span><br><span class="line">			综合判断server所在区域的性能，和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，</span><br><span class="line">			剔除不可用的Zone中的所有server</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）、Ribbon是如何实现轮询的？如果让你自己实现轮询，如何实现？	</span><br><span class="line">	原理：</span><br><span class="line">		rest 接口的第几次请求数 % 服务器集群总数量 = 实际调用服务器的下标，每次服务重启，rest接口计数从<span class="number">1</span>开始</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）、Feign和Ribbon的关系是什么？</span><br><span class="line">	Feign 是在 Ribbon的基础上进行了一次改进，是一个使用起来更加方便的 HTTP 客户端</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）、你们项目中如何使用Feign的（Feign的最佳实践）</span><br><span class="line">	将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）、Feign远程调用时的日志级别有哪些？</span><br><span class="line">	<span class="number">1</span>、NONE，无记录（DEFAULT）</span><br><span class="line">　　　　		<span class="number">2</span>、BASIC，只记录请求方法和URL以及响应状态代码和执行时间</span><br><span class="line">　　　　		<span class="number">3</span>、HEADERS，记录基本信息以及请求和响应标头</span><br><span class="line">　　　　		<span class="number">4</span>、FULL，记录请求和响应的头文件，正文和元数据</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>）、如何优化Feign的调用性能？</span><br><span class="line">	<span class="number">1</span>、配置连接池</span><br><span class="line">	<span class="number">2</span>、设置合理的日志级别（basic级别就ok了，强烈不建议使用full）</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）、Feign的默认超时时间是多久？重试次数是几次？</span><br><span class="line">	默认超时时间：</span><br><span class="line">		<span class="number">1</span>秒</span><br><span class="line">	重试次数：</span><br><span class="line">		<span class="number">1</span>次</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>）、Dubbo服务注册与发现的原理？（官方原理图）</span><br><span class="line">	<span class="number">1</span>、服务器容器负责启动、加载、运行服务提供者</span><br><span class="line">	<span class="number">2</span>、服务提供者在启动时，向注册中心注册自己提供的服务</span><br><span class="line">	<span class="number">3</span>、服务消费者在启动时，向注册中心订阅自己需要的服务</span><br><span class="line">	<span class="number">4</span>、注册中心返沪服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</span><br><span class="line">	<span class="number">5</span>、服务消费者从提供者地址列表中基于负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用</span><br><span class="line">	<span class="number">6</span>、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>）、Dubbo负载均衡策略有哪些？默认是哪种？</span><br><span class="line">	<span class="number">1</span>、Random LoadBalance（默认）：</span><br><span class="line">		随机，按权重设置随机概率</span><br><span class="line">	<span class="number">2</span>、RoundRobin LoadBalance: </span><br><span class="line">		轮询，按公约后的权重设置轮询比例</span><br><span class="line">	<span class="number">3</span>、LeastActive LoadBalance：</span><br><span class="line">		最少活跃调用数，相同活跃数的随机</span><br><span class="line">	<span class="number">4</span>、ConstantHash LoadBalance：</span><br><span class="line">		一致性 Hash，相同参数的请求总是发到同意提供者</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>）、Dubbo支持哪些通信协议？默认是哪种？一般用哪种协议？有什么好处？</span><br><span class="line">	Dubbo支持<span class="number">9</span>种通信协议：</span><br><span class="line">		<span class="number">1</span>、dubbo 协议</span><br><span class="line">		<span class="number">2</span>、rmi 协议</span><br><span class="line">		<span class="number">3</span>、hessian 协议</span><br><span class="line">		<span class="number">4</span>、http 协议</span><br><span class="line">		<span class="number">5</span>、webservice 协议</span><br><span class="line">		<span class="number">6</span>、thrift 协议</span><br><span class="line">		<span class="number">7</span>、memcached 协议</span><br><span class="line">		<span class="number">8</span>、redis 协议</span><br><span class="line">		<span class="number">9</span>、rest</span><br><span class="line">	默认是哪种：</span><br><span class="line">		dubbo 协议 (默认)</span><br><span class="line">	一般用哪种协议：</span><br><span class="line">		dubbo 协议</span><br><span class="line">	好处：</span><br><span class="line">		底层是TCP，效率快</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>）、注册中心挂了影响服务调用吗？为什么？</span><br><span class="line">	不会</span><br><span class="line">	因为启动dubbo时，消费者会从注册中心拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>）、Dubbo启动检查如何设置？多版本支持如何设置？</span><br><span class="line">	启动检查：</span><br><span class="line">		可以通过配置信息 check=<span class="string">&quot;false&quot;</span> 关闭检查</span><br><span class="line">	多版本支持：</span><br><span class="line">		<span class="meta">@DubboService(version = “2.0.0”)</span></span><br><span class="line">		<span class="meta">@DubboReference(version = &quot;2.0.0&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>）、Dubbo的默认超时时间是多久？重试次数是几次？</span><br><span class="line">	默认超时时间：</span><br><span class="line">		<span class="number">1</span>秒</span><br><span class="line">	默认重试次数：</span><br><span class="line">		<span class="number">2</span>次</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>）、Dubbo进行服务注册和发现的核心注解是哪个？</span><br><span class="line">	<span class="meta">@DubboService</span></span><br><span class="line">	<span class="meta">@DubboReference</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>）、Dubbo服务如何进行监控和管理？</span><br><span class="line">	dubbo-admin 监控中心</span><br></pre></td></tr></table></figure></div>

<h2 id="3、注册中心"><a href="#3、注册中心" class="headerlink" title="3、注册中心"></a>3、注册中心</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3、配置中心1）、Eureka</span><br><span class="line">			1、eureka是属于什么体系的技术（Spring Cloud）</span><br><span class="line">				Spring Cloud</span><br><span class="line">			2、eureka技术体系有哪些角色？（服务端用作注册中心，客户端用作微服务）</span><br><span class="line">				服务端用作注册中心，客户端用作微服务</span><br><span class="line">			3、eureka的自我保护机制是什么？什么时候开启？为什么开启？开启了会发生什么？</span><br><span class="line">				自我保护机制：</span><br><span class="line">					某时刻某个微服务不能用了，eureka不会立刻清理，而是对该微服务进行保存</span><br><span class="line">				开启时间：</span><br><span class="line">					当EurekaServer节点在短时间内丢失过多客户端时候(可能发生了网络分区故障)</span><br><span class="line">				为什么开启：</span><br><span class="line">					默认情况下，如果EurekaServer在一定时间内没有收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90s)。</span><br><span class="line">					但是当网络分区故障发生(延时、卡顿、拥挤)时候，微服务与EurekaServer之间无法正常通信，</span><br><span class="line">					以上行为可能变得非常危险了，因为微服务本身其实是健康的。此时本不应该注销这个微服务的</span><br><span class="line">				开启了会发生什么：</span><br><span class="line">					一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据。也就是不会注销任何微服务</span><br><span class="line"></span><br><span class="line">			4、eureka作为注册中心的原理是什么？心跳检测某个服务是否健康的原理详细说下？</span><br><span class="line">				原理：</span><br><span class="line">					1、服务提供者启动后将注册到注册中心，提供IP, 名字，什么服务等信息，</span><br><span class="line">				    2、服务消费者作为客户端注册到注册中心后，拉取注册中心的服务列表，在通过负载均衡调用对应的服务提供者。</span><br><span class="line">				    3、注册中心可以建立集群，生成多台eureka，注册中心为了监测各个服务的心跳，将在每 30S 向所注册的服务发起请求判断</span><br><span class="line">				    4、服务是否挂掉，如果挂掉90S后将会将服务从注册中心剔除。</span><br><span class="line">				      一个服务可以监测多台服务实例，从而可实现均衡负载。</span><br><span class="line">				心跳检测：</span><br><span class="line">					在应用启动后，节点们将会向Eureka Server发送心跳,默认周期为30秒，</span><br><span class="line">					如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，</span><br><span class="line">					Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)。</span><br><span class="line"></span><br><span class="line">			5、eureka集群是属于AP还是CP？(AP)</span><br><span class="line">				AP</span><br><span class="line">	2）、Nacos</span><br><span class="line">			1、nacos是属于什么体系的技术（Spring Cloud Alibaba）</span><br><span class="line">				Spring Cloud Alibaba</span><br><span class="line"></span><br><span class="line">			2、nacos作为注册中心的原理是什么？</span><br><span class="line">				服务注册时在服务端本地会通过轮询注册中心集群节点地址进行服务注册，</span><br><span class="line">				在注册中心上，即Nacos Server上采用了Map保存实例信息，当然配置了持久化的服务会被保存到数据库中，</span><br><span class="line">				在服务的调用方，为了保证本地服务实例列表的动态感知，Nacos与其他注册中心不同的是，采用了 Pull/Push同时运作的方式</span><br><span class="line"></span><br><span class="line">			3、nacos如何确定唯一的一个服务?（通过namespace、group、service、集群唯一确定一个服务）</span><br><span class="line">				通过namespace、group、service、集群唯一确定一个服务</span><br><span class="line"></span><br><span class="line">			4、nacos中namespace、group分别的作用是什么？</span><br><span class="line">				namespace：</span><br><span class="line">					用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置</span><br><span class="line">				group：</span><br><span class="line">					Nacos中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串对配置集进行分组，从而区分 Data ID 相同的配置集</span><br><span class="line"></span><br><span class="line">			5、nacos和eureka的异同有哪些？</span><br><span class="line">				相同点：</span><br><span class="line">					1、都支持服务注册和服务拉取</span><br><span class="line">					2、都支持服务提供者心跳的方式做健康检测</span><br><span class="line">				不同点：</span><br><span class="line">					1、nacos支持服务端主动检测提供者状态：</span><br><span class="line">						临时实例采用心跳模式，非临时实例采用主动检测模式（一般情况下都使用临时实例，主动检测消费的服务器资源较大，服务器压力大）</span><br><span class="line">					2、临时实例心跳不正常会被剔除，非临时实例则不会被剔除</span><br><span class="line">					3、nacos支持服务列表变更的消息推送模式，服务列表更新及时</span><br><span class="line">					4、nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；eureka采用AP方式</span><br><span class="line"></span><br><span class="line">			6、nacos的临时节点和非临时节点有什么区别？</span><br><span class="line">				非临时实例挂掉后不会被nacos剔除，而是等待他重连</span><br><span class="line"></span><br><span class="line">			7、nacos集群是属于AP还是CP？(AP或CP)</span><br><span class="line">				nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式</span><br><span class="line">			</span><br><span class="line">		3）、Zookeeper</span><br><span class="line">			1、Zookeeper的内部结构是什么？</span><br><span class="line">				ZooKeeper维护和操作一个小型的数据节点，这些节点被称之为znode，采用类似于文件系统的层级树状结构进行管理</span><br><span class="line"></span><br><span class="line">			2、使用Zookeeper作为分布式事务锁的原理是什么？</span><br><span class="line">				锁分为两种：</span><br><span class="line">					共享锁（读锁）和排他锁（写锁）</span><br><span class="line">				读锁：</span><br><span class="line">					当有一个线程获取读锁后，其他线程也可以获取读锁，但是在读锁没有完全被释放之前，其他线程不能获取写锁。</span><br><span class="line">				写锁：</span><br><span class="line">					当有一个线程获取写锁后，其他线程就无法获取读锁和写锁了。</span><br><span class="line">				zookeeper 有一种节点类型叫做临时序号节点，它会按序号自增地创建临时节点，这正好可以作为分布式锁的实现工具。</span><br><span class="line"></span><br><span class="line">			3、Zookeeper集群属于AP还是CP？(CP)</span><br><span class="line">				CP</span><br></pre></td></tr></table></figure></div>

<h2 id="3、配置中心"><a href="#3、配置中心" class="headerlink" title="3、配置中心"></a>3、配置中心</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）、实现配置中心都可以使用哪些技术？</span><br><span class="line">			1、Spring Cloud Config</span><br><span class="line">			2、Apollo</span><br><span class="line">			3、Nacos</span><br><span class="line"></span><br><span class="line">		2）、使用nacos作为配置中心，如何实现热更新？</span><br><span class="line">			1、在 @Value 注入的变量所在的类上添加注解 @RefreshScope</span><br><span class="line">			2、使用 @ConfigurationProperties(prefix = &quot;pattern&quot;) 注解</span><br><span class="line"></span><br><span class="line">		3）、nacos作为配置中心，为什么需要用到bootstrap文件？</span><br><span class="line">			得知nacos地址、配置文件id</span><br><span class="line"></span><br><span class="line">		4）、远程配置文件和本地配置文件属性加载优先级是什么样的？</span><br><span class="line">			远程 &gt; 本地</span><br><span class="line">			高优先级的会覆盖低优先级的重复的配置内容</span><br><span class="line"></span><br><span class="line">		5）、使用配置中心的好处是什么？能解决什么问题？</span><br><span class="line">			好处：</span><br><span class="line">				将配置文件集中管理</span><br><span class="line">			解决的问题：</span><br><span class="line">				可以在配置变更时，及时通知微服务，实现配置的热更新</span><br></pre></td></tr></table></figure></div>

<h2 id="4、服务保护"><a href="#4、服务保护" class="headerlink" title="4、服务保护"></a>4、服务保护</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）、Hystrix</span><br><span class="line">			1、hystrix是属于什么体系的技术？（SpringCloud）</span><br><span class="line">				SpringCloud</span><br><span class="line"></span><br><span class="line">			2、hystrix可以用来干嘛？（服务熔断降级）</span><br><span class="line">				服务熔断降级</span><br><span class="line"></span><br><span class="line">			3、hystrix默认的触发熔断策略是什么？（5分钟之内服务调用异常比例达到一半或者失败次数超过20次）</span><br><span class="line">				5分钟之内服务调用异常比例达到一半或者失败次数超过20次</span><br><span class="line"></span><br><span class="line">			4、hystrix的隔离是基于什么？（线程池隔离【低扇出】）</span><br><span class="line">				线程池隔离（低扇出）</span><br><span class="line"></span><br><span class="line">		2）、Sentinel</span><br><span class="line">			1、sentinel可以用来干嘛？（限流、隔离、熔断、降级）</span><br><span class="line">				限流、隔离、熔断、降级</span><br><span class="line"></span><br><span class="line">			2、什么是微服务雪崩现象？如何解决微服务雪崩问题？</span><br><span class="line">				微服务雪崩：</span><br><span class="line">					微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况</span><br><span class="line">				解决方案：</span><br><span class="line">					 1、超时处理</span><br><span class="line">				     2、船壁模式（隔离）</span><br><span class="line">				     3、熔断，降级</span><br><span class="line"></span><br><span class="line">			3、sentinel的限流模式有哪些？分别的运用场景是什么？</span><br><span class="line">				1、直接：</span><br><span class="line">					对当前资源限流</span><br><span class="line">			    2、关联： </span><br><span class="line">			    	比如用户支付时需要修改订单状态，同时用户要查询订单。</span><br><span class="line">					查询和修改操作会争抢数据库锁，产生竞争。</span><br><span class="line">					业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</span><br><span class="line">			    3、链路：</span><br><span class="line">			    	阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流</span><br><span class="line"></span><br><span class="line">			4、sentinel的限流效果有哪些？分别的运用场景是什么？</span><br><span class="line">				1、快速失败：</span><br><span class="line">					QPS超过阈值时，拒绝新的请求</span><br><span class="line">	      		2、warm up：</span><br><span class="line">	      			QPS超过阈值时，拒绝新的请求；</span><br><span class="line">	      			QPS阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机</span><br><span class="line">	      		3、排队等待：</span><br><span class="line">	      			请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝</span><br><span class="line">	      		4、热点参数：</span><br><span class="line">	      			分别统计参数值相同的请求，判断是否超过QPS阈值</span><br><span class="line"></span><br><span class="line">			5、sentinel支持对热点参数进行限流吗？</span><br><span class="line">				支持</span><br><span class="line"></span><br><span class="line">			6、实现微服务调用隔离有两种方式（信号量隔离和线程池隔离），区别是什么？sentinel是使用的哪种？</span><br><span class="line">				区别：</span><br><span class="line">					1、信号量隔离：</span><br><span class="line">			            不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</span><br><span class="line">			            特点：基于计数器模式，简单，开销小；高扇出</span><br><span class="line">		    		2、线程池隔离</span><br><span class="line">			            给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</span><br><span class="line">			            特点：基于线程池模式，有额外开销，但隔离控制更强；低扇出</span><br><span class="line">			    sentinel是使用的哪种：</span><br><span class="line">			    	信号量隔离</span><br><span class="line"></span><br><span class="line">			7、什么是熔断？熔断的原理是什么？什么时候会触发sentinel的熔断？断路器的三种状态是哪些？是怎样进行切换的？</span><br><span class="line">				概念：</span><br><span class="line">					熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），</span><br><span class="line">					对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误</span><br><span class="line">				熔断的原理：</span><br><span class="line">					断路器</span><br><span class="line">				什么时候会触发sentinel的熔断：</span><br><span class="line">					1、慢调用</span><br><span class="line">					2、异常比例或者异常数</span><br><span class="line">				断路器的三种状态是哪些，是怎样进行切换的：</span><br><span class="line">					1、关闭：默认就是关闭的</span><br><span class="line">					2、半开：开启后到达指定（可配置）的时间，开启半开状态，尝试接收请求</span><br><span class="line">									如果成功：状态置为关闭</span><br><span class="line">									如果失败：状态置为开启</span><br><span class="line">					3、开启：当触发配置的阈值，会开启</span><br><span class="line"></span><br><span class="line">			8、什么是降级？如何实现降级？</span><br><span class="line">				概念：</span><br><span class="line">					当微服务调用失败，客户端走降级逻辑</span><br><span class="line">				如何实现降级：</span><br><span class="line">					1、FallBackClass</span><br><span class="line">					2、FallBackFactoryClass（优势：可以获取服务端抛出的异常）</span><br><span class="line"></span><br><span class="line">			9、sentinel授权规则是用来干什么的？</span><br><span class="line">				授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式：</span><br><span class="line">					1、白名单：来源（origin）在白名单内的调用者允许访问</span><br><span class="line">					2、黑名单：来源（origin）在黑名单内的调用者不允许访问</span><br><span class="line"></span><br><span class="line">			10、sentinel的规则持久化方式有哪些？一般使用哪种？</span><br><span class="line">				sentinel的规则持久化方式：</span><br><span class="line">					1、原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。</span><br><span class="line">				    2、pull模式</span><br><span class="line">				    3、push模式</span><br><span class="line">			    一般使用哪种：</span><br><span class="line">			    	push模式</span><br></pre></td></tr></table></figure></div>

<h2 id="5、网关"><a href="#5、网关" class="headerlink" title="5、网关"></a>5、网关</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）、网关有什么作用？在你们项目中用网关来干嘛了？</span><br><span class="line">			1、权限控制：</span><br><span class="line">				网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</span><br><span class="line">			2、路由和负载均衡：</span><br><span class="line">				一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。</span><br><span class="line">				当然路由的目标服务有多个时，还需要做负载均衡。</span><br><span class="line">			3、限流：</span><br><span class="line">				当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</span><br><span class="line"></span><br><span class="line">		2）、网关的核心技术点有哪些？</span><br><span class="line">			1、断言工厂</span><br><span class="line">			2、过滤器工厂</span><br><span class="line">			3、全局过滤器</span><br><span class="line">			4、解决跨域</span><br><span class="line"></span><br><span class="line">		3）、网关的路由是用来干嘛的？分为哪几种？</span><br><span class="line">			路由的作用：</span><br><span class="line">				一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务</span><br><span class="line">			分为哪几种：</span><br><span class="line">				静态路由、动态路由</span><br><span class="line"></span><br><span class="line">		4）、网关的过滤器是用来干嘛的？分为哪几种？</span><br><span class="line">			网关的过滤器作用：</span><br><span class="line">				可以对进入网关的请求和微服务返回的响应做处理</span><br><span class="line">			分为哪几种：</span><br><span class="line">				1、路由过滤器</span><br><span class="line">				2、请求头过滤器</span><br><span class="line">				3、默认过滤器</span><br><span class="line"></span><br><span class="line">		5）、网关局部过滤器和全局过滤器的区别有哪些？</span><br><span class="line">			局部过滤器：</span><br><span class="line">				拦截经过网关的特定服务的请求</span><br><span class="line">			全局过滤器：</span><br><span class="line">				无差别拦截所有经过网关 的请求</span><br><span class="line"></span><br><span class="line">		6）、网关中局部过滤器、默认过滤器、全局过滤器的执行顺序是什么？</span><br><span class="line">			默认过滤器 &gt; 局部过滤器 &gt; 全局过滤器</span><br><span class="line"></span><br><span class="line">		7）、加入网关后，访问一个链接，你们项目的执行流程是什么？</span><br><span class="line">			1、客户端发送请求</span><br><span class="line">			2、进行权限校验，如果是登录或者注册操作则直接放行</span><br><span class="line">			3、校验通过生成该用户的token，校验失败拦截</span><br><span class="line">			4、路由匹配到某个微服务</span><br><span class="line"></span><br><span class="line">		8）、定义全局过滤器需要实现哪几个接口？</span><br><span class="line">			GlobalFilter</span><br></pre></td></tr></table></figure></div>

<h2 id="6、分布式事务"><a href="#6、分布式事务" class="headerlink" title="6、分布式事务"></a>6、分布式事务</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）、什么是本地事务？什么是分布式事务？</span><br><span class="line">			本地事务：</span><br><span class="line">				无需跨越多个服务或者数据源的单体事务，一般由spring控制即可（声明式事务处理：AOP）</span><br><span class="line">			分布式事务：</span><br><span class="line">				指一个业务跨越多个服务或者数据源，每个事务叫做分支事务，要保证所有分支事务要么成功，要么失败</span><br><span class="line"></span><br><span class="line">		2）、什么是CAP定理？为什么必须保证P？为什么在保证P的前提下只能保证C或者A其中一个？</span><br><span class="line">			CAP定理：</span><br><span class="line">				Consistency（一致性）、Availability（可用性）、Partition tolerance （分区容错性），这三个指标不可能同时做到</span><br><span class="line">			为什么必须保证P：	</span><br><span class="line">				在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免</span><br><span class="line">			为什么在保证P的前提下只能保证C或者A其中一个：</span><br><span class="line">				如果此时要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</span><br><span class="line">				如果此时要保证可用性，就不能等待网络恢复，那 node01、node02、node03 之间就会出现数据不一致。</span><br><span class="line"></span><br><span class="line">		3）、什么是BASE理论？</span><br><span class="line">			BASE理论是对CAP的一种解决思路，包含三个思想：</span><br><span class="line">				1、Basically Available（基本可用）：</span><br><span class="line">					分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</span><br><span class="line">				2、Soft State（软状态）：</span><br><span class="line">					在一定时间内，允许出现中间状态，比如临时的不一致状态</span><br><span class="line">				3、Eventually Consistent（最终一致性）：</span><br><span class="line">					虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</span><br><span class="line"></span><br><span class="line">		4）、seata解决分布式事务的三个角色以及分别的作用什么？</span><br><span class="line">			1、TC (Transaction Coordinator) - 事务协调者：</span><br><span class="line">				维护全局和分支事务的状态，协调全局事务提交或回滚</span><br><span class="line">            2、TM (Transaction Manager) - 事务管理器：</span><br><span class="line">            	定义全局事务的范围、开始全局事务、提交或回滚全局事务</span><br><span class="line">            3、RM (Resource Manager) - 资源管理器：</span><br><span class="line">            	管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</span><br><span class="line"></span><br><span class="line">		5）、seata解决分布式事务的四种模式</span><br><span class="line">			1、XA</span><br><span class="line">			2、AT</span><br><span class="line">			3、TCC</span><br><span class="line">			4、SAGA</span><br><span class="line"></span><br><span class="line">		6）、XA模式特点、原理以及应用场景？优缺点有哪些？</span><br><span class="line">			特点：</span><br><span class="line">				强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入 （CP）</span><br><span class="line">			原理：</span><br><span class="line">				1）、第一阶段：</span><br><span class="line">					1、TM：</span><br><span class="line">						1、开启全局事务</span><br><span class="line">						2、调用分支事务</span><br><span class="line">					2、TC: </span><br><span class="line">						接收开启全局事务的请求</span><br><span class="line">					3、RM: </span><br><span class="line">						1、将分支事务注册到TC服务</span><br><span class="line">						2、执行本地sql，但是，重点：不提交事务！！！！</span><br><span class="line">						3、将本地事务状态报告至TC服务	</span><br><span class="line">				2）、第二阶段：</span><br><span class="line">					1、TM：</span><br><span class="line">						等第一阶段所有分支事务执行完，发起提交/回滚全局事务的命令</span><br><span class="line">					2、TC:</span><br><span class="line">						接收全局事务提交/回滚请求，核查所有分支事务的状态，对RM发起提交/回滚的命令</span><br><span class="line">					3、RM:</span><br><span class="line">						提交或者回滚当前的分支事务(依赖于数据库)</span><br><span class="line">			优点：</span><br><span class="line">				强一致性、无代码侵入、实现简单</span><br><span class="line">			缺点：</span><br><span class="line">				强依赖于关系型数据库实现回滚、性能比较差</span><br><span class="line"></span><br><span class="line">		7）、AT模式特点、原理以及应用场景？优缺点有哪些？有可能会出现什么问题？如何解决？</span><br><span class="line">			特点：</span><br><span class="line">				同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷，属于最终一致（AP）</span><br><span class="line">			原理：</span><br><span class="line">				1）、第一阶段：</span><br><span class="line">					1、TM:</span><br><span class="line">						1、开启全局事务</span><br><span class="line">						2、调用分支事务</span><br><span class="line">					2、TC:</span><br><span class="line">						接收开启全局事务的请求</span><br><span class="line">					3、RM：</span><br><span class="line">						1、将分支事务注册到TC服务</span><br><span class="line">						2、执行本地sql，重点：提交事务！！！！</span><br><span class="line">						3、执行sql前后，生成快照:undo_log</span><br><span class="line">						4、将本地事务状态报告至TC服务</span><br><span class="line">				2）、第二阶段：</span><br><span class="line">					1、TM：</span><br><span class="line">						等第一阶段所有分支事务执行完，发起提交/回滚全局事务的命令</span><br><span class="line">					2、TC:</span><br><span class="line">						接收全局事务提交/回滚请求，核查所有分支事务的状态，对RM发起提交/回滚的命令</span><br><span class="line">					3、RM:</span><br><span class="line">						提交或者回滚当前的分支事务（依赖于undo_log快照数据）</span><br><span class="line">						提交：删除快照数据</span><br><span class="line">						回滚：根据快照进行数据恢复</span><br><span class="line">			优点：</span><br><span class="line">				1、一阶段完成直接提交事务，释放数据库资源，性能比较好</span><br><span class="line">				2、利用全局锁实现读写隔离</span><br><span class="line">				3、没有代码侵入，框架自动完成回滚和提交</span><br><span class="line">			缺点：</span><br><span class="line">				1、两阶段之间属于软状态，属于最终一致</span><br><span class="line">				2、框架的快照功能会影响性能，但比XA模式要好很多</span><br><span class="line">			可能出现的问题：</span><br><span class="line">				脏写：当全局事务1提交修改的数据后，此时全局事务2又过来修改了这条数据</span><br><span class="line">					 后续阶段二全局事务1需要利用快照进行回滚，将全局事务2的所有修改进行了覆盖</span><br><span class="line">			解决方案：</span><br><span class="line">				seata内部提供了全局锁的概念（需要在seata server新增一张全局锁的表）</span><br><span class="line">				但是全局锁有可能导致死锁（内部通过限制获取全局锁的次数来解决：30次/10ms）</span><br><span class="line"></span><br><span class="line">		8）、重点：TCC模式特点、原理以及应用场景？优缺点有哪些？有可能会出现什么问题？什么是空回滚和业务悬挂，如何解决？</span><br><span class="line">			特点：</span><br><span class="line">				与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。属于最终一致（AP）</span><br><span class="line">			原理：</span><br><span class="line">				1、T: Try，进行资源的检测和预留</span><br><span class="line">				2、C：Confirm，对资源进行确认操作（业务执行和提交）</span><br><span class="line">				3、C：Cancle，对资源进行回滚操作（预留资源的释放）</span><br><span class="line">			优点：</span><br><span class="line">				1、一阶段完成直接提交事务，释放数据库资源，性能好</span><br><span class="line">				2、相比AT模型，无需生成快照，无需使用全局锁，性能最强</span><br><span class="line">				3、不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</span><br><span class="line">			缺点：</span><br><span class="line">				1、有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</span><br><span class="line">				2、软状态，事务是最终一致</span><br><span class="line">				3、需要考虑Confirm和Cancel的失败情况，做好幂等处理</span><br><span class="line">			可能出现的问题：</span><br><span class="line">				1、空回滚</span><br><span class="line">					问题描述：</span><br><span class="line">						当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。</span><br><span class="line">						在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，则就是空回滚。</span><br><span class="line">					解决办法：</span><br><span class="line">						执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。</span><br><span class="line">				2、业务悬挂</span><br><span class="line">					问题描述：</span><br><span class="line">						对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能</span><br><span class="line">					  	confirm或cancel ，事务一直处于中间状态，这就是业务悬挂。</span><br><span class="line">					解决办法：</span><br><span class="line">						执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂		</span><br><span class="line"></span><br><span class="line">		9）、SAGA模式特点、原理以及应用场景？优缺点有哪些？</span><br><span class="line">			概念：</span><br><span class="line">				Saga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。</span><br><span class="line">			原理：</span><br><span class="line">				在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</span><br><span class="line">				分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。</span><br><span class="line">				如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，</span><br><span class="line">				使分布式事务回到初始状态。</span><br><span class="line">			优点：</span><br><span class="line">				1、事务参与者可以基于事件驱动实现异步调用，吞吐高</span><br><span class="line">				2、一阶段直接提交事务，无锁，性能好</span><br><span class="line">				3、不用编写TCC中的三个阶段，实现简单</span><br><span class="line">			缺点：</span><br><span class="line">				1、软状态持续时间不确定，时效性差</span><br><span class="line">				2、没有锁，没有事务隔离，会有脏写</span><br></pre></td></tr></table></figure></div>

<h1 id="九、Docker"><a href="#九、Docker" class="headerlink" title="九、Docker"></a>九、Docker</h1><h2 id="1、什么是Docker？优点是什么？有哪些核心概念？"><a href="#1、什么是Docker？优点是什么？有哪些核心概念？" class="headerlink" title="1、什么是Docker？优点是什么？有哪些核心概念？"></a>1、什么是Docker？优点是什么？有哪些核心概念？</h2><p>概念：<br>            Docker是一个快速交付应用、运行应用的技术<br>        优点：<br>            1、可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统<br>            2、运行时利用沙箱机制形成隔离容器，各个应用互不干扰<br>            3、启动、移除都可以通过一行命令完成，方便快捷<br>        核心概念：<br>            解决大型项目依赖关系复杂，不同组件依赖的兼容性问题：<br>                1、Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像<br>                2、Docker应用运行在容器中，使用沙箱机制，相互隔离<br>            解决开发、测试、生产环境有差异的问题：<br>                Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</p>
<h2 id="2、镜像操作命令有哪些？"><a href="#2、镜像操作命令有哪些？" class="headerlink" title="2、镜像操作命令有哪些？"></a>2、镜像操作命令有哪些？</h2><p>拉取、推送、查看、查看所有、删除、删除所有、制作镜像、导出镜像、加载镜像</p>
<h2 id="3、容器操作命令有哪些？"><a href="#3、容器操作命令有哪些？" class="headerlink" title="3、容器操作命令有哪些？"></a>3、容器操作命令有哪些？</h2><p>查看所有、查看正在运行的容器、删除、强制删除、创建容器、创建并运行、<br>        启动容器、停止容器、重启容器、暂停容器、恢复容器、进入容器</p>
<h2 id="4、数据卷操作命令有哪些？"><a href="#4、数据卷操作命令有哪些？" class="headerlink" title="4、数据卷操作命令有哪些？"></a>4、数据卷操作命令有哪些？</h2><p>创建数据卷、查看单个数据卷详情、查看数据卷列表、删除数据卷、删除未使用的数据卷、创建容器时挂载数据卷</p>
<h2 id="5、docker如何自定义镜像？docker-file的语法是什么样的？"><a href="#5、docker如何自定义镜像？docker-file的语法是什么样的？" class="headerlink" title="5、docker如何自定义镜像？docker file的语法是什么样的？"></a>5、docker如何自定义镜像？docker file的语法是什么样的？</h2><p>自定义镜像：<br>            1、准备基础镜像和tar包<br>            2、创建Dockerfile<br>            3、使用Dockerfile创建镜像<br>        docker file的语法：<br>            保留字指令要大写，后边有空格，后边必须有内容。 比如：FROM scratch<br>             指令从上往下依次执行</p>
<h2 id="6、docker-compose是干嘛的-语法是什么样的？"><a href="#6、docker-compose是干嘛的-语法是什么样的？" class="headerlink" title="6、docker compose是干嘛的?语法是什么样的？"></a>6、docker compose是干嘛的?语法是什么样的？</h2><p>作用：<br>            调用docker服务的API负责实现对docker容器集群的快速编排，即通过一个单独的yaml文件，来定义一组相关的容器来为一个项目服务<br>        语法：<br>            一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分</p>
<h1 id="十、ElasticSearch"><a href="#十、ElasticSearch" class="headerlink" title="十、ElasticSearch"></a>十、ElasticSearch</h1><h2 id="1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？"><a href="#1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？" class="headerlink" title="1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？"></a>1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？</h2><p>概念：<br>            1）、是一款分布式、高性能、高扩展，支持海量数据分析、搜索、计算的搜索引擎<br>            2）、基于Java语言编写，发起的请求时基于Json风格的符合RestFull风格的DSL语句<br>            3）、前身Lucene诞生于1999年，2004年变为了compass，2010年重构成了现在的ES<br>            4）、ELK：是一个围绕ElasticSearch的技术栈，包含：ElasticSearch、Logstatch、Kibana，最新版本7.16.3<br>            5）、Solr：是ES的一款竞品，2016被ES反超，主流成为ES<br>        由什么语言编写:<br>            Java<br>        和Lunce的关系:<br>            前身Lucene诞生于1999年，2004年变为了compass，2010年重构成了现在的ES<br>        什么是ELK:<br>            是一个围绕ElasticSearch的技术栈，包含：ElasticSearch、Logstatch、Kibana，最新版本7.16.3    </p>
<h2 id="2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？"><a href="#2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？" class="headerlink" title="2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？"></a>2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？</h2><p>核心概念：<br>            1）、倒排索引<br>                对文档进行合理化的分词，形成一个不重复的词条列表，每一个词条对应一个文档id集合，将来根据文档分成词条找id，<br>                再根据id找到相应的文档（涉及到两次的Btree查询）<br>            2）、索引 – index<br>                同一类型文档的集合，相当于mysql的表<br>            3）、映射 – mapping<br>                对索引结构的约束，相当于mysql的schema（约束）（表结构）<br>            4）、文档 – document<br>                Json格式的数据，相当于mysql的row（行）<br>            5）、字段 – field<br>                一个个的字段，相当于mysql的列<br>            6）、DSL语句<br>                Json风格的符合restful风格的请求语句    </p>
<h2 id="3、什么是倒排索引？倒排索引建立过程？"><a href="#3、什么是倒排索引？倒排索引建立过程？" class="headerlink" title="3、什么是倒排索引？倒排索引建立过程？"></a>3、什么是倒排索引？倒排索引建立过程？</h2><p>倒排索引：<br>            对文档进行合理化的分词，形成一个不重复的词条列表，每一个词条对应一个文档id集合，将来根据文档分成词条找id，<br>            再根据id找到相应的文档（涉及到两次的Btree查询）<br>        倒排索引建立过程：<br>            1、将每一个文档的数据利用算法分词，得到一个个词条<br>            2、创建表，每行数据包括词条、词条所在文档id、位置等信息<br>            3、因为词条唯一性，可以给词条创建索引，例如hash表结构索引</p>
<h2 id="4、ES有哪些数据类型？keyword和text有什么区别？"><a href="#4、ES有哪些数据类型？keyword和text有什么区别？" class="headerlink" title="4、ES有哪些数据类型？keyword和text有什么区别？"></a>4、ES有哪些数据类型？keyword和text有什么区别？</h2><p>数据类型：<br>            1、字符串：<br>                text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）<br>            2、数值：<br>                long、integer、short、byte、double、float、<br>            3、布尔：<br>                boolean<br>            4、日期：<br>                date<br>            5、对象：<br>                object<br>        keyword和text有什么区别：<br>            text可分词，keyword不可分词</p>
<h2 id="5、重要：说说用户输入框输入查询条件-进行ES搜索的底层原理过程"><a href="#5、重要：说说用户输入框输入查询条件-进行ES搜索的底层原理过程" class="headerlink" title="5、重要：说说用户输入框输入查询条件 进行ES搜索的底层原理过程"></a>5、重要：说说用户输入框输入查询条件 进行ES搜索的底层原理过程</h2><p>1、如果用户输入条件“华为手机”进行搜索。<br>        2、对用户输入内容分词，得到词条：“华为”、“手机”。<br>        3、拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。<br>        4、拿着文档id到正向索引中查找具体文档。</p>
<h2 id="6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）"><a href="#6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）" class="headerlink" title="6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）"></a>6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）</h2><p>建立倒排索引时对文档分词和用户搜索时对搜索条件分词</p>
<h2 id="7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？"><a href="#7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？" class="headerlink" title="7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？"></a>7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？</h2><p>用的哪种:<br>            IK分词器<br>        为什么要自定义拼音分词器：<br>            要实现根据字母做补全，就必须对文档按照拼音分词。<br>            默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器<br>        为什么搜索时不能用拼音分词器：<br>            为了避免搜索到同音字，搜索时不要使用拼音分词器</p>
<h2 id="8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？"><a href="#8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？" class="headerlink" title="8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？"></a>8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？</h2><p>查询类型：<br>            1、查询所有：<br>                查询出所有数据，一般测试用。例如：match_all<br>            2、全文检索（full text）查询：<br>                利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<br>                match_query<br>                multi_match_query<br>            3、精确查询：<br>                根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：<br>                    ids<br>                    range<br>                    term<br>            4、地理（geo）查询：<br>                根据经纬度查询。例如：<br>                    geo_distance<br>                    eo_bounding_box<br>            5、复合（compound）查询：<br>                复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：<br>                    bool<br>                    function_score<br>        如何实现复合查询：<br>            1、根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score）<br>            2、根据过滤条件，过滤文档<br>            3、符合过滤条件的文档，基于算分函数运算，得到函数算分（function score）<br>            4、将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。<br>        给指定的数据进行加分如何实现：<br>            算分函数：<br>                可以简单粗暴，直接给固定的算分结果，weight</p>
<h2 id="9、给指定的数据进行加分如何实现？如何实现高亮？"><a href="#9、给指定的数据进行加分如何实现？如何实现高亮？" class="headerlink" title="9、给指定的数据进行加分如何实现？如何实现高亮？"></a>9、给指定的数据进行加分如何实现？如何实现高亮？</h2><p>给指定的数据进行加分如何实现：<br>            1、排序<br>            2、分页<br>            3、高亮<br>        如何实现高亮：<br>            1、给文档中的所有关键字都添加一个标签，例如<em>标签<br>            2、页面给<em>标签编写CSS样式</p>
<h2 id="10、ES有哪些聚合查询？"><a href="#10、ES有哪些聚合查询？" class="headerlink" title="10、ES有哪些聚合查询？"></a>10、ES有哪些聚合查询？</h2><p>1、桶（Bucket）聚合：<br>            用来对文档做分组<br>        2、度量（Metric）聚合：<br>            用以计算一些值，比如：最大值、最小值、平均值等<br>        3、管道（pipeline）聚合：<br>            其它聚合的结果为基础做聚合</p>
<h2 id="11、ES如何实现自动补全查询"><a href="#11、ES如何实现自动补全查询" class="headerlink" title="11、ES如何实现自动补全查询"></a>11、ES如何实现自动补全查询</h2><p>1、修改索引库结构，设置自定义拼音分词器<br>        2、修改索引库的需要补全的属性，使用自定义分词器<br>        3、索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器<br>        4、给实体类doc添加suggestion字段<br>        5、重新导入数据到索引库</p>
<h2 id="12、如何自定义分词器？"><a href="#12、如何自定义分词器？" class="headerlink" title="12、如何自定义分词器？"></a>12、如何自定义分词器？</h2><p>1、创建索引库时，在settings中配置，可以包含三部分<br>        2、character filter：<br>            在tokenizer之前对文本进行处理。例如删除字符、替换字符<br>        3、tokenizer：<br>            将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart<br>        4、filter：<br>            将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</p>
<h2 id="13、如何实现es与mysql的数据同步？"><a href="#13、如何实现es与mysql的数据同步？" class="headerlink" title="13、如何实现es与mysql的数据同步？"></a>13、如何实现es与mysql的数据同步？</h2><p>1、同步调用：<br>            1、ES微服务对外提供接口，用来修改elasticsearch中的数据<br>            2、操作数据库微服务在完成数据库操作后，直接调用微服务提供的接口，<br>        2、异步通知：<br>            1、操作数据库微服务对mysql数据库数据完成增、删、改后，发送MQ消息<br>            2、ES微服务监听MQ，接收到消息后完成elasticsearch数据修改<br>        3、监听binlog<br>            1、给mysql开启binlog功能<br>            2、mysql完成增、删、改操作都会记录在binlog中<br>            3、ES微服务基于canal监听binlog变化，实时更新elasticsearch中的内容</p>
<h2 id="14、es集群节点有哪些类型？分别的职责是什么？"><a href="#14、es集群节点有哪些类型？分别的职责是什么？" class="headerlink" title="14、es集群节点有哪些类型？分别的职责是什么？"></a>14、es集群节点有哪些类型？分别的职责是什么？</h2><p>1、备选主节点（master eligible）：<br>            主节点可以管理和记录集群状态、决定分片在哪个节点、处理创建和删除索引库的请求<br>        2、数据节点（data）：<br>            存储数据、搜查、聚合、CRUD<br>        3、ingest：<br>            数据存储之前的预处理<br>        4、coordinating：<br>            路由请求到其他节点，合并其他节点处理的结果，返回给用户</p>
<h2 id="15、什么是es脑裂问题？"><a href="#15、什么是es脑裂问题？" class="headerlink" title="15、什么是es脑裂问题？"></a>15、什么是es脑裂问题？</h2><p>1、一个集群中，主节点与其它节点失联<br>        2、此时，node2和node3认为node1宕机，就会重新选主<br>        3、当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异<br>        4、当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况</p>
<h1 id="十一、压测、高并发性能优化"><a href="#十一、压测、高并发性能优化" class="headerlink" title="十一、压测、高并发性能优化"></a>十一、压测、高并发性能优化</h1><p>1、jemiter压测工具使用<br>    2、多级缓存（nginx共享字典、redis缓存、tomcat进程缓存）<br>    3、数据库主从读写分离（mycat）<br>    4、发布：<br>        开发环境、测试环境用的shell脚本自动发布（包括从git上拉取代码、打包编译、启动）<br>        预上线、线上环境用的jenkins持续集成<br>    5、提交代码之前需要做什么？</p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基础——线性表</title>
    <url>/2022/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<p>前言：<br>数据结构的概念：数据结构是指数据对象机器相互关系的构造方法。</p>
<p>数据结构S可以用一个二元组表示：S&#x3D;（D，R）</p>
<p>D是数据结构中的数据的非空有限集合，R是定义在D上的关系的非空有限集合。</p>
<p>数据的存储结构：在数据结构中，结点及结点间的相互关系称为数据的逻辑结构。</p>
<p>数据结构可以按照逻辑结构的不同分为两大类：线性结构和非线性结构。其中非线性结构又可分为树形结构和图结构，而树形结构又可以分为树结构和二叉树结构。</p>
<p>1、常用数据结构</p>
<p>数组（静态数组、动态数组）、线性表、链表（单向链表、双向链表、循环链表）、队列、栈、树（二叉树、查找树、平衡树、线索树、堆）、图等的定义、存储和操作。Hash（存储地址计算，冲突处理）。</p>
<p>2、常用算法：</p>
<p>排序算法、查找算法、数值计算方法、字符串处理方法、数据压缩算法、递归算法、图的相关算法。算法与数据结构的关系、算法效率、算法设计、算法描述（流程图、伪代码、决策表）、算法的复杂性。</p>
<h2 id="1-线性表的概念"><a href="#1-线性表的概念" class="headerlink" title="1.线性表的概念"></a>1.线性表的概念</h2><p><strong>线性表</strong>是最简单、最常用的一种数据结构，它是<strong>由相同类型的节点组成的有限序列</strong>。</p>
<p>一个由n个结点a0,a1,…，an–1组成的线性表可记为（a0,a1,…，an–1）。</p>
<p>线性表的结点个数为线性表的长度， 长度为0的线性表称为<strong>空表</strong>。</p>
<p>对于非空线性表，a0是线性表的第一个结点，an–1是线性表的最后一个结点。</p>
<p>线性表的结点构成一个序列，对序列中两相邻结点ai和ai+1,称ai是ai+1的前驱结点，ai+1是ai的后继结点。其中a0没有前驱结点，an–1没有后继结点。</p>
<p>线性表中结点之间的关系可由<strong>结点在线性表中的位置</strong>确定，通常用（ai,ai+1）（0≤i≤n–2）表示两个结点之间的先后关系。例如，如果两个线性表有相同的数据结点，但它们的结点在线性表中出现的顺序不同，则它们是两个不同的线性表。</p>
<p>线性表的结点可由若干成分组成，其中能唯一标识该结点的成分称为关键字，或简称键。</p>
<h2 id="2-线性表的基本运算"><a href="#2-线性表的基本运算" class="headerlink" title="2.线性表的基本运算"></a>2.线性表的基本运算</h2><p>线性表包含的结点个数可以动态增加或减少，可以在任何位置插入或删除结点。线性表常用的运算可分成几类，每类有若干种运算。</p>
<h3 id="1-查找运算"><a href="#1-查找运算" class="headerlink" title="1)查找运算"></a>1)查找运算</h3><p>在线性表中查找具有给定键值的结点。</p>
<h3 id="2）插入运算"><a href="#2）插入运算" class="headerlink" title="2）插入运算"></a>2）插入运算</h3><p>在线性表的第i（0≤i≤n–1）个结点的前面或后面插入一个新结点。</p>
<h3 id="3）删除运算"><a href="#3）删除运算" class="headerlink" title="3）删除运算"></a>3）删除运算</h3><p>删除线性表的第i（0≤i≤n–1）个结点。</p>
<h3 id="4）其他运算"><a href="#4）其他运算" class="headerlink" title="4）其他运算"></a>4）其他运算</h3><p>统计线性表中结点的个数；</p>
<p>输出线性表各结点的值；</p>
<p>复制线性表；</p>
<p>线性表分拆；</p>
<p>线性表合并；</p>
<p>线性表排序；</p>
<p>按某种规则整理线性表。</p>
<h2 id="3-线性表的存储"><a href="#3-线性表的存储" class="headerlink" title="3.线性表的存储"></a>3.线性表的存储</h2><p>线性表常用的存储方式有<strong>顺序存储</strong>和<strong>链接存储</strong>。</p>
<h3 id="1）顺序存储"><a href="#1）顺序存储" class="headerlink" title="1）顺序存储"></a>1）顺序存储</h3><p><strong>顺序存储</strong>是最简单的存储方式，通常用一个数组，从数组的第一个元素开始，将线性表的结点依次存储在数组中，即线性表的第i个结点存储在数组的第i（0≤i≤n–1）个元素中，用数组元素的顺序存储来体现线性表中结点的先后次序关系。</p>
<p><strong>优点</strong>：</p>
<p>能随机存储线性表中的任何一个结点。</p>
<p><strong>缺点</strong>：</p>
<p>1.数组的大小通常是固定的，不利于任意增加或减少线性表的结点个数</p>
<p>2.插入和删除线性表的结点时，要移动数组的其他元素，操作复杂。</p>
<h3 id="2）链接存储"><a href="#2）链接存储" class="headerlink" title="2）链接存储"></a>2）链接存储</h3><p><strong>链接存储</strong>是用链表存储线性表（链表），最简单的是用单向链表，即从链表的第一个结点开始，将线性表的结点依次存储在链表的各结点中。链表的每个结点不但要存储线性表结点的信息，还要用一个域存储其后继结点的指针。单向链表通过链接指针来体现线性表中结点的先后次序关系。</p>
<p><strong>优点</strong>：</p>
<p>1.线性表每个结点的实际存储位置是任意的。</p>
<p>2.只要改变链表有关结点的后继指针就能完成插入或删除的操作，不需移动任何表单元。</p>
<p><strong>缺点</strong>：</p>
<p>1.每个结点增加了一个后继指针成分，要花费更多的存储空间。</p>
<p>2.不便随机访问线性表的任一结点。</p>
<h2 id="4-线性表上的查找"><a href="#4-线性表上的查找" class="headerlink" title="4.线性表上的查找"></a>4.线性表上的查找</h2><p>线性表上的查找运算是指在线性表中找某个键值的结点。</p>
<p>根据线性表中的存储形式和线性表本身的性质差异，有多种查找算法，例如顺序查找、二分法查找、分块查找、散列查找等。其中二分法查找要求线性表是一个有序序列。</p>
<h2 id="5-在线性表中插入新结点"><a href="#5-在线性表中插入新结点" class="headerlink" title="5.在线性表中插入新结点"></a>5.在线性表中插入新结点</h2><h3 id="1）顺序存储-1"><a href="#1）顺序存储-1" class="headerlink" title="1）顺序存储"></a>1）顺序存储</h3><p>设线性表结点的类型为整型，插入之前有n个结点，把值为x的新结点插在线性表的第i（0≤i≤n）个位置上。</p>
<p>完成插入主要有以下步骤：</p>
<p>1.检查插入要求的有关参数的合理性；</p>
<p>2.把原来的第n–1个结点至第i个结点依次往后移一个数组元素位置；</p>
<p>3.把新结点放在第i个位置上；</p>
<p>4.修正线性表的结点个数。</p>
<p>5.在具有n个结点的线性表上插入新结点，其时间主要花费在移动结点的循环上。若插入任一位置的概率相等，则在顺序存储线性表中插入一个新结点，平均移动次数为n&#x2F;2</p>
<h3 id="2）链接存储-1"><a href="#2）链接存储-1" class="headerlink" title="2）链接存储"></a>2）链接存储</h3><p>在链接存储线性表中插入一个键值为x的新结点，分为以下4种情况：</p>
<p>1.在某指针p所指结点之后插入；</p>
<p>2.插在首结点之前，使待插入结点成为新的首结点；</p>
<p>3.接在线性表的末尾；</p>
<p>4.在有序链表中插入，使新的线性表仍然有序。</p>
<h2 id="6-删除线性表的结点"><a href="#6-删除线性表的结点" class="headerlink" title="6.删除线性表的结点"></a>6.删除线性表的结点</h2><h3 id="1）顺序存储-2"><a href="#1）顺序存储-2" class="headerlink" title="1）顺序存储"></a>1）顺序存储</h3><p>在有n个结点的线性表中，删除第i（0≤i≤n–1）个结点。删除时应将第i+1个结点至第n–1个结点依次向前移一个数组元素位置，共移动n–i–1个结点。完成删除主要有以下几个步骤：</p>
<p>1.检查删除要求的有关参数的合理性；</p>
<p>2.把原来第i+1个表元至第n–1个结点依次向前移一个数组元素位置；修正线性表表元个数。</p>
<p>3.在具有n个结点的线性表上删除结点，其时间主要花费在移动表元的循环上。若删除任一表元的概率相等，则在顺序存储线性表中删除一个结点，平均移动次数为（n-1）&#x2F;2.</p>
<h3 id="2）链接存储-2"><a href="#2）链接存储-2" class="headerlink" title="2）链接存储"></a>2）链接存储</h3><p>对于链表上删除指定的结点的删除运算，需要考虑几种情况：</p>
<p>1.链表为空链表，不执行删除操作；</p>
<p>2.要删除的结点恰为链表的首结点，应将链表头指针改为指向原首结点的后继指点；</p>
<p>3.其他情况，先要在链表中寻找要删除的结点，从链表首结点开始顺序寻找。若找到，执行删除操作，若直至链表末尾没有指定值的结点，则不执行删除操作。</p>
<p>完成删除由以下几个步骤组成：</p>
<p>如链表为空链表，则不执行删除操作；</p>
<p>若链表的首结点的值为指定值，更改链表的头指针为指向首结点的后继结点；</p>
<p>在链表中寻找指定值的结点；</p>
<p>将找到的结点删除。</p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>用Java解决贪心算法——删数问题</title>
    <url>/2022/09/03/%E7%94%A8Java%E8%A7%A3%E5%86%B3%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%A0%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>贪心算法——删数问题</p>
<p>【问题描述】</p>
<p>假设正整数n、s，s&lt;n。设计算法对任一给定n位数，删除其中的s位后，使得剩下的位新数最小。</p>
<p>【输入形式】</p>
<p>ex：1 2 3 9 5；删掉一个数；</p>
<p>1：1 2 3 5</p>
<p>2：1 2 3</p>
<p>3：1 2</p>
<p>【个人思路】</p>
<p>从第一个数开始遍历，到寻找到单调递减的第一个数（即单调递增的最后一个数），则删除，若无单调递减子序列，则删掉最后一个非递减序列的数；每找到一个就又从头开始。即每做一次删数，就是一次贪心选择，删掉此数剩下的数为组成最小</p>
<p>【代码演示】</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">shanshuwenti2</span> &#123;</span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">Delete</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k)</span></span><br><span class="line">	    &#123;</span><br><span class="line">	        StringBuffer sb=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(a+<span class="string">&quot;&quot;</span>);</span><br><span class="line">	        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">	        &#123;</span><br><span class="line">	            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;sb.length()-<span class="number">1</span>&amp;&amp;sb.charAt(j)&lt;=sb.charAt(j+<span class="number">1</span>);j++)</span><br><span class="line">	            &#123;</span><br><span class="line">	            &#125;</span><br><span class="line">	            sb.delete(j,j+<span class="number">1</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> sb.length()==<span class="number">0</span>?<span class="number">0</span>:Integer.parseInt(sb.toString());</span><br><span class="line">	    &#125;</span><br><span class="line">	 </span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	    &#123;</span><br><span class="line">	            Scanner in=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">	            <span class="type">int</span> a=in.nextInt();</span><br><span class="line">	            <span class="type">int</span> b=in.nextInt();</span><br><span class="line">	            <span class="keyword">if</span>(a&lt;=<span class="number">0</span>||b&lt;=<span class="number">0</span>)</span><br><span class="line">	                System.exit(<span class="number">0</span>);</span><br><span class="line">	            System.out.println(Delete(a,b));</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>百度引擎搜索方法</title>
    <url>/2022/09/02/%E7%99%BE%E5%BA%A6%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>百度上的资源越来越多，你是否很多时候都搜不到自己想要的资源呢？逐渐商业化的网络时代，各种各样的广告也随之而来呢，你是否也经常因为搜索引擎遍布的广告而烦恼呢？在这里小编教大家一些小技巧，希望能够帮助到大家。</p>
<p>1.标题搜索</p>
<p>将搜索范围限定在网页标题中，使用关键词intitle，例如：intitle：java教程。百度搜索引擎是这样理解这句话的： 搜索网页标题含有“java教程”的字样，这样百度就会自动帮你筛选结果啦。</p>
<p>2.链接搜索</p>
<p>将搜索范围限定在url链接中，使用关键词：inurl，例如：inutl: php。百度搜索引擎是这样理解这句话的： 在站点的url中搜索含有“php”的字样</p>
<p>3.不拆分搜索</p>
<p>不拆分搜索，又叫做”精确搜索“，使用双引号或者书名号。例如，在百度搜索框中搜索”java自学视频”，百度搜索引擎视”java自学视频“为不可拆分的关键字。而添加书名号也是一样的效果</p>
<p>4.类型搜索</p>
<p>类型搜索或者成为格式搜索。使用特定的”元词“+关键字，例如，要只是搜索风景图片，可以这样：image:风景图片,  或者只是搜索 备案文件的文本。可以这样搜索：doc:备案文件 等等。</p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：7-1 数表问题</title>
    <url>/2022/10/19/%E7%AE%97%E6%B3%95%EF%BC%9A7-1-%E6%95%B0%E8%A1%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>编个题面先：</p>
<p>小明是个爱学习的好孩子，上课的时候老师布置了这么一个作业题：</p>
<p>根据一张由N个正整数组成的数表，两两相加得到新数（共有<em>N</em>∗(<em>N</em>−1)&#x2F;2个），然后将新数按照非递减排序。</p>
<p>举个例子呢就是：如果数表里包含有4个数1，4，3，9，那么正确答案就是4，5，7，10，12，13。</p>
<p>请你编程帮助小明完成这道题吧！</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>数据有两行，第1行是一个整数N（1&lt;N≤100），表示数表中的整数个数；</p>
<p>第2行是数表中的N个整数（0≤整数≤5000），相邻整数间以一个空格分隔。</p>
<p>输入的N个整数确保不重复。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出一组按照升序排列的整数的和，相邻整数之间以一个空格分隔。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><p>在这里给出一组输入。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 4 3 9</span><br></pre></td></tr></table></figure></div>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><p>在这里给出相应的输出。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 7 10 12 13</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码长度限制									   16 KB</span><br><span class="line">时间限制										400 ms</span><br><span class="line">内存限制										64 MB</span><br></pre></td></tr></table></figure></div>

<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示:"></a>代码演示:</h3><p>刚开始未优化的方法：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">arr</span> <span class="operator">=</span> sc1.nextLine();</span><br><span class="line">        String arr1[] = arr.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> num[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            num[i] = Integer.parseInt(arr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//Set无序集合可以自动去除重复的结果</span></span><br><span class="line">        Set&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; num.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i] != num[j]) &#123;</span><br><span class="line">                    list.add(num[i] + num[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; newList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer arrInt:list) &#123;</span><br><span class="line">            newList.add(arrInt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对newList进行排序</span></span><br><span class="line">        Collections.sort(newList);</span><br><span class="line">        <span class="keyword">for</span> (Integer newArr:newList) &#123;</span><br><span class="line">            System.out.print(newArr + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/7-1-Img/img1.png"
                     
                ></p>
<p>满足条件正确解法：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> num=sc.nextInt();</span><br><span class="line">        sc.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ar</span> <span class="operator">=</span>sc.next();</span><br><span class="line">        String[] arArray = ar.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> a[]=<span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : arArray) &#123;</span><br><span class="line">            <span class="type">int</span> b= Integer.parseInt(s);</span><br><span class="line">            a[i]=b;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.length==i)&#123;</span><br><span class="line">            <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[num*(num-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j+<span class="number">1</span>; k &lt; num; k++) &#123;</span><br><span class="line">                    b[l]=(a[j]+a[k]);</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;b.length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j+<span class="number">1</span>; k &lt; b.length; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (b[j]&gt;b[k])&#123;</span><br><span class="line">                        <span class="type">int</span> e=b[j];</span><br><span class="line">                        b[j]=b[k];</span><br><span class="line">                        b[k]=e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; b.length; j++) &#123;</span><br><span class="line">                System.out.print(b[j]);</span><br><span class="line">                <span class="keyword">if</span> (j&lt;b.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/7-1-Img/img2.jpg"
                     
                ></p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：7-1 循环日程安排问题</title>
    <url>/2022/10/26/%E7%AE%97%E6%B3%95%EF%BC%9A7-1-%E5%BE%AA%E7%8E%AF%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>用分治法求解循环日程安排问题。设有n&#x3D;2<em>k</em>个选手要进行网球循环赛，要求设计一个满足以下要求的比赛日程表：<br>（1）每个选手必须与其他n-1个选手各赛一次。<br>（2）每个选手一天只能赛一次。<br>（3）循环赛在n-1天之内结束。</p>
<img src = "/asset_img/Recurring-Schedule-Img/img.png">

<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><p>输入K值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></div>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><p>输出比赛日程表。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 </span><br><span class="line">2 1 4 3 6 5 8 7 </span><br><span class="line">3 4 1 2 7 8 5 6 </span><br><span class="line">4 3 2 1 8 7 6 5 </span><br><span class="line">5 6 7 8 1 2 3 4 </span><br><span class="line">6 5 8 7 2 1 4 3 </span><br><span class="line">7 8 5 6 3 4 1 2 </span><br><span class="line">8 7 6 5 4 3 2 1 </span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码长度限制									    16 KB</span><br><span class="line"></span><br><span class="line">时间限制										400 ms</span><br><span class="line"></span><br><span class="line">内存限制										 64 MB</span><br></pre></td></tr></table></figure></div>

<h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n,temp,i,j,t;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//选手的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>,k);</span><br><span class="line">        <span class="type">int</span> a[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][sum+<span class="number">1</span>];</span><br><span class="line">        n=<span class="number">2</span>;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (t=<span class="number">1</span>; t&lt;k; t++) &#123;</span><br><span class="line">            temp=n;</span><br><span class="line">            n=n*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (i=temp+<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= temp; j++)&#123;</span><br><span class="line">                    a[i][j] = a[i - temp][j] + temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=temp; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = temp + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    a[i][j] = a[i + temp][(j + temp) % n];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=temp+<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = temp + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    a[i][j] = a[i - temp][j - temp];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; l &lt;= sum; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; m &lt;= sum; m++) &#123;</span><br><span class="line">                System.out.print(a[l][m]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：Java快速排序的实现</title>
    <url>/2022/10/08/%E7%AE%97%E6%B3%95%EF%BC%9AJava%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>快速排序由于排序效率在同为O(n*logn)的几种排序方法中效率较高，快速排序思想——分治法也确实实用。<br>排序思想也有很多种，例如：冒泡排序、选择排序、插入排序，快速排序，那么此篇就来讲讲快速排序的实现吧~</p>
<p><strong>基本思想</strong></p>
<p>1．先从数列中取出一个数作为基准数。<br>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。<br>3．再对左右区间重复第二步，直到各区间只有一个数。</p>
<p><strong>代码实现</strong></p>
<p>这里是C语言的代码（上课记录下来的）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/QuickSort-Img/img.jpg"
                     
                ><br>那么下面我们用Java语言搞定：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> temp=a[l];</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">                <span class="keyword">while</span> (l&lt;r &amp;&amp; a[r]&gt;temp)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    a[l++]=a[r];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (l&lt;r &amp;&amp; a[l]&lt;=temp)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                    a[r--]=a[l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[l]=temp;</span><br><span class="line">            quickSort(a,l,temp-<span class="number">1</span>);</span><br><span class="line">            quickSort(a,temp+<span class="number">1</span>,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>程序常用开发工具</title>
    <url>/2022/11/13/%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>程序开发工具：</p>
<ol>
<li><p>IntelliJ IDEA 2022.2</p>
<p>强大开发工具，开发的时候经常用，首选这个。</p>
</li>
<li><p>Eclipse</p>
<p>比较老的开发工具，功能相对Idea没有那么强大，不过占用较少运行较快。</p>
</li>
<li><p>PyCharm Community Edition 2022.1.4</p>
<p>开发Python的强大工具，研究Python的时候就用这个。</p>
</li>
<li><p>Microsoft VS Code</p>
<p>开发动态网页和静态网页，hexo博客后台，用的最多的工具。</p>
</li>
<li><p>Dev-Cpp</p>
<p>用来运行C语言和C++的开发工具，copy代码用。</p>
</li>
<li><p>Navicat Premium 15</p>
<p>MySQL数据库可视化工具，一般做项目的时候用。</p>
</li>
<li><p>Microsoft Visual Studio</p>
<p>编写C语言和C++的强大工具，挺好用。</p>
</li>
<li><p>微信开发者工具</p>
<p>开发微信小程序用。</p>
</li>
<li><p>FinalShell</p>
<p>一体化的服务器，网络管理软件。</p>
</li>
<li><p>GreenHub</p>
<p>免费VPN，翻墙用。</p>
</li>
<li><p>夜神模拟器</p>
<p>开发安卓app，也可以做些其他的开发操作。</p>
</li>
<li><p>Photoshop 2022</p>
<p>PS专用，P图之类的。</p>
</li>
<li><p>Premiere Pro 2022</p>
<p>专业剪视频工具，简单点的视频用剪映。</p>
</li>
<li><p>Git</p>
<p>代码管理工具，从电脑上传到Gitee或者Github仓库</p>
</li>
</ol>
<p>效率工具：</p>
<ol>
<li><p>utools</p>
<p>新一代效率工具，内置Everything，颜色助手，微信躲开，批量重命名，Markdown等插件</p>
</li>
<li><p>office全家桶</p>
<p>这个就不多说，必备。</p>
</li>
<li><p>Typora</p>
<p>记笔记用，或者写博客。</p>
</li>
<li><p>Watt Toolkit</p>
<p>别名Steam++，还可以加速烂橘子，Github，公告CDN。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：7-2 最大三角形</title>
    <url>/2022/10/19/%E7%AE%97%E6%B3%95%EF%BC%9A7-2-%E6%9C%80%E5%A4%A7%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<p>有一个游戏，玩法是在一堆长度不一的小棍中找出三根棍子，拼出一个周长最大的三角形。有什么策略能快速的找到三根小棍么？<br>请你来试试吧</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>在一行中给出小棍的个数 N，另一行中分别给出 N 个小棍的长度，之间用空格隔开。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果小棍的数量小于 3，则输出<code>小棍的个数不能组成三角形</code>；如果找到最大的三角形，则输出<code>最大三角形的周长是?</code>，并在下一行中输出<code>组成最大三角形的三条边是?,?,?</code>，三条边之间用英文逗号隔开并从小到大输出；如果没有找到，则输出<code>没有找到能组成三角形的小棍</code>。</p>
<h3 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">233 120 747 75 67 336 221 845 780 403</span><br></pre></td></tr></table></figure></div>

<h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">最大三角形的周长是2372</span><br><span class="line">组成最大三角形的三条边是747,780,845</span><br></pre></td></tr></table></figure></div>

<h3 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">15 12</span><br></pre></td></tr></table></figure></div>

<h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">小棍的个数不能组成三角形</span><br></pre></td></tr></table></figure></div>

<h3 id="输入样例3"><a href="#输入样例3" class="headerlink" title="输入样例3:"></a>输入样例3:</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">15 12 3</span><br></pre></td></tr></table></figure></div>

<h3 id="输出样例3"><a href="#输出样例3" class="headerlink" title="输出样例3:"></a>输出样例3:</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有找到能组成三角形的小棍</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码长度限制										16 KB</span><br><span class="line">时间限制										 30 ms</span><br><span class="line">内存限制										 64 MB</span><br></pre></td></tr></table></figure></div>

<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示:"></a>代码演示:</h3><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小棍的个数不能组成三角形&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sr</span> <span class="operator">=</span> sc1.nextLine();</span><br><span class="line">        String arr1[] = sr.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = Integer.parseInt(arr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        getLongestTriangle(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLongestTriangle</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">longEdge</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">midEdge</span> <span class="operator">=</span> arr[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">shortEdge</span> <span class="operator">=</span> arr[i - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (midEdge + shortEdge &gt; longEdge) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;最大三角形的周长是&quot;</span>);</span><br><span class="line">                System.out.println(midEdge+shortEdge+longEdge);</span><br><span class="line">                System.out.println(<span class="string">&quot;组成最大三角形的三条边是&quot;</span>+shortEdge+<span class="string">&quot;,&quot;</span>+midEdge+<span class="string">&quot;,&quot;</span>+longEdge);</span><br><span class="line">                <span class="keyword">return</span> longEdge + midEdge + shortEdge;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((!(midEdge + shortEdge &gt; longEdge)))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有找到能组成三角形的小棍&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;&#125;</span><br><span class="line"> <span class="type">int</span> arr[n];</span><br><span class="line"> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]))&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(n&lt;<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;小棍的个数不能组成三角形\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> j = i<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> t = arr[i];</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; t)&#123;</span><br><span class="line">        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j+<span class="number">1</span>] = t;</span><br><span class="line"> &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;n<span class="number">-3</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;没有找到能组成三角形的小棍&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[i<span class="number">-1</span>]+arr[i<span class="number">-2</span>]&gt;arr[i]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大三角形的周长是%d\n组成最大三角形的三条边是%d,%d,%d&quot;</span>, arr[i] + arr[i<span class="number">-1</span>] + arr[i<span class="number">-2</span>], arr[i<span class="number">-2</span>], arr[i<span class="number">-1</span>], arr[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：墙上的门</title>
    <url>/2022/09/12/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%A2%99%E4%B8%8A%E7%9A%84%E9%97%A8/</url>
    <content><![CDATA[<p>题目：你面前是一堵朝两个方向无限延伸的墙。墙上有一扇门，但你不知道门离你有多远，也不知道门位于哪个方向。你只有走到门面前才能看到它。假设从当前位置到门要走n（事先不知道n的大小）步，请设计一个算法，使你最多走O(n)步就能遇到门。</p>
<h2 id="【初步分析】"><a href="#【初步分析】" class="headerlink" title="【初步分析】"></a>【初步分析】</h2><p>分析题目，已知墙上有两个方向，所以并不能只朝一个方向去找门，我们得先向钟摆一样来回找，先走一边走几步之后在返回起点继续朝另外一边走，我们不需要判断门在哪一边，我们只需要遇到门就可以。</p>
<h2 id="【题目解法】"><a href="#【题目解法】" class="headerlink" title="【题目解法】"></a>【题目解法】</h2><p>尝试以每次乘以2的方式递进。</p>
<p>第一次：往右走2步，回起点，往左走2步，回起点。</p>
<p>第二次：往右走4步，回起点，往左走4步，回起点。</p>
<p>设一个变量i，起步从起点开始，也就是以0开始。</p>
<p>首先往右走2^i步，往左走2^i步；</p>
<p>然后往右走2^(i+1)步，往左走2^(i+1)步</p>
<p>距离为n步，所以可以得出2^(i-1)&lt;n≤2^i</p>
<p>差不多最多要走4×（2^0+2^1+……+2^（i-1）+3×2^i</p>
<p>即4×（2^i-1）+3×2^i&#x3D;14×2^（i-1）&lt;14*n</p>
<p>最多能保证O(n)步就能遇到门</p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：折半查找（二分查找）</title>
    <url>/2022/10/12/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%89/</url>
    <content><![CDATA[<p>折半查找，也称二分查找，在某些情况下相比于顺序查找，使用折半查找算法的效率更高。<br>但是该算法的使用前提是静态查找表中的数据必须是有序的。</p>
<p>下面来看代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">Max</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> data[] = &#123; <span class="number">12</span>, <span class="number">16</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">32</span>, <span class="number">39</span>, <span class="number">39</span>, <span class="number">48</span>, <span class="number">55</span>, <span class="number">57</span>,<span class="number">58</span>,<span class="number">63</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">70</span>, <span class="number">78</span>, <span class="number">84</span>, <span class="number">88</span>, <span class="number">90</span>, <span class="number">97</span> &#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入您要查找的数字：&quot;</span>);</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">KeyValue</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">		<span class="keyword">if</span> (Search(KeyValue)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;共查找了&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;抱歉,数据数组源中找不到您输入的数字&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">Search</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Max - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> middle;</span><br><span class="line">		<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">			middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (k &lt; data[middle]) &#123;</span><br><span class="line">				right = middle - <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; data[middle]) &#123;</span><br><span class="line">				left = middle + <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == data[middle]) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Data[&quot;</span> + middle + <span class="string">&quot;] = &quot;</span> + data[middle]);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上课的C语言代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Half-Search-Img/img.jpg"
                     
                ></p>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：更轻或者更重？</title>
    <url>/2022/09/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9B%B4%E8%BD%BB%E6%88%96%E8%80%85%E6%9B%B4%E9%87%8D%EF%BC%9F/</url>
    <content><![CDATA[<p>题目：你有n (n &gt; 2)个外观相似的硬币和一个没有砝码的天平。其中一枚为假币，但不知道它比真币重还是轻。设计一个O(1)的算法来确定假币比真币重还是轻。</p>
<h2 id="【开始分析】"><a href="#【开始分析】" class="headerlink" title="【开始分析】"></a>【开始分析】</h2><p>这个题目首先我们要明白我们只是需要确定假币是比真币重还是轻，所以说并不需要我们找出这枚硬币，所以按照这个思路继续往下走，那么我们可以确定在大多数的情况下在天平上只需要比较两次我们就可以分析出结果。</p>
<h2 id="【我的初步思路】"><a href="#【我的初步思路】" class="headerlink" title="【我的初步思路】"></a>【我的初步思路】</h2><p>在看到这个题目之后，我的第一反应是这样划分：首先不考虑硬币少的情况下，我们假设有11个硬币，为奇数次，我们划分为两堆，每堆5枚硬币，多出来的一枚先放一遍，那么分情况进行第一次判断：</p>
<p><strong>1.天平两边相等的情况下。</strong></p>
<p>那么这是最好的情况，直接就可以判断出多出来的那一个就是假币，然后随便替换一边就可以得出哪边轻哪边重了，从而得出结论。</p>
<p><strong>2.天平左边重或者轻的情况下。</strong></p>
<p>每边平分之后我们既可以一眼看出哪边轻哪边重，这是第一次称，那么我们带着假设假币是轻的代入第二次称，依旧是平分，多出来一个或者不多出，那么如果两个相等说明剩下的那个是假币，再按照替换的方式就能得出结论。</p>
<p>但是这个方式行的通吗？明显是行不通的，我们不能用假设的思路去判断它，因为有很多不确定性，所以我们得换一种思路。</p>
<h2 id="【正确解法】"><a href="#【正确解法】" class="headerlink" title="【正确解法】"></a>【正确解法】</h2><p>刚才我们想的是分成两堆硬币进行判断，但是这次我们试着分成三堆来判断。</p>
<p>那么由于n&gt;2，我们就可以判断出两种情况：</p>
<p><strong>情况一：当n是3的整数倍。我们可以将这堆硬币按数量等分为三堆，比如有12个硬币，我们等分为4 4 4 三堆。也设为A、B、C三堆，假币一定在其中一堆中。</strong></p>
<p>第一次在天平上比较A堆和B堆的重量。分为三种子情况：</p>
<ol>
<li><p>A&#x3D;B，则A、B堆均为真币，假币一定在C堆中。第二次比较A堆与C堆，若A比C重，则假币比真币轻，否则假币比真币重。</p>
</li>
<li><p>A&gt;B，则C堆一定全为真币，第二次比较A堆与C堆，若A与C等重，则假币在B中且假币比真币轻，若A比C重，则假币比真币重，若A比C轻，则假币比真币轻。</p>
</li>
<li><p>A&lt;B，同子情况b，C堆一定全为真币，第二次比较A堆与C堆，若A与C等重，则假币在B中且假币比真币重，若A比C重，则假币比真币重，若A比C轻，则假币比真币轻。</p>
</li>
</ol>
<p><strong>情况二：当n不是3的整数倍。此时仍然可以将这堆硬币按数量等分为三堆A、B、C，比如13个硬币，我们分成4 4 5。多出来的1~2个硬币先放到一边。</strong></p>
<p>第一次在天平上比较A堆和B堆的重量。也分为三种子情况：</p>
<ol>
<li><p>A&#x3D;B，则A、B堆均为真币。说明假币一定在C堆中，我们可以随意从A、B堆中选择一边，然后第二次称再从另外一堆真币中拿一个真币与C堆称，如果A&gt;C，那么假币就比真币轻，如果A&lt;C，那么假币就比真币重。</p>
</li>
<li><p>A&gt;B，则C堆一定全为真币，假币在A或B中。第二次称随意从A、B堆中选择一边，C堆去除一个与其中一堆称，例如与B堆，如果与B等重，说明B中全是真币，又因为A&gt;B，所以假币是重于真币的，如果C&gt;B，那么假币就是在B中，且假币比真币轻。那么会不会出现C&lt;B&lt;A呢，很明显这个就不成立了，因为假币只有一个，又已知C中全是真币，所以假币必须是在B和A中在其中一堆里。</p>
</li>
<li><p>A&lt;B，同子情况b，C堆一定全为真币，假币在A或B中。第二次比较A堆与C堆，若A与C等重，则假币在B中且假币比真币重，若A比C重，则假币比真币重，若A比C轻，则假币比真币轻。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：递归实现排列型枚举</title>
    <url>/2022/09/30/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
<p>输入格式:<br>输入一个整数 n，1≤n≤9。</p>
<p>输出格式:<br>按照从小到大的顺序输出所有方案，每行 1 个。</p>
<p>首先，同一行相邻两个数用一个空格隔开。</p>
<p>其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。</p>
<p>输入样例:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></div>

<p>输出样例:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">1 3 2 </span><br><span class="line">2 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">3 1 2 </span><br><span class="line">3 2 1 </span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码长度限制</span><br><span class="line">16 KB</span><br><span class="line">时间限制</span><br><span class="line">400 ms</span><br><span class="line">内存限制</span><br><span class="line">64 MB</span><br></pre></td></tr></table></figure></div>

<p>代码详解：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] stu=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] vis=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n=sc.nextInt();</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                out.print(stu[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                stu[ans]=i;</span><br><span class="line">                dfs(i,ans+<span class="number">1</span>);</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：递归求解兔子问题</title>
    <url>/2022/09/30/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>递归求解兔子问题</p>
<p>一般而言，兔子在出生两个月后，就有繁殖能力，一对兔子每个月能生出一对小兔子来。假设开始有一对刚出生的兔子且所有兔子都不死，那么一年以后可以繁殖多少对兔子？</p>
<p>程序分析:利用递归的方法解题。递归分为回推和递推两个阶段。例如，要想知道第12个月兔子的对数，需知道第10，11个月兔子的对数，依次类推，推到第1，2个月兔子的对数，再往回推。<br>要求输入几个月的整数值，输入前有提示。<br>输出相应的兔子对的数量。<br>输入月数小于等于0时输出num&#x3D;0;<br>输入月数为1或者2时输出num&#x3D;1;</p>
<p>输入格式:<br>12</p>
<p>输出格式:<br>请输入几个月整数值:12<br>num&#x3D;144</p>
<p>输入样例:<br>在这里给出一组输入。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure></div>

<p>输出样例:<br>在这里给出相应的输出。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入几个月整数值:</span><br><span class="line">num=144</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码长度限制</span><br><span class="line">16 KB</span><br><span class="line">时间限制</span><br><span class="line">400 ms</span><br><span class="line">内存限制</span><br><span class="line">64 MB</span><br></pre></td></tr></table></figure></div>

<p>代码详解：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入几个月整数值:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + birth(month));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">birth</span><span class="params">(<span class="type">int</span> month)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (month &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (month == <span class="number">1</span> || month == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> birth(month - <span class="number">1</span>) + birth(month - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>算法设计</tag>
      </tags>
  </entry>
  <entry>
    <title>美团一道经典面试算法题解法</title>
    <url>/2022/09/03/%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<p>这是美团一道经典面试算法题，在大三课上老师留给的一道课后练习，那么我们现在用Java来分析它的解法，此问题为斐波拉契数列（跳楼梯问题）</p>
<p>【问题描述】</p>
<p>一个台阶总共有n级，如果一次可以跳1级，也可以跳2级。总共有多少种跳法？</p>
<p>【初步思路】</p>
<p>对于这一道算法题，我们首先可以做一个简单的分析：</p>
<p>当台阶为1级时，可以得知总共跳法为1种；	1</p>
<p>当台阶为2级时，可以得知总共跳法为2种；	1 1、2</p>
<p>当台阶为3级时，可以得知总共跳法为3种；	1 1 1、1 2、2 1</p>
<p>当台阶为4级时，可以得知总共跳法为4种；	1 1 1 1、1 1 2、1 2 1、2 2</p>
<p>但是当台阶来到5级时，它一共可以得到16种</p>
<p>由此可见我们可以使用递归推导出一个公式：f(1)&#x3D;1;f(2)&#x3D;1;f(n)&#x3D;f(n-1)+f(n-2)；</p>
<p>【代码演示】</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">JumpFloor</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>*JumpFloor(target-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个正整数&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的总种数为：&quot;</span>+JumpFloor(target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>创作篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>蛮力法——狱吏问题</title>
    <url>/2022/09/25/%E8%9B%AE%E5%8A%9B%E6%B3%95%E2%80%94%E2%80%94%E7%8B%B1%E5%90%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>这是大学里算法设计与分析基础一节课上的一道经典题，正在思考中，现在还没有解出来就先分享出来吧~<br>这个也是算法中的一道经典题。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/asset_img/Turnkey-Img/img.jpg"
                     
                >

<p>来了来了，下面是正确解法:</p>
<h1 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h1><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		n = sc.nextInt();</span><br><span class="line">		sc.close();</span><br><span class="line">		<span class="type">int</span>[] flag = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j&lt;=n;j = j+i) &#123;</span><br><span class="line">				flag[j] = <span class="number">1</span> - flag[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;= n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(flag[i] == <span class="number">1</span>)</span><br><span class="line">				System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		answer_two(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">answer_two</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i * i &lt;= n)</span><br><span class="line">				System.out.print(i*i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>记录篇</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
