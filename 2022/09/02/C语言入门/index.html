<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="小颜同学">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://yan-tongxue/github.io/2022/09/02/c语言入门/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="此篇为C语言基础入门，适合C语言初学者 目录一、C语言简介 ​	1、程序语言基础 ​		1.1、程序设计语言概述 ​			1.1.1、什么是计算机程序？ ​			1.1.2、什么是计算机语言？ ​			1.1.3、程序设计语言的基本概念 ​		1.2、语言处理程序 ​		1.3、程序设计语言的基本成分 ​			1.3.1、程序设计语言的数据成分 ​			1.3.2、程序设计语言的运算成分 ​">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言入门">
<meta property="og:url" content="https://yan-tongxue/github.io/2022/09/02/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="忘忧Studio">
<meta property="og:description" content="此篇为C语言基础入门，适合C语言初学者 目录一、C语言简介 ​	1、程序语言基础 ​		1.1、程序设计语言概述 ​			1.1.1、什么是计算机程序？ ​			1.1.2、什么是计算机语言？ ​			1.1.3、程序设计语言的基本概念 ​		1.2、语言处理程序 ​		1.3、程序设计语言的基本成分 ​			1.3.1、程序设计语言的数据成分 ​			1.3.2、程序设计语言的运算成分 ​">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yan-tongxue/asset_img/Blog-Img/img8.jpg">
<meta property="article:published_time" content="2022-09-02T04:36:14.000Z">
<meta property="article:modified_time" content="2023-05-28T07:34:33.824Z">
<meta property="article:author" content="小颜同学">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yan-tongxue/asset_img/Blog-Img/img8.jpg">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/logo.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/logo.png">
    <!--- Page Info-->
    
    <title>
        
            C语言入门 -
        
        忘忧Studio
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"yan-tongxue","root":"/","language":"zh-CN","path":"search.xml"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"busuanzi_counter":{"enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"pjax":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/background-light.jpeg","dark":"/images/background-dark.jpeg"},"title":"小颜同学的博客","subtitle":{"text":["欢迎来到我的博客啦！","Welcome to My Blog!","花会沿路盛开，你的未来也是！"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/yan-tongxue","github-alt":"https://gitee.com/Yan-Tongxue","email":"2279656909@QQ.com"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.2.0","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Github":"https://github.com/EvanNotFound/hexo-theme-redefine","Blog":"https://www.wy-studio.cn","作者寄言":"/about"}},"Links":{"icon":"fa-regular fa-link","submenus":{"树洞":"https://www.wy-studio.cn/2023/09/22/%E5%BF%98%E5%BF%A7Studio%E6%A0%91%E6%B4%9E%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E7%A7%AF%E6%9E%81%E5%8F%82%E4%B8%8E%EF%BC%81/"}},"相册":{"icon":"fa-solid fa-image","path":"/masonry/"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":{"文章":{"path":"/archives","icon":"fa-regular fa-archive"},"标签":{"path":"/tags","icon":"fa-regular fa-tags"},"分类":{"path":"/categories","icon":"fa-regular fa-folder"},"相册":{"icon":"fa-solid fa-image","path":"/masonry/"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/5/20 12:00:00"};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    Global.data_config = {"masonry":true};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
h<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.png">
                </a>
            
            <a class="logo-title" href="/">
                
                忘忧Studio
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        归档
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/about">ME
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/EvanNotFound/hexo-theme-redefine">GITHUB
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://www.wy-studio.cn">BLOG
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/about">作者寄言
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://www.wy-studio.cn/2023/09/22/%E5%BF%98%E5%BF%A7Studio%E6%A0%91%E6%B4%9E%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E7%A7%AF%E6%9E%81%E5%8F%82%E4%B8%8E%EF%BC%81/">树洞
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/masonry/"  >
                                    
                                        
                                            <i class="fa-solid fa-image"></i>
                                        
                                        相册
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                归档
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/about">ME</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://github.com/EvanNotFound/hexo-theme-redefine">GITHUB</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://www.wy-studio.cn">BLOG</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/about">作者寄言</a>
                            </li>
                        
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://www.wy-studio.cn/2023/09/22/%E5%BF%98%E5%BF%A7Studio%E6%A0%91%E6%B4%9E%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF%E6%B5%8B%E8%AF%95%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E7%A7%AF%E6%9E%81%E5%8F%82%E4%B8%8E%EF%BC%81/">树洞</a>
                            </li>
                        
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/masonry/"  >
                             
                                
                                    <i class="fa-solid fa-image"></i>
                                
                                相册
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">C语言入门</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">小颜同学</span>
                            
                                <span class="author-label">Lv4</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2022-09-02 12:36:14</span>
        <span class="mobile">2022-09-02 12:36</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-05-28 15:34:33</span>
            <span class="mobile">2023-05-28 15:34</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%88%9B%E4%BD%9C%E7%AF%87/">创作篇</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>39.9k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>153 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <p>此篇为C语言基础入门，适合C语言初学者</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>一、C语言简介</p>
<p>​	1、程序语言基础</p>
<p>​		1.1、程序设计语言概述</p>
<p>​			1.1.1、什么是计算机程序？</p>
<p>​			1.1.2、什么是计算机语言？</p>
<p>​			1.1.3、程序设计语言的基本概念</p>
<p>​		1.2、语言处理程序</p>
<p>​		1.3、程序设计语言的基本成分</p>
<p>​			1.3.1、程序设计语言的数据成分</p>
<p>​			1.3.2、程序设计语言的运算成分</p>
<p>​			1.3.3、程序设计语言的控制成分</p>
<p>​			1.3.4、程序设计语言的传输成分</p>
<p>​	2、什么是C语言</p>
<p>​	3、C语言的发展历程</p>
<p>​	4、C语言的特点</p>
<p>二、基本数据类型</p>
<p>​	1、数据的表现形式</p>
<p>​		1.1、常量</p>
<p>​		1.2、变量</p>
<p>​			1.2.1、变量的基本概念</p>
<p>​			1.2.2、标识符的命名规则</p>
<p>​			1.2.3、变量的定义</p>
<p>​	2、基本数据类型</p>
<p>​		2.1、数据类型的基本概念</p>
<p>​		2.2、基本数据类型简介</p>
<p>​		2.3、确定常量的类型</p>
<p>​	3、格式化输入输出函数</p>
<p>​		3.1、有关数据输入和输出的概念</p>
<p>​		3.2、用printf函数输出数据（格式化输出函数）</p>
<p>​		3.3、用scanf函数输入数据（格式化输入函数）</p>
<p>三、运算符和表达式</p>
<p>​	1、C语言运算符</p>
<p>​		1.1、C运算符的分类</p>
<p>​		1.2、运算符的操作数以及目数</p>
<p>​		1.3、运算符的优先级</p>
<p>​	2、算术运算符</p>
<p>​		2.1、基本的算术运算符</p>
<p>​		2.2、自增、自减运算符</p>
<p>​		2.3、算术表达式与运算符的优先级和结合性</p>
<p>​		2.4、不同类型数据间的混合运算</p>
<p>​	3、强制类型转换运算符</p>
<p>​	4、关系运算符</p>
<p>​	5、逻辑运算符</p>
<p>​	6、条件运算符</p>
<p>​	7、位运算符</p>
<p>​	8、表达式和C语句</p>
<p>​		8.1、表达式和语句的基本概念</p>
<p>​		8.2、逗号表达式</p>
<p>​		8.3、最基本的语句——赋值语句</p>
<p>​		8.4、C语句的分类</p>
<p>四、选择结构和循环结构</p>
<p>​	1、选择结构</p>
<p>​		1.1、if语句</p>
<p>​		1.2、switch语句</p>
<p>​	2、循环结构</p>
<p>​		2.1、for循环</p>
<p>​		2.2、while循环</p>
<p>​		2.3、do while循环</p>
<p>​		2.4、循环结构的分类</p>
<p>​	3、跳转语句</p>
<p>​		3.1、break语句</p>
<p>​		3.2、continue语句</p>
<p>​		3.3、goto跳转语句</p>
<p>五、数组</p>
<p>​	1、什么是数组？</p>
<p>​	2、一维数组的定义和引用</p>
<p>​		2.1、定义一维数组</p>
<p>​		2.2、使用数组及引用数组元素</p>
<p>​		2.3、一维数组的初始化</p>
<p>​		2.4、一维数组的输入输出</p>
<p>​	3、二维数组</p>
<p>​		3.1、二维数组的定义</p>
<p>​		3.2、二维数组的初始化</p>
<p>​		3.3、二维数组元素的访问</p>
<p>​		3.4、二维数组的输入输出</p>
<p>​	4、字符数组</p>
<p>​		4.1、字符数组的定义及初始化</p>
<p>​		4.2、引用字符数组中的元素</p>
<p>​		4.3、字符数组的输入和输出</p>
<p>​		4.4、二维字符数组</p>
<p>​		4.5、字符串处理函数</p>
<p>六、函数</p>
<p>​	1、函数的基本概念</p>
<p>​	2、函数的定义</p>
<p>​		2.1、定义无参无返回值函数</p>
<p>​		2.2、定义有参无返回值函数</p>
<p>​		2.3、定义有参数有返回值函数</p>
<p>​		2.4、定义无参数有返回值函数</p>
<p>​	3、函数的调用</p>
<p>​		3.1、函数调用语句</p>
<p>​		3.2、函数参数</p>
<p>​		3.3、实参和形参之间的数据传递</p>
<p>​		3.4、函数的返回值</p>
<p>​	4、函数的声明</p>
<p>​	5、局部变量和全局变量</p>
<p>​		5.1、局部变量</p>
<p>​		5.2、全局变量</p>
<p>​		5.3、静态变量与动态变量</p>
<p>​	6、函数的嵌套调用</p>
<p>​	7、函数的递归调用</p>
<p>​	8、数组作为函数参数传递</p>
<p>七、预处理</p>
<p>​	1、预定义符号</p>
<p>​	2、宏定义</p>
<p>​		2.1、无参宏定义</p>
<p>​		2.2、带参宏定义</p>
<p>​		2.3、常量的定义</p>
<p>​	3、文件包含</p>
<p>​		3.1、包含头文件</p>
<p>​		3.2、头文件的重复包含</p>
<p>​	4、条件编译</p>
<p>​		4.1、#if……#else的使用</p>
<p>​		4.2、#ifdef……#endif的使用</p>
<p>​		4.3、#ifndef……#endif的使用</p>
<p>八、构造数据类型</p>
<p>​	1、结构体</p>
<p>​		1.1、什么是结构体？</p>
<p>​		1.2、为什么要用结构体？</p>
<p>​		1.3、结构体类型的声明和结构体变量的定义</p>
<p>​		1.4、结构体变量的初始化和引用</p>
<p>​		1.5、使用typedef关键字自定义类型名</p>
<p>​		1.6、结构体的嵌套定义</p>
<p>​		1.7、结构体数组</p>
<p>​	2、共用体</p>
<p>​		2.1、什么是共用体？</p>
<p>​		2.2、共用体类型的声明和共用体变量的定义</p>
<p>​		2.3、共用体类型所占内存</p>
<p>​	3、枚举类型</p>
<p>​		3.1、枚举类型的概念</p>
<p>​		3.2、枚举类型的声明</p>
<p>​		3.3、枚举变量的定义</p>
<p>​		3.4、枚举类型应用举例</p>
<p>九、C语言文件操作</p>
<p>​	1、什么是文件？</p>
<p>​		1.1、文件的概念</p>
<p>​		1.2、文件的分类</p>
<p>​		1.3、文件存储方法的区别</p>
<p>​	2、指向文件的指针</p>
<p>​		2.1、文件指针的定义</p>
<p>​		2.2、打开与关闭文件</p>
<p>​	3、顺序读写文件</p>
<p>​		3.1、字符输入和输出函数</p>
<p>​		3.2、字符串输入和输出函数</p>
<p>​		3.3、文件格式化输入和输出函数</p>
<p>​		3.4、以二进制的形式读写数据</p>
<p>​	4、随机读写文件</p>
<p>​		4.1、强制使文件指针指向文件开头</p>
<p>​		4.2、使文件指针指向文件中的任意位置</p>
<p>​	5、文件的出错检测</p>
<p>​		5.1、文件读写出错检测</p>
<p>​		5.2、文件末尾判断</p>
<p>​		5.3、文件错误标志</p>
<p>十、C语言的灵魂——指针</p>
<p>​	1、什么是指针？</p>
<p>​	2、指针常量与指针变量</p>
<p>​		2.1、指针常量</p>
<p>​		2.2、指针变量</p>
<p>​	3、指针变量作为函数参数</p>
<p>​		3.1、函数参数为指针类型的函数</p>
<p>​		3.2、指针函数</p>
<p>​	4、通过指针引用数组</p>
<p>​		4.1、数组元素的地址</p>
<p>​		4.2、指针指向数组元素</p>
<p>​		4.3、指针指向的移动（指针的偏移）</p>
<p>​		4.4、指针指向字符串</p>
<p>​	5、指向函数的指针（函数指针）</p>
<p>​		5.1、什么是函数指针？</p>
<p>​		5.2、函数指针的定义</p>
<p>​		5.3、函数指针的初始化及使用</p>
<p>​		5.4、使用函数指针作为函数参数（回调函数）</p>
<p>​		5.5、使用typedef给函数指针取别名</p>
<p>​		5.6、指针函数和函数指针的区别</p>
<p>​	6、指针数组和数组指针</p>
<p>​		6.1、指针数组</p>
<p>​		6.2、数组指针</p>
<p>​	7、指针常量和常量指针</p>
<p>​	8、动态内存分配</p>
<p>​		8.1、什么是动态内存分配</p>
<p>​		8.2、怎样建立内存的动态分配</p>
<p>​	9、结构体指针</p>
<p>​		9.1、指向结构体变量的指针</p>
<p>​		9.2、结构体指针的定义</p>
<p>​		9.3、通过结构体指针引用结构体成员</p>
<p>​	10、多重指针（多级指针）</p>
<p>​		10.1、什么是多重指针</p>
<p>​		10.2、多重指针的定义</p>
<p>​		10.3、多重指针的使用</p>
<p>​		10.4、双重指针作为函数形参</p>
<p>​	11、内存四区</p>
<p>十一、排序算法</p>
<p>​	1、排序的基本概念</p>
<p>​		1.1、什么是排序？</p>
<p>​		1.2、排序的稳定性</p>
<p>​		1.3、排序的分类</p>
<p>​		1.4、排序的过程</p>
<p>​		1.5、排序算法</p>
<p>​	2、冒泡排序</p>
<p>​	3、简单选择排序</p>
<p>​	4、直接插入排序</p>
<p>十二、顺序表</p>
<p>​	1、顺序表的基本概念</p>
<p>​	2、顺序表的定义</p>
<p>​	3、顺序表的功能实现</p>
<p>十三、链表</p>
<p>​	1、链表的基本概念</p>
<p>​		1.1、什么是链表</p>
<p>​		1.2、链表的特点</p>
<p>​		1.3、链表和数组的区别</p>
<p>​	2、链表的结构</p>
<p>​		2.1、链表的结构体示意图</p>
<p>​		2.2、单链表节点的插入和删除结构示意图</p>
<p>​	3、单链表</p>
<p>​		3.1、单链表结构的声明</p>
<p>​		3.2、单链表的创建与功能实现</p>
<p>十四、栈和队列</p>
<p>​	1、栈和队列的基本概念</p>
<p>​	2、数据结构中的栈和队列</p>
<p>​		2.1、栈（stack）</p>
<p>​		2.2、队列（queue）</p>
<p>​	3、栈和队列的基本结构</p>
<p>​		3.1、栈和队列的结构示意图</p>
<p>​		3.2、栈和队列中数据的插入和删除</p>
<p>​	4、栈和队列的实现</p>
<p>​		4.1、栈功能的实现</p>
<p>​		4.2、队列功能的实现</p>
<p>附录：C语言常用基础知识</p>
<p>​	1、C语言中的关键字</p>
<p>​	2、ASCII码表</p>
<p>​	3、运算符的优先级</p>
<p>​	4、C语言常用头文件和库函数</p>
<p>​		4.1、数学函数</p>
<p>​		4.2、字符函数</p>
<p>​		4.3、字符串函数</p>
<p>​		4.4、输入输出函数</p>
<p>​		4.5、动态分配函数和随机函数</p>
<h1 id="一、C语言简介"><a href="#一、C语言简介" class="headerlink" title="一、C语言简介"></a>一、C语言简介</h1><h2 id="1、程序语言基础"><a href="#1、程序语言基础" class="headerlink" title="1、程序语言基础"></a>1、程序语言基础</h2><h3 id="1-1、程序设计语言概述"><a href="#1-1、程序设计语言概述" class="headerlink" title="1.1、程序设计语言概述"></a>1.1、程序设计语言概述</h3><h4 id="1-1-1、什么是计算机程序？"><a href="#1-1-1、什么是计算机程序？" class="headerlink" title="1.1.1、什么是计算机程序？"></a>1.1.1、什么是计算机程序？</h4><p>所谓程序，就是一组计算机能识别和执行的指令。每一条指令能使计算机执行特定的操作。</p>
<h4 id="1-1-2、什么是计算机语言？"><a href="#1-1-2、什么是计算机语言？" class="headerlink" title="1.1.2、什么是计算机语言？"></a>1.1.2、什么是计算机语言？</h4><p>人与人之间交流需要通过语言，我们中国人之间交流用普通话，英国人用英语，俄国人用俄语等。</p>
<p>那人和计算机之间交流当然也要使用一种语言了，所以我们创造了一种计算机和人都能识别的语言，这就是计算机语言。</p>
<h4 id="1-1-3、程序设计语言的基本概念"><a href="#1-1-3、程序设计语言的基本概念" class="headerlink" title="1.1.3、程序设计语言的基本概念"></a>1.1.3、程序设计语言的基本概念</h4><p>计算机语言是为了编写计算机程序而设计的符号语言，是用于对计算过程进行描述、组织和推导，方便人机交互的一种语言。我们需要简单了解一下从低级语言到高级语言。</p>
<p>（1）机器语言</p>
<p>由于计算机工作基于二进制，计算机硬件只能识别由0、1字符串组成的机器指令序列，也就是机器指令程序，我们把它称为机器语言，所以机器语言是最基本的计算机语言。用机器语言编制程序，编写的效率低、可读性差，也难以理解、修改和维护。</p>
<p>（2）汇编语言</p>
<p>由于使用机器语言对于人类来说太不友好了，所以人们设计了汇编语言，用一些容易记忆的符号代替0、1序列，来表示机器指令中的操作码和操作数。例如：用ADD表示加法、SUB表示减法等。相对于机器语言，使用汇编语言编写程序的效率和程序可读性有所提高，但汇编语言是面向机器的语言，其书写格式在很大程度上取决于特定计算机指令。<br>由于它比较“贴近”于计算机，或者说“偏向”于计算机，对计算机比较友好，所以机器语言和汇编语言被称为低级语言。</p>
<p>（3）高级语言</p>
<p>随着计算机的发展，人们开发了功能更强、可读性更高、更加“偏向”于人们逻辑思维的语言，为了更好的支持程序设计，因此产生了面向各类应用的程序设计语言，即高级语言。高级语言更接近于人们习惯使用的自然语言和数学语言，程序中用到的语句和指令是用英文单词来表示的，用到的运算符和表达式和我们日常用的数学算式差不多，比较容易理解。</p>
<p>我们常用的高级语言有C、C++、Java、PHP、Python等，这类语言与人们使用的自然语言比较接近，能够大大的提高程序设计的效率。</p>
<h3 id="1-2、语言处理程序"><a href="#1-2、语言处理程序" class="headerlink" title="1.2、语言处理程序"></a>1.2、语言处理程序</h3><p>编译程序和解释程序</p>
<p>尽管人们可以借助高级语言与计算机进行交互，但是计算机仍然只能理解和执行由0、1序列构成的机器语言，所以高级程序设计语言需要翻译成计算机能够识别的机器语言，担负这一任务的程序称为“语言处理程序”。由于应用程序设计语言不同，语言之间的翻译也是多种多样的，它们大致可以分为汇编程序、解释程序和编译程序。</p>
<p>用某种高级语言或汇编语言编写的程序称为源程序，源程序不能直接在计算机上执行。如果源程序是用汇编语言编写的，就需要汇编程序来把它翻译成目标程序才能执行；如果源程序是用某种高级语言编写的，就需要对应的解释程序或者编译程序进行翻译才能执行。</p>
<p>（1）编译程序：计算机是不能直接识别高级语言程序的，需要用一种称为编译程序的软件把用高级语言写的程序（源程序）转换成为机器指令的程序（目标程序），计算机才能够执行，最后才能得到结果。高级语言的一个语句往往对应多条机器指令。</p>
<p>C语言是编译型语言，从C语言源程序到可执行的目标程序需要经过预处理、编译和连接三个步骤。</p>
<p>（2）解释程序：也称为解释器，它可以直接解释执行源程序，或者将源程序翻译某种中间表示形式后再加以执行，不生成独立的目标程序。</p>
<h3 id="1-3、程序设计语言的基本成分"><a href="#1-3、程序设计语言的基本成分" class="headerlink" title="1.3、程序设计语言的基本成分"></a>1.3、程序设计语言的基本成分</h3><p>程序设计语言的基本成分包括数据、运算、控制和传输等。</p>
<h4 id="1-3-1、程序设计语言的数据成分"><a href="#1-3-1、程序设计语言的数据成分" class="headerlink" title="1.3.1、程序设计语言的数据成分"></a>1.3.1、程序设计语言的数据成分</h4><p>程序设计语言的数据成分是指程序设计语言所支持的数据类型。数据是程序操作的对象，具有类型、名称、作用域、存储类别和生存期等属性，在程序运行过程中要为他分配内存空间。</p>
<p>数据名称可以由用户通过标识符命名；数据类型说明数据占用内存的大小和存放形式；作用域则说明这个数据的使用范围；存储类别说明数据在内存中的位置；生存期说明数据占用内存的时间范围。</p>
<p>从不同的角度来看，可以将数据进行分类。</p>
<p>（1）根据程序运行时数据的值能否被改变可分为常量和变量。在程序中数据可以具有左值和右值，左值是指数据的存储空间（内存地址），右值是指数据的内容（值）。在程序运行中，数据的左值是不可被改变的，也就是常量，右值是可以被改变的，也就是变量。也有一些符号和数值类型等，只有右值，在程序运行过程中其右值不可被改变，所以也将他们称为字符常量和数值常量。</p>
<p>（2）按照数据类型不同可分为基本类型、特殊类型、用户自定义类型、构造类型及其它类型等。</p>
<p>（3）按照作用域的不同可分为全局量和局部量。全局量的作用域为整个程序，所以它在整个程序中都是可用的，在程序运行中其存储空间一般不可改变；而局部量的作用域为一条语句或者一个函数中，它在其他语句或者函数中是不可用的。</p>
<h4 id="1-3-2、程序设计语言的运算成分"><a href="#1-3-2、程序设计语言的运算成分" class="headerlink" title="1.3.2、程序设计语言的运算成分"></a>1.3.2、程序设计语言的运算成分</h4><p>运算成分指明允许使用的运算符号及运算规则。大多数高级程序设计语言的基本运算可分为算术运算、关系运算和逻辑运算等类型，有些语言还提供了位运算（如C、C++），运算符和数据类型密切相关，为了得到明确的运算结果，运算符号要规定优先级和结合性，必要时需要使用圆括号来改变其运算顺序。</p>
<h4 id="1-3-3、程序设计语言的控制成分"><a href="#1-3-3、程序设计语言的控制成分" class="headerlink" title="1.3.3、程序设计语言的控制成分"></a>1.3.3、程序设计语言的控制成分</h4><p>控制成分是指程序设计语言允许使用的控制结构，程序员可以使用控制成分来构造程序中的控制逻辑。控制结构可分为顺序、选择和循环这三种。</p>
<p>（1）顺序结构：用来表示一个计算操作序列的计算过程是按照所描述的第一个操作开始执行，按顺序依次执行后续操作，直到执行完最后一个操作。</p>
<p>（2）选择结构：也称为分支结构，它提供了在两个或多个分支中选择其中一个的逻辑。首先选择结构指定一个条件，然后根据条件是否成立来决定程序的走向，能从两个或多个分支中选择一个满足条件的来执行。</p>
<p>（3）循环结构：描述了重复计算的过程。通常由初始化、需要重复计算的部分和重复计算的条件组成。</p>
<h4 id="1-3-4、程序设计语言的传输成分"><a href="#1-3-4、程序设计语言的传输成分" class="headerlink" title="1.3.4、程序设计语言的传输成分"></a>1.3.4、程序设计语言的传输成分</h4><p>传输成分是指程序设计语言的输入和输出等数据传输。</p>
<p>比如：格式化输出函数、格式化输入函数</p>
<h2 id="2、什么是C语言"><a href="#2、什么是C语言" class="headerlink" title="2、什么是C语言"></a>2、什么是C语言</h2><p>C语言是一门面向过程的计算机编程语言，与C++、Java等面向对象编程语言有所不同。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、仅产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C语言描述问题比汇编语言迅速、工作量小、可读性好、易于调试、修改和移植，而代码质量与汇编语言相当。C语言一般只比汇编语言代码生成目标程序的效率低个10%～20%左右。所以，C语言可以编写系统软件。 </p>
<p>在编程领域中，C语言的运用非常之多，它兼顾了汇编语言和高级语言的优点，相对于其它编程语言而言，其具有较大的优势。C语言的普遍性较强，能够适用于许多计算机操作系统中，并且执行效率高。计算机系统的设计以及应用程序的编写是C语言应用的两大领域。 </p>
<p>C语言经过了漫长的发展历史，其拥有一套完整的理论体系，在编程语言中具有举足轻重的地位。</p>
<h2 id="3、C语言发展历程"><a href="#3、C语言发展历程" class="headerlink" title="3、C语言发展历程"></a>3、C语言发展历程</h2><p>怎样利用C语言作为工具进行程序设计？为什么要选择C语言呢?</p>
<p>首先有必要对C语言的发展和特点有一定的了解。<br>C语言是在国际上广泛流行的高级计算机语言，其是BCPL语言发展而来的。</p>
<p>1967年英国剑桥大学的Martin Richards推出了没有类型的BCPL( Basic Combined Programming Language)语言。</p>
<p>1970 年美国AT&amp;.T贝尔实验室的Ken Thompson以BCPL语言为基础，设计出了很简单且很接近硬件的B语言(取BCPL的第一个字母)。但B语言过于简单，功能有限。</p>
<p>1972- 1973年间,美国贝尔实验室的D.M.Ritchie在B语言的基础上设计出了C语言。C语言既保持了BCPL和B语言的优点(精练,接近硬件),又克服了它们的缺点(过于简单、无数据类型等),C语言的新特点主要表现在具有多种数据类型(如字符、数值、数组、结构体和指针等)。开发C语言的目的在于尽可能降低用它所写的软件对硬件平台的依赖程度,使之具有可移植性。<br>最初的C语言只是为描述和实现UNIX操作系统提供一种工作语言 而设计的。</p>
<p>1973年，Ken Thompson和D. M. Ritchie合作把UNIX的90%以上用C语言改写,即UNIX第5版。随着UNIX的广泛使用，C语言也迅速得到推广。</p>
<p>1978年，在Brian W.Kernighan和D. M. Ritchie合著的《The C programming Language》一书中介绍了C语言，这可以说是C语言的第一个标准，其后来成为了广泛使用的C语言基础版本。</p>
<p>1983年，美国国家标准协会（ANSI）成立了一个委员会，根据C语言之前的各个版本对C语言的发展和扩充制定了第一个C语言标准草案，在之前C语言的版本之上有了很大的发展。</p>
<p>在之后的十几年间，国际标准化组织ISO对C语言做了一些修订，直到1999年，ISO又对C语言标准进行修订，针对于应用的需要，在保留以前版本的C语言特征的基础上，新增了一些功能，此次修正被称为C语言的C99版本。之后的几年又先后进行了两次技术的修正。</p>
<h2 id="4、C语言的特点"><a href="#4、C语言的特点" class="headerlink" title="4、C语言的特点"></a>4、C语言的特点</h2><p>C语言原本是专用于编写系统软件而设计的，许多大型软件基本都是用的C语言进行编写，其具有以下特点：</p>
<p>①C语言语法简洁、结构紧凑，使用较为灵活、方便，程序编写格式较为自由。<br>②数据类型丰富，包括整型、浮点型、字符型、数组类型指针类型和共用体类型等，C99又扩充了复数浮点型、超长整型和布尔类型等。特别是指针类型，丰富多样，使用非常灵活，可以用来实现多种复杂的数据结构。<br>③运算符类型极其丰富，包含的范围很广泛，表达式类型多样化，灵活使用运算符能够实现许多复杂的运算。<br>④C语言是结构化和模块化的编程语言。具有结构化控制语句，以函数为基本单位，易于实现模块化编程。<br>⑤语法限制不太严格，程序设计自由度大。如：对数组的下标越界不会进行检查，由程序员自己保证程序的正确。<br>⑥C语言能允许直接访问物理地址，能进行位(bit)操作，能实现汇编语言的大部分功能，可以直接对硬件进行操作。<br>⑦用C语言编写的程序可移植性好，C编译系统比较简洁，几乎在所有计算机系统中都可以使用C语言。<br>⑧生成目标代码质量高，程序执行效率高，是最接近于汇编语言执行效率的高级语言。</p>
<p>由于C语言具备以上特点，使得C语言得到了广泛的应用，除了编写系统软件以外，许多应用软件也是用的C语言进行编写。</p>
<h1 id="二、基本数据类型"><a href="#二、基本数据类型" class="headerlink" title="二、基本数据类型"></a>二、基本数据类型</h1><h2 id="1、数据的表现形式"><a href="#1、数据的表现形式" class="headerlink" title="1、数据的表现形式"></a>1、数据的表现形式</h2><p> 在计算机高级语言中，数据有两种表现形式：常量和变量。</p>
<h3 id="1-1、常量"><a href="#1-1、常量" class="headerlink" title="1.1、常量"></a>1.1、常量</h3><p>在程序运行过程中，其值不能被改变的量称为常量。例如：数字1、2、3、0.1、3.14和字母’a’、’b’等。数值常量就是数学中的常数。</p>
<p>常用的常量有以下几类：</p>
<p>（1）整型常量</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">10000</span> , <span class="number">0</span> , <span class="number">-100</span> , <span class="number">056</span> , <span class="number">0xAB</span>;	<span class="comment">//整型常量</span></span><br></pre></td></tr></table></figure></div>

<p>（2）实型常量</p>
<p>有两种表示形式：</p>
<p>①十进制小数形式</p>
<p>由数字和小数点组成。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123.456</span> , <span class="number">0.789</span> , <span class="number">-12.34</span> , <span class="number">0.0</span> , <span class="number">10.0</span></span><br></pre></td></tr></table></figure></div>

<p>②指数形式</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12.34e3</span>;	<span class="comment">//表示12.34*10^3，也就是12.34乘以10的3次方</span></span><br><span class="line"><span class="number">-67.89e-6</span>;	<span class="comment">//表示-67.89*10^-6，也就是-67.89乘以10的-6次方</span></span><br></pre></td></tr></table></figure></div>

<p>由于计算机输入或输出时无法表示上标和下标，所以规定以字母e或E代表以10为底的指数，需要注意的是e和E之前必须要有数字，且e和E后面必须为整数，不能写成e4、12e2.5等这种形式。</p>
<p>（3）字符常量：有两种形式的字符常量</p>
<p>①普通字符常量：用单引号括起来的一个字符。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">’a’ , ’B’ , ’<span class="number">3</span>’ , ’@’ , ’#’;</span><br></pre></td></tr></table></figure></div>

<p>不能写成’ab’或’12’，一个单引号内只会包含一个有效字符。注意单引号只是个界限符，字符是指用单引号括起来的符号，不包括单引号。字符型在内存中是以ASCII码形式存储的，例如字符’a’的ASCII码的十进制为97，在存储单元中存放的是97的二进制补码形式。</p>
<p>②转义字符：C语言中还有一种特殊形式的字符常量，是以字符\开头的字符序列。例如：’\n’换行、’\t’水平制表符（tab）、’\’’单引号、’\”’双引号、’?’问号、’\’斜杠、’\a’警告声音提示、’\b’退格删除符、’\f’换页符、’\r’回车、’\v’垂直制表符、’\o’八进制形式、’\x’十六进制形式等。转义字符的意思是将’\’后面的字符转换成另外的意义。如’\n’中的n不代表字母n，而是作为换行符。</p>
<p>（4）字符串常量：如”ABC”、”123”等，用双引号把若干个字符括起来，字符串不包括双引号。注意不能写成’abc’、’123’，单引号内只能包含一个字符，表示字符常量；双引号内可以包含一串字符，表示字符串常量。</p>
<p>（5）符号常量：用#define指令指定用一个符号代表一个常量。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926	<span class="comment">//注意末尾不需要分号</span></span></span><br></pre></td></tr></table></figure></div>

<p>也就是用PI代替3.1415926，意思很简单，代表圆周率。</p>
<p>使用符号常量可以让常量在使用时含义更清楚，并且在需要改变程序中多处用到了同一个常量的时候，能够做到“一改全改”。</p>
<p>注意不要把符号常量误认为变量。</p>
<p>（6）地址常量：每一个常量、变量、数组和函数的地址在程序运行期间是不能够改变的，称为地址常量。</p>
<h3 id="1-2、变量"><a href="#1-2、变量" class="headerlink" title="1.2、变量"></a>1.2、变量</h3><h4 id="1-2-1、变量的基本概念"><a href="#1-2-1、变量的基本概念" class="headerlink" title="1.2.1、变量的基本概念"></a>1.2.1、变量的基本概念</h4><p>变量就是在程序运行中，值可以改变的量。</p>
<p>变量代表一个有名字的、具有特定属性的一个存储单元，可以用来存储数据，也就是变量的值。</p>
<p>变量必须先定义后使用。变量名的命名规则应符合标识符命名规则。</p>
<h4 id="1-2-2、标识符的命名规则"><a href="#1-2-2、标识符的命名规则" class="headerlink" title="1.2.2、标识符的命名规则"></a>1.2.2、标识符的命名规则</h4><p>什么是标识符？</p>
<p>标识符用来给我们所定义的变量、符号常量、函数、数组和类型名等命名，或者说标识和区分它们，标识符命名规则：只能由字母、数字、下划线’_’组成，并且只能由字母和下划线开头。同一个作用域范围内定义的标识符不允许重名，不允许是关键字。</p>
<p>如下列的合法标识符可以作为变量名：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type,CLass,sum,student_name,day,point1_2_3,_10,n1,temp</span><br></pre></td></tr></table></figure></div>

<h4 id="1-2-3、变量的定义"><a href="#1-2-3、变量的定义" class="headerlink" title="1.2.3、变量的定义"></a>1.2.3、变量的定义</h4><p>定义变量的基本格式：数据类型名  变量名;<br>如：定义一个整型变量a</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;	<span class="comment">//int为数据类型名，a为变量名</span></span><br></pre></td></tr></table></figure></div>

<h2 id="2、基本数据类型"><a href="#2、基本数据类型" class="headerlink" title="2、基本数据类型"></a>2、基本数据类型</h2><h3 id="2-1、数据类型的基本概念"><a href="#2-1、数据类型的基本概念" class="headerlink" title="2.1、数据类型的基本概念"></a>2.1、数据类型的基本概念</h3><p> 所谓的类型，就是对数据分配存储单元的安排，包括存储单元的长度（占多少个字节）以及数据的存储形式。不同类型分配不同的长度和存储形式，我们将int、float、char等称为类型名称，或者数据类型关键字。</p>
<p>为什么在用计算机运算时，要指定数据类型呢？</p>
<p>数学运算与计算机运算的区别。</p>
<p>在数学中，数值是不分类型的，数值的运算是绝对精准的，例如1&#x2F;3的值是0.333333333……（循环小数）。数学是一门研究抽象的学科，数和数的运算都是抽象的。而在计算机中，数据是存放在存储单元中的，它是具体存在的。并且存储单元是由有限的字节构成的，每一个存储单元中存放数据的范围是有限的，不可能存放“无穷大”或者“无限”的数，也不能存放循环小数了。例如计算和输出1&#x2F;3，以%f格式输出得到的结果是0.333333，只有6位小数，而不是无限循环小数。</p>
<p>1字节&#x3D;8位（【0000 0000】）</p>
<p>C99还新增了布尔型（bool，0&#x2F;1）和双长整型（long long int）两种基本整型数据类型。</p>
<h3 id="2-2、基本数据类型简介"><a href="#2-2、基本数据类型简介" class="headerlink" title="2.2、基本数据类型简介"></a>2.2、基本数据类型简介</h3><p>各种基本数据类型所占用的存储空间和取值范围如下所示：</p>
<p>（1）整型</p>
<p>整型用于存储整数。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">大小（字节）</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td align="center">无符号整型</td>
<td align="center">unsigned int</td>
<td align="center">4</td>
<td align="center">0 ~ 2^32-1</td>
</tr>
<tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">-2^15 ~ 2^15-1</td>
</tr>
<tr>
<td align="center">无符号短整型</td>
<td align="center">unsigned short</td>
<td align="center">2</td>
<td align="center">0 ~ 2^16-1</td>
</tr>
<tr>
<td align="center">长整型</td>
<td align="center">long</td>
<td align="center">4</td>
<td align="center">-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td align="center">无符号长整型</td>
<td align="center">unsigned long</td>
<td align="center">4</td>
<td align="center">0 ~ 2^32-1</td>
</tr>
<tr>
<td align="center">双长整型</td>
<td align="center">long long</td>
<td align="center">8</td>
<td align="center">-2^63 ~ 2^63-1</td>
</tr>
<tr>
<td align="center">无符号双长整型</td>
<td align="center">unsigned long long</td>
<td align="center">8</td>
<td align="center">0 ~ 2^64-1</td>
</tr>
</tbody></table>
<p>可以用求字节运算符sizeof求出数据类型所占字节数：sizeof(数据类型);</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>);	<span class="comment">//求int类型所占字节数</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);	<span class="comment">//求unsigned long类型所占字节数</span></span><br></pre></td></tr></table></figure></div>

<p>（2）字符型</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">大小（字节）</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">1</td>
<td align="center">ASCII码表</td>
</tr>
</tbody></table>
<p>ASCII码表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/C%E8%AF%AD%E8%A8%80%E4%B9%A6%E7%B1%8D%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90%5CASCII%E7%A0%81%E8%A1%A8.jpg"
                     
                ></p>
<p>字母：大写字母A<del>Z和小写字母a</del>z；</p>
<p>数字：0~9；</p>
<p>专用字符：！	”	#	’	&amp;	%	*	(	)	+	-	&#x2F;	_	^	{	}	[	]	**	~	&lt;	&gt;	&#x3D;	,	.	?	;	:	|	~	&#96;	等；</p>
<p>空格符：空格’ ’、水平垂直制表符’\t’、换行符、换页符等。</p>
<p>不能显示的字符：空（NULL）字符’\0’、警告字符’\a’、退格符’\b’、回车符’\r’等。</p>
<p>特殊情况：当字符存储其他文字字符时，其占两个或多个字节，如：char ch&#x3D;’中’；</p>
<p>中文字符实际上占2个字节，内存的补正（补齐）会把超过一个字节但不超过四个字节的，统一按照4个字节处理。</p>
<p>（3）浮点型</p>
<p>浮点型数据是用来表示具有小数点的实数。</p>
<p>为什么在C语言中把实数称为浮点数呢？</p>
<p>在C语言中，实数是以指数的形式存放在存储单元里的。一个实数表示为指数可以有不止一种形式，但它们表示同一个数值。<br>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span>可以表示为<span class="number">3.14159</span>*<span class="number">10</span>^<span class="number">0</span>，<span class="number">0.314159</span>*<span class="number">10</span>^<span class="number">1</span>，<span class="number">0.0314159</span>*<span class="number">10</span>^<span class="number">2</span>，<span class="number">31.4159</span>*<span class="number">10</span>^<span class="number">-1</span>，<span class="number">314.159</span>*<span class="number">10</span>^<span class="number">-2</span>，<span class="number">3141.59</span>*<span class="number">10</span>^<span class="number">-3</span>等</span><br></pre></td></tr></table></figure></div>

<p>以此看来，小数点的位置是可以在314159几个数字之间和之前或之后加0浮动的，只要在小数点浮动的同时改变指数的值，就可以保证它的大小不会被改变。由于小数点的位置可以浮动，所以实数又称为浮点数。</p>
<p>在指数形式的多种表示方式中，把小数点前的数字为0和小数点后的数字不为0的表示形式称为规范的指数形式，在程序以指数形式输出一个实数时，必然以规范化的指数形式输出，如123.456的规范形式为1.23456e+2。</p>
<p>C语言中的浮点型</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">大小（字节）</th>
<th align="center">取值范围（绝对值）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单精度浮点型</td>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">0以及1.2*10^-38 ~ 3.4 *10^38</td>
</tr>
<tr>
<td align="center">双精度浮点型</td>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">0以及1.2*10^-308 ~ 3.4 *10^308</td>
</tr>
<tr>
<td align="center">长双精度浮点型</td>
<td align="center">long double</td>
<td align="center">8</td>
<td align="center">0以及1.2*10^-308 ~ 3.4 *10^308</td>
</tr>
</tbody></table>
<h3 id="2-3、确定常量的类型"><a href="#2-3、确定常量的类型" class="headerlink" title="2.3、确定常量的类型"></a>2.3、确定常量的类型</h3><p>在C语言中，不仅变量有类型，常量也是有类型的。为什么要把常量分为不同的类型呢？在程序中出现的常量是要存放在计算机中的存储单元中的，这就必须确定分配给它多少字节，按什么方式存储。例如，程序中有整数16，在编译器中会分配给它4个字节，按补码形式存储。</p>
<p>怎样确定常量的类型呢？从常量的表示形式即可判定其类型。</p>
<p>（1）符号常量：对于符号常量来说很简单，只要看到由单引号括起来的单个字符或转义字符就是字符常量,以ACSII码值进行存储，占1个字节。</p>
<p>（2）整型常量：不带小数点的数值是整型常量，但要注意其有效范围。如果某系统中为整型数据分配2个字节，其表示范围为-32768<del>32767（-2^16</del>2^16-1），如果在程序中出现数值常量12345，则系统把它作为int型处理，用4个字节存放。如果出现数值常量45678，由于其大于32767，2个字节放不下，所以系统就会把它作为长整型（long int）进行处理，分配4个字节。以此类推，如果出现的数值常量超过4个字节的表示范围的话，系统就会把它当作双长整型（long long int）。<br>在整数的末尾加上大写字母L或小写字母l，则表示它是长整型（long int）。例如666l、123L等。在VS编译环境中int和long int数据都分配4个字节，因此没有必要用long int。如果在整数的末尾加上大写字母LL或小写字母ll，则表示它是长长整型（long long int），其在内存中占8个字节。</p>
<p>（1）浮点型常量：凡是以小数形式或指数形式出现的实数，都是浮点型常量，在内存中以指数形式存储。如：0、10为整型常量，0.0、10.0是浮点型常量。注意：对于浮点型常量，编译器默认是按双精度进行处理的。例如：float a&#x3D;3.14159；在编译时，给float变量分配4个字节，而对于浮点型常量3.14159来说，则是按double型处理，分配8个字节，编译器有时会发出“警告”。这种警告一般不会影响程序运行结果，但是会影响程序运行结果的精确度。<br>可以在常量的末尾加一个F或f，强制指定常量的类型为单精度。如果在实型常量的末尾加一个L或l，就是指定此常量为long double类型。</p>
<p>注意：区分类型与变量、变量与常量的概念</p>
<h2 id="3、格式化输入输出函数"><a href="#3、格式化输入输出函数" class="headerlink" title="3、格式化输入输出函数"></a>3、格式化输入输出函数</h2><h3 id="3-1、有关数据输入和输出的概念"><a href="#3-1、有关数据输入和输出的概念" class="headerlink" title="3.1、有关数据输入和输出的概念"></a>3.1、有关数据输入和输出的概念</h3><p>从之前的每个程序看来，几乎每一个C程序都包含输入和输出。因为程序要进行运算，就必须给出数据，而运算的结果当然也需要输出了，便于人们应用。没有输出的程序是没有意义的，输入输出是程序中最基本的操作之一。<br>讨论程序的输入和输出时首先要注意：所谓的输入输出是以计算机主机为主而言的。<br>计算机向输出设备（如显示器、打印机等）输出数据称为输出，从输入设备（如键盘、磁盘、光盘、扫描仪等）向计算机输入数据称为输入。<br>C语言函数库中提供了一批“标准输入输出函数”，它是以标准的输入输出设备（一般为终端设备）为输入输出对象的。其中有：printf,scanf,putchar,getchar,puts,gets等函数。在使用这些库函数时，要在程序文件的开头用预处理指令#include把相关头文件加载进本程序中，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、用printf函数输出数据（格式化输出函数）"><a href="#3-2、用printf函数输出数据（格式化输出函数）" class="headerlink" title="3.2、用printf函数输出数据（格式化输出函数）"></a>3.2、用printf函数输出数据（格式化输出函数）</h3><p>printf函数的一般格式为：</p>
<p>printf(格式控制,输出列表);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(“%d,%c\n”,n,c);</span><br></pre></td></tr></table></figure></div>

<p>括号内包括两个部分：</p>
<p>①格式控制</p>
<p>格式控制是用双引号括起来的一个字符串，称为“转换控制字符串”，简称“格式字符串”。</p>
<p>它包括两个信息：</p>
<p>●格式声明：由%和格式字符组成，用作将输出的数据转换为指定的格式然后输出。格式声明符总是由‘%’字符开始的。</p>
<p>常用的格式声明符有：</p>
<p>%d（十进制），%o（八进制），%x（十六进制），%u（无符号十进制），%c（单个字符），</p>
<p>%s（字符串），%f（单精度），%lf（双精度），%e（科学计数法），%i（自适应整数类型），%g（自适应浮点类型）。</p>
<p>●普通字符：即需要在输出时原样输出的字符。</p>
<p>如：\n、\t、空格、逗号等。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“a=%d\n”,a);		<span class="comment">//这里的a=和\n是原样输出的：a=1’\n’</span></span><br></pre></td></tr></table></figure></div>

<p>②输出列表</p>
<p>输出列表就是程序需要输出的一些数据，可以是常量、变量或表达式。</p>
<p>格式化输出函数printf是个函数，所以“格式控制字符串”和“输出列表”实际上都是函数的参数。</p>
<p>printf函数的一般形式可以表示为：printf(“参数1”,参数2,参数3,…,参数n);</p>
<p>参数1是格式控制字符串，参数2~参数n是所需要输出的数据。</p>
<p>我们还可以自定义输出的分隔符和输出的格式。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“%d %c %f\n”,a,b,c);</span><br><span class="line"><span class="built_in">printf</span>(“%d,%c,%f\n”,a,b,c);</span><br><span class="line"><span class="built_in">printf</span>(“%d\t%c\t%f\n”,a,b,c);</span><br></pre></td></tr></table></figure></div>

<p>%4d和%5.2f中的4和5.2是在格式声明中用来指定输出数据的域宽（所占列数）的，如%6d，是指定输出的整型数据占6列，%8.3f，是指输出的浮点型数据总共占8列，其中小数占3列，小数点占1列。还可以在域宽数字前加一个’-’号，用于使输出左对齐。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“%<span class="number">-4</span>d\t%<span class="number">5.2f</span>\n”,a,b);</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3、用scanf函数输入数据（格式化输入函数）"><a href="#3-3、用scanf函数输入数据（格式化输入函数）" class="headerlink" title="3.3、用scanf函数输入数据（格式化输入函数）"></a>3.3、用scanf函数输入数据（格式化输入函数）</h3><p>scanf函数的一般格式为：</p>
<p>scanf(格式控制,地址列表);</p>
<p>其中“格式控制”的含义与printf函数相同。“地址列表”是由若干个地址组成的列表，可以是变量的地址，或者是字符串的首地址。</p>
<p>使用格式化输入函数scanf时，需要注意以下几点：</p>
<p>①函数的地址列表是以变量的地址作为参数的时候，变量名前面必须加一个取地址符号’&amp;’，用于取此变量的地址，否则会出错。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%d %f %c”,a,b,c);<span class="comment">//错误</span></span><br></pre></td></tr></table></figure></div>

<p>②如果在“格式化控制字符串”中除了格式声明符以外还有其他字符，则应在输入数时在对应位置上输入与这些字符对应的相同的字符。</p>
<p>如有</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“a=%d,b=%f,c=%c”,&amp;a,&amp;b,&amp;c);</span><br></pre></td></tr></table></figure></div>

<p>要想输入数据1,2,3，则应输入：a&#x3D;1,b&#x3D;2,c&#x3D;3(回车)&#x2F;&#x2F;注意这里的a&#x3D;、b&#x3D;、c&#x3D;和逗号’,’</p>
<p>当然，其中的格式可以自己定义，如可以用空格’ ’隔开，还有输入时间的时分秒可以用’:’隔开等。</p>
<p>这里特别要注意字符和字符串的混合输入问题。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c%c%c&quot;</span>,&amp;a,&amp;b,&amp;c);<span class="comment">//输入x y z，则a=‘x’，b=‘ ’，c=‘y’；应连续输入xyz。</span></span><br></pre></td></tr></table></figure></div>

<p>输入输出函数数据之间的格式化间隔符（空格、TAB、回车或非法数据（“%d”，12A）等）</p>
<p>非格式间隔符（‘，’、‘！’等任意间隔符）；使用非格式间隔符时需要在输入的时候也用此间隔符分隔。</p>
<p>③在输入数值型数据时，如输入空格、回车、tab键或非法字符（除scanf格式声明中指定的）等不属于数值的字符，则认为此数据输入结束。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%d%c%f”,&amp;a,&amp;b,&amp;c);<span class="comment">//输入1234a567.8b9,a=1234,b=’a’,c=567.8 //&amp;取址符</span></span><br></pre></td></tr></table></figure></div>

<p>④scanf函数中double型数据需要使用%lf才能正常得到所输入的值，而输出可以用%f输出。</p>
<p>⑤在输入时也可以进行域宽控制</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%3d%4d&quot;</span>,&amp;a,&amp;b); <span class="comment">//输入12345678，则a=123，b=4567；</span></span><br></pre></td></tr></table></figure></div>

<p>注意各种类型的数据混合输入存在的问题</p>
<p>（1）字符型数据的输入和输出</p>
<p>①putchar字符输出函数</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>(a);<span class="comment">//输出字符型变量a的值</span></span><br><span class="line">	<span class="comment">//请区别对待putchar(&#x27;a&#x27;);</span></span><br></pre></td></tr></table></figure></div>

<p>②getchar字符输入函数</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch=getchar();	<span class="comment">//从键盘输入一个字符，存入字符变量ch中</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,getchar());	<span class="comment">//也可在格式化输出语句中直接输出所接收的字符</span></span><br></pre></td></tr></table></figure></div>

<p>由于scanf、getchar等输入函数没有从键盘接收到数据就不会继续执行，所以在程序中可以起到与system(“pause”);函数类似的暂停效果。</p>
<h1 id="三、运算符和表达式"><a href="#三、运算符和表达式" class="headerlink" title="三、运算符和表达式"></a>三、运算符和表达式</h1><h2 id="1、C语言运算符"><a href="#1、C语言运算符" class="headerlink" title="1、C语言运算符"></a>1、C语言运算符</h2><h3 id="1-1、C运算符的分类"><a href="#1-1、C运算符的分类" class="headerlink" title="1.1、C运算符的分类"></a>1.1、C运算符的分类</h3><p>C提供了各种各样不同作用的运算符，共分为以下几类：</p>
<p>（1）算术运算符			（+、-、*、&#x2F;、%、++、–）加、减、乘、除、模、自增、自减</p>
<p>（2）关系运算符			（&gt;、&lt;、&#x3D;&#x3D;、&gt;&#x3D;、&lt;&#x3D;、!&#x3D;） </p>
<p>（3）逻辑运算符			（&amp;&amp;与、||或、！非）</p>
<p>（4）位运算符				（左移&lt;&lt;、右移&gt;&gt;、按位非~、按位或|、按位异或^、按位与&amp;）</p>
<p>（5）赋值运算符			（&#x3D;及其扩展赋值运算符+&#x3D;、-&#x3D;、&#x3D;、&#x2F;&#x3D;、%&#x3D;等）等于</p>
<p>（6）条件运算符			（? :) (表达式1)?(表达式2):(表达式3) 三目运算符</p>
<p>（7）逗号运算符			（,）</p>
<p>（8）指针运算符			（*、&amp;）</p>
<p>（9）求字节数运算符	（sizeof()）</p>
<p>（10）强制类型转换符	((类型名))</p>
<p>（11）成员引用符			(.、-&gt;)结构体或共用体的成员引用符</p>
<p>（12）下标运算符			([])数组元素下标</p>
<p>（13）其他运算符			(如函数调用运算符()，复合语句符{}，语句结束符;等)</p>
<p>这一章主要讲解算术运算符、关系运算符、逻辑运算符、赋值运算符和条件运算符等常用运算符的运算规则，其他运算符待之后几章讲解相关知识点时再仔细讲解。</p>
<h3 id="1-2、运算符的操作数以及目数"><a href="#1-2、运算符的操作数以及目数" class="headerlink" title="1.2、运算符的操作数以及目数"></a>1.2、运算符的操作数以及目数</h3><p>①操作数：操作数是运算符操作的实体，是表达式的一个组成部分，它规定了运算指令中进行数值运算的量。</p>
<p>②目数：这些运算符根据其参与运算的操作数的个数不同，而分为了单目运算符、双目运算符和三目运算符。</p>
<p>有1个操作数的运算符为单目运算符，有2个操作数的运算符为双目运算符，有3个操作数的运算符为三目运算符。C语言中运算符的操作数最多为3个。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">x = <span class="number">1</span>; 	<span class="comment">//其中x和1分别是赋值运算符=的左操作数和右操作数，操作数为两个，所以=是双目运算符</span></span><br><span class="line">y = x++;	<span class="comment">//其中y和x++分别是赋值运算符=的左操作数和右操作数，而x又是自增运算符++的左操作数，所以++是单目运算符</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-3、运算符的优先级"><a href="#1-3、运算符的优先级" class="headerlink" title="1.3、运算符的优先级"></a>1.3、运算符的优先级</h3><p>C运算符的优先级及相关内容如下表所示：</p>
<p>通常意义上来说（广义）运算符的优先级大致为：单目&gt;双目&gt;三目。</p>
<p>优先级详细划分为：算术运算符&gt;关系运算符&gt;逻辑运算符&gt;条件运算符&gt;赋值运算符&gt;逗号运算符</p>
<h2 id="2、算术运算符"><a href="#2、算术运算符" class="headerlink" title="2、算术运算符"></a>2、算术运算符</h2><h3 id="2-1、基本的算术运算符"><a href="#2-1、基本的算术运算符" class="headerlink" title="2.1、基本的算术运算符"></a>2.1、基本的算术运算符</h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
<th align="center">举例</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">正号运算符（单目运算符）</td>
<td align="center">+a</td>
<td align="center">a的值</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">负号运算符（单目运算符）</td>
<td align="center">-a</td>
<td align="center">a的算术负值</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘法运算符（双目运算符）</td>
<td align="center">a*b</td>
<td align="center">a和b的乘积</td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除法运算符（双目运算符）</td>
<td align="center">a&#x2F;b</td>
<td align="center">a除以b的商</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取余运算符（双目运算符）</td>
<td align="center">a%b</td>
<td align="center">a除以b的余数</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">加法运算符（双目运算符）</td>
<td align="center">a+b</td>
<td align="center">a与b的和</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减法运算符（双目运算符）</td>
<td align="center">a-b</td>
<td align="center">a与b的差</td>
</tr>
</tbody></table>
<p>说明：</p>
<p>①由于键盘没有×号，运算符×以*代替。</p>
<p>②由于键盘没有÷号，运算符÷以&#x2F;代替（反斜杠）。（注意区分\斜杠）</p>
<p>③整数相除的结果仍为整数！如：-5&#x2F;3结果为-1（向0取整，舍去小数）。（5.0&#x2F;3&#x3D;1.666666）</p>
<p>④%（求余运算符）要求参加运算的运算对象（即操作数）为整数，结果也为整数。如8%6结果为2。（思考一下8.0%6&#x3D;？）</p>
<p>⑤除%以外运算符的操作数都可以是任何算术类型。</p>
<h3 id="2-2、自增、自减运算符"><a href="#2-2、自增、自减运算符" class="headerlink" title="2.2、自增、自减运算符"></a>2.2、自增、自减运算符</h3><p>++（自增运算符）、–（自减运算符）它们都属于单目运算符。</p>
<p>例如：</p>
<p>++i；–i；（在使用i之前，先使i的值加（减）1，先加减后使用）</p>
<p>i++；i–；（在使用i之后，使i的值加（减）1，先使用后加减）</p>
<p>粗略地看，++i和i++的作用都相当于i&#x3D;i+1。但是++i和i++的不同之处在于：++i是先执行i&#x3D;i+1，再使用i的值；而i++是先使用i的值，再执行i&#x3D;i+1。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>,j;</span><br><span class="line">j=++i;	<span class="comment">//i的值先+1变成2，再赋值给j，j的值为2</span></span><br><span class="line">j=i++;	<span class="comment">//先将i的值赋值给j，j的值为2，然后再将i的值+1变成3</span></span><br></pre></td></tr></table></figure></div>

<p>又例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">3</span>；</span><br><span class="line"><span class="built_in">printf</span>(“%d”,++i);	<span class="comment">//输出4，i=4</span></span><br><span class="line"><span class="built_in">printf</span>(“%d”,i++);	<span class="comment">//输出4，i=5</span></span><br></pre></td></tr></table></figure></div>

<p>注意：++和–运算符只能用于变量，而不能用于常量或表达式，如5++或–(i+j)等。</p>
<p>使用++和–的时候，会出现一种情况，如i+++j，是理解成(i++)+j呢？还是理解成i+(++j)呢？为了避免二义性，可以加一些“不必要的括号”，如(i++)+j。</p>
<h3 id="2-3、算术表达式与运算符的优先级和结合性"><a href="#2-3、算术表达式与运算符的优先级和结合性" class="headerlink" title="2.3、算术表达式与运算符的优先级和结合性"></a>2.3、算术表达式与运算符的优先级和结合性</h3><p>什么叫算术表达式呢？</p>
<p>用算术运算符和括号将运算对象（操作数）连接起来的、符合C语法规则的式子，就称为C语言算术表达式。运算对象包括常量、变量、函数等。例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（a+b）*c/d<span class="number">-1.5</span>+<span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>C语言规定了运算符的优先级和结合性。</p>
<p>与数学运算符的优先级和结合性类似，乘、除、模（、&#x2F;、%）运算符的优先级要高于加减（+、-），结合方向都是“从左至右”，同一优先级的运算符，按结合性依次执行。</p>
<h3 id="2-4、不同类型数据间的混合运算"><a href="#2-4、不同类型数据间的混合运算" class="headerlink" title="2.4、不同类型数据间的混合运算"></a>2.4、不同类型数据间的混合运算</h3><p>在程序运行中，经常会遇到不同类型的数据进行运算，如6+8.8。如果一个运算符的两侧数据类型不同，则先自动进行类型转换，使二者具有同一种类型，然后进行运算。因此整型、实型、字符型数据间可以进行混合运算。</p>
<p>（1）+、-、*、&#x2F;运算的两个操作数进行运算，如果其中有一个数位float或double型，结果是double型，因为系统将所有float型数据都先转换为double型，然后进行运算的。</p>
<p>（2）如果是int型与float或double型数据进行运算，先把int型和float型数据转换为double型，然后再进行运算，结果为double型。</p>
<p>（3）字符型（char）数据与整型数据进行运算，就是把字符的ASCII码与整型数据进行运算。如：10+’A’，由于字符A的ASCII码为65，就相当于10+65，等于75，字符型数据可以直接与整型数据进行运算。如果字符型数据与实型数据进行运算，则将字符对应的ASCII码转换为double型数据，然后进行运算。</p>
<p>（4）整型（int）与无符号整型（unsigned）之间进行运算，以无符号整型为准，先把int型数据转换为unsigned型，然后再做运算。</p>
<p>以上转换是隐式类型转换，是编译系统自动完成的，用户不必过问。</p>
<p>例如：</p>
<p>以下表达式的值为多少？</p>
<p>10+’a’-3*2.5+5&#x2F;2-7%2&#x3D;107-7.5+2-1&#x3D;100.500000</p>
<p>例题：给定一个大写字母，要求输出其对应的小写字母。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>(ch+<span class="number">32</span>);</span><br></pre></td></tr></table></figure></div>



<h2 id="3、强制类型转换运算符"><a href="#3、强制类型转换运算符" class="headerlink" title="3、强制类型转换运算符"></a>3、强制类型转换运算符</h2><p>C语言中可以运用强制类型转换运算符将一个表达式转换成所需的类型。</p>
<p>强制类型转换的一般格式为：(类型名)(表达式)</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">double</span>)a	<span class="comment">//将变量a强制类型转换为double类型</span></span><br><span class="line">(<span class="type">int</span>)(x+y)	<span class="comment">//将表达式(x+y)的结果强制类型转换为int类型</span></span><br><span class="line">(<span class="type">float</span>)(<span class="number">5</span>%<span class="number">3</span>)<span class="comment">//将表达式(5%3)的结果强制类型转换为float类型</span></span><br><span class="line">(<span class="type">int</span>)<span class="number">6.8</span>%<span class="number">3</span>	<span class="comment">//将小数6.8强制类型转换为int类型，然后再于整数3求余</span></span><br></pre></td></tr></table></figure></div>

<p>注意：表达式应该用括号括起来。</p>
<p>如果写成：(int)x+y，则只是将x转换成整型，然后再与y相加。如果想要将表达式x+y的值转换为整型，应写成(int)(x+y)。</p>
<p>强制类型转换后的值只是临时值，不对数据本身操作。</p>
<h2 id="4、关系运算符"><a href="#4、关系运算符" class="headerlink" title="4、关系运算符"></a>4、关系运算符</h2><p>关系运算符是一个双目运算符，用于比较两个操作数之间的大小关系，其中包含大于（&gt;）、小于（&lt;）、等于（&#x3D;&#x3D;）、大于等于（&gt;&#x3D;）、小于等于（&lt;&#x3D;）、不等于（!&#x3D;）这些运算符，运算结果是一个逻辑值（真&#x2F;假）。</p>
<p>逻辑值：0为假，非0为真，如：1、2、100、-1、-10、’a’、12.3 等数据的逻辑值为真，逻辑值为真的表达式结果默认为1，也就是1代表真，只有0代表逻辑假。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关系运算符（&gt;、&lt;、==、&gt;=、&lt;=、!=）</span></span><br><span class="line"><span class="comment">//运算结果为逻辑值：0表示假，非0表示真（1）</span></span><br><span class="line"><span class="number">1</span>&lt;=<span class="number">2</span>;	<span class="comment">//结果为真（1），因为1小于等于2，条件满足</span></span><br><span class="line"><span class="number">1</span>&gt;<span class="number">3</span>	<span class="comment">//结果为假（0），因为1大于3，条件不满足</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">5</span> != <span class="number">5</span>);	<span class="comment">//结果为假（0），因为5不等于5，条件为假</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a&lt;=b);	<span class="comment">//结果为真（1），a小于b条件满足</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a==b);	<span class="comment">//结果为假（0），a等于b条件不满足</span></span><br></pre></td></tr></table></figure></div>



<h2 id="5、逻辑运算符"><a href="#5、逻辑运算符" class="headerlink" title="5、逻辑运算符"></a>5、逻辑运算符</h2><p>逻辑运算符用于连接多个条件语句，判断多个条件值联合的结果，其中包含与(&amp;&amp;)、或(||)、非(!)三种运算。</p>
<p>与、或、非运算的基本使用如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&amp;&amp;（与运算）：双目运算符，用于连接两个表达式，相当于并且的意思</span></span><br><span class="line"><span class="comment">运算规则：同真为真，否则为假</span></span><br><span class="line"><span class="comment">只有&amp;&amp;运算符两边操作数的逻辑值同时为真，整个逻辑表达式的值才为真，否则整个表达式的值为假</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">1</span>&lt;<span class="number">2</span> &amp;&amp; <span class="number">5</span>&lt;<span class="number">4</span>);	<span class="comment">//1&lt;2并且5&lt;4，其中1&lt;2为真，5&lt;4为假，整个表达式的值为假</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">1</span>&lt;<span class="number">2</span> &amp;&amp; <span class="number">5</span>!=<span class="number">4</span>);	<span class="comment">//1&lt;2并且5!=4，其中1&lt;2为真，5!=4为真，整个表达式的值为真</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*||（或运算）：双目运算符，用于连接两个表达式，相当于或者的意思</span></span><br><span class="line"><span class="comment">运算规则：同假为假，否则为真</span></span><br><span class="line"><span class="comment">只有||运算符两边的操作数的逻辑值同时为假，整个逻辑表达式的值才为假，否则整个表达式的值为真</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0</span> || <span class="number">-1</span>);	<span class="comment">//其中-1的逻辑值为真，整个表达式的结果为真（1）</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x || y);</span><br><span class="line"><span class="comment">//x和y的值都为0，也就是逻辑值都为假，所以整个逻辑表达式 x || y的值就为假，输出结果为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">!（非运算）：单目运算符，用于将之后的表达式的逻辑值取反</span></span><br><span class="line"><span class="comment">运算规则：真变假，假变真,（取反）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !<span class="number">-2</span>);	<span class="comment">//其中(-2)的逻辑值为真，所以(!-2)的逻辑值为假，输出结果为0</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, !n);	<span class="comment">//其中n的逻辑值为假，所以(!n)的逻辑值为真，输出结果为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;&amp;和||存在的短路运算：</span></span><br><span class="line"><span class="type">int</span> g = <span class="number">1</span>, h = <span class="number">1</span>;</span><br><span class="line">++g || ++h;	<span class="comment">//||的短路运算：前一个条件为真，之后的条件不管为真还是为假都不执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>, g, h);	<span class="comment">//结果为：1	1</span></span><br><span class="line"></span><br><span class="line">g = <span class="number">1</span>, h = <span class="number">1</span>;</span><br><span class="line">--g &amp;&amp; --h;	<span class="comment">//&amp;&amp;的短路运算：前一个条件为假，之后的条件不管为真还是为假都不执行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>, g, h);	<span class="comment">//结果为：0	1</span></span><br></pre></td></tr></table></figure></div>

<p>与、或、非运算的操作数可以是int、float、char等多种数据类型的表达式。</p>
<h2 id="6、条件运算符"><a href="#6、条件运算符" class="headerlink" title="6、条件运算符"></a>6、条件运算符</h2><p>条件运算符（? :）用于条件判断。</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(表达式<span class="number">1</span>)?(表达式<span class="number">2</span>):(表达式<span class="number">3</span>);</span><br></pre></td></tr></table></figure></div>

<p>运算规则：首先判断表达式1的逻辑值，如果表达式1的逻辑值为真，则执行冒号’:‘之前的表达式2，整个条件表达式的值为表达式2的值；如果表达式1的逻辑值为假，则执行冒号’:‘之后的表达式3，整个条件表达式的值为表达式3的值。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出两个数中的最大值</span></span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x &gt; y ? x : (x == y ? x : y));</span><br><span class="line">	<span class="comment">//判断表达式(x&gt;y)的逻辑值，如果为真则整个表达式的值为冒号之前的x的值</span></span><br><span class="line">	<span class="comment">//否则执行(x == y ? x : y)，这又是一个含有条件运算符的条件表达式</span></span><br><span class="line">	<span class="comment">//判断(x == y)的值，如果为真则整个表达式的值为x，否则为y</span></span><br></pre></td></tr></table></figure></div>



<h2 id="7、位运算符"><a href="#7、位运算符" class="headerlink" title="7、位运算符"></a>7、位运算符</h2><p>位运算符是针对数据的二进制进行运算的，其中包含左移”&lt;&lt;”、右移”&gt;&gt;”、按位非”~”、按位或”|”、按位异或”^”、按位与”&amp;”这六种位运算，其只能对整型数据操作，运算规则如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左移运算符&quot;&lt;&lt;&quot;，是一个双目运算符</span></span><br><span class="line"><span class="comment">基本格式：整数&lt;&lt;n</span></span><br><span class="line"><span class="comment">其用于将一个整数的二进制向左移动n个二进制位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a&lt;&lt;<span class="number">2</span>);	<span class="comment">//输出结果为：40，相当于乘以2的2次方</span></span><br><span class="line"><span class="comment">//将变量a的值左移两个二进制位并输出，a本身的值不变</span></span><br><span class="line"><span class="comment">//a等于10，10的二进制为00001010，左移2位就是00101000，转换为十进制为40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">右移运算符&quot;&gt;&gt;&quot;，是一个双目运算符，与左移类似</span></span><br><span class="line"><span class="comment">基本格式：整数&gt;&gt;n</span></span><br><span class="line"><span class="comment">用于将一个整数的二进制向右移动n个二进制位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">a&gt;&gt;=<span class="number">3</span>;	<span class="comment">//a=1,相当于a除2的3次方,</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);	<span class="comment">//输出结果为：1</span></span><br><span class="line"><span class="comment">//相当于a=a&gt;&gt;2，将变量a的值右移两个二进制位后赋值给本身，a本身的值变为40</span></span><br><span class="line"><span class="comment">//a等于10，10的二进制为00001010，右移3位就是00000001，转换为十进制为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按位非&quot;~&quot;，是一个单目运算符</span></span><br><span class="line"><span class="comment">基本格式：~整数</span></span><br><span class="line"><span class="comment">用于将一个整数的二进制各个位数取反</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">short</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,~b);	<span class="comment">//输出结果为：-21</span></span><br><span class="line"><span class="comment">//b等于20，20的二进制为：00000000 00010100，各位取反为：11111111 11101011</span></span><br><span class="line"><span class="comment">//由于计算机内是用补码做运算的，所以负数的补码转换成原码后为：10000000 00010100，结果为-21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按位或&#x27;|&#x27;，双目运算符</span></span><br><span class="line"><span class="comment">基本格式：整数|整数</span></span><br><span class="line"><span class="comment">用于将两个整数的二进制相或，遵循有1为1，否则为0的规则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a|b);	<span class="comment">//结果为30</span></span><br><span class="line">	<span class="comment">// a:	00000000 00001010</span></span><br><span class="line">	<span class="comment">// b:	00000000 00010100</span></span><br><span class="line">	<span class="comment">// a|b:	00000000 00011110</span></span><br><span class="line">	<span class="comment">// 相同二进制位相或，有1为1，否则为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按位与&#x27;&amp;&#x27;，双目运算符</span></span><br><span class="line"><span class="comment">基本格式：整数&amp;整数</span></span><br><span class="line"><span class="comment">用于将两个整数的二进制相与，遵循有0为0，否则为1的规则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a&amp;b);	<span class="comment">//结果为10</span></span><br><span class="line">	<span class="comment">// a:	00000000 00001010</span></span><br><span class="line">	<span class="comment">// b:	00000000 00011110</span></span><br><span class="line">	<span class="comment">// a&amp;b:	00000000 00001010</span></span><br><span class="line">	<span class="comment">// 相同二进制位相与，有0为0，否则为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">按位异或&#x27;^&#x27;</span></span><br><span class="line"><span class="comment">基本格式：整数^整数</span></span><br><span class="line"><span class="comment">用于将两个整数的二进制相异或，遵循相同为0，相异为1的规则</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a^b);	<span class="comment">//结果为20</span></span><br><span class="line">	<span class="comment">// a:	00000000 00001010</span></span><br><span class="line">	<span class="comment">// b:	00000000 00011110</span></span><br><span class="line">	<span class="comment">// a^b:	00000000 00010100</span></span><br><span class="line">	<span class="comment">// 相同二进制位相异或，相同为0，相异为1</span></span><br></pre></td></tr></table></figure></div>



<h2 id="8、表达式和C语句"><a href="#8、表达式和C语句" class="headerlink" title="8、表达式和C语句"></a>8、表达式和C语句</h2><h3 id="8-1、表达式和语句的基本概念"><a href="#8-1、表达式和语句的基本概念" class="headerlink" title="8.1、表达式和语句的基本概念"></a>8.1、表达式和语句的基本概念</h3><p>一个C语言程序由若干个源程序文件组成，一个源文件由若干个函数和预处理指令以及全局变量声明部分组成。如一个函数有数据声明部分和执行语句，其都是由语句组成的。语句的作用使向计算机系统发出操作指令，要求执行相应的操作。一个C语句经过编译后产生若干条机器指令。<br>C程序的基本组成单位是函数，函数又由一条或多条C语句构成，而C语句又是多个表达式的组合。</p>
<h3 id="8-2、逗号表达式"><a href="#8-2、逗号表达式" class="headerlink" title="8.2、逗号表达式"></a>8.2、逗号表达式</h3><p>逗号表达式是一类特殊的表达式，其是由逗号运算符隔开的多个表达式的组合，逗号起到分隔的作用。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,c=<span class="number">30</span>;</span><br><span class="line">	<span class="comment">//逗号隔开的多个相同类型变量的定义个初始化赋值</span></span><br></pre></td></tr></table></figure></div>

<p>逗号分隔的多个表达式是依次从左至右执行的，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">a=<span class="number">1</span>,b=<span class="number">2</span>,c=a+b;</span><br><span class="line">	<span class="comment">//这里是先执行a=1，再执行b=2，最后才执行c=a+b,c的值为3</span></span><br></pre></td></tr></table></figure></div>

<p>整个逗号表达式的值以逗号分隔的最后一个表达式为准，如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a,b,c,d;</span><br><span class="line">d=(a=1,b=2,c=a+b);</span><br><span class="line">	//这里d的值为逗号分隔的最后一个表达式的值，也就是c=a+b的值，相当于d=c，d的值为3</span><br><span class="line"></span><br><span class="line">d=a=1,b=2,c=a+b;</span><br><span class="line">	//这里d的值为第一个表达式的值，d的值为1</span><br></pre></td></tr></table></figure></div>



<h3 id="8-3、最基本的语句——赋值语句"><a href="#8-3、最基本的语句——赋值语句" class="headerlink" title="8.3、最基本的语句——赋值语句"></a>8.3、最基本的语句——赋值语句</h3><p>在C语言中最常用的语句就是赋值语句和输入输出语句了。其中最基本的就是赋值语句，程序中的计算功能大部分是由赋值语句实现的，几乎每个有实用价值的程序都包括赋值语句。</p>
<p>（1）赋值运算符’&#x3D;’</p>
<p>与数学中的’&#x3D;’不同的是，在C语言中，’&#x3D;’为赋值运算符，它是用来将一个数据赋值给一个变量的。如a&#x3D;1;的作用是执行一次赋值操作（赋值运算），把1赋值给变量a。也可以将一个表达式的值赋值给一个变量，如a&#x3D;1+2;a&#x3D;b+c+1;等。</p>
<p>（2）复合的赋值运算符</p>
<p>在赋值运算符&#x3D;之前加上其他运算符，可以构成复合的运算符。</p>
<p>主要有：+&#x3D;、-&#x3D;、&#x3D;、&#x2F;&#x3D;、%&#x3D;这几种复合赋值运算符。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x+=y;	<span class="comment">//相当于：x=x+y;</span></span><br><span class="line">x=y;	<span class="comment">//相当于：x=x*y;</span></span><br><span class="line">x+=y+<span class="number">1</span>;	<span class="comment">//相当于x+=(y+1);	x=x+(y+1);</span></span><br><span class="line">x=y+<span class="number">1</span>;	<span class="comment">//相当于x=(y+1);	x=x(y+1);</span></span><br></pre></td></tr></table></figure></div>

<p>（3）赋值表达式和赋值语句</p>
<p>右值和左值</p>
<p>左值应该为可修改的变量，右值可以为任意符合规范且赋值有效的表达式。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>；</span><br><span class="line">a=b=c=<span class="number">1</span>;		<span class="comment">//a=1;b=1;c=1;</span></span><br><span class="line">a=(b=<span class="number">1</span>)+(c=<span class="number">2</span>);	<span class="comment">//a=3;b=1;c=2;</span></span><br><span class="line">a=(b=<span class="number">1</span>)(c=<span class="number">2</span>);</span><br></pre></td></tr></table></figure></div>

<p>赋值运算符是按照“从右至左”的结合顺序运行的。</p>
<p>（4）变量赋初值</p>
<p>在变量定义时对变量赋值就称为变量赋初值，也称为变量的初始化赋值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="8-4、C语句的分类"><a href="#8-4、C语句的分类" class="headerlink" title="8.4、C语句的分类"></a>8.4、C语句的分类</h3><p>C语句分为以下5类：</p>
<p>（1）表达式语句</p>
<p>表达式语句是由一个表达式加一个分号构成，最典型的是由赋值表达式构成的赋值语句，例如：a&#x3D;3是赋值表达式，而a&#x3D;3;是赋值语句。还有由逗号表达式构成语句，的由条件表达式构成的条件表语句，和逻辑表达式构成的逻辑语句等。</p>
<p>（2）控制语句</p>
<p>控制语句是由流程控制表达式组成的语句，用于完成一定的流程控制功能。</p>
<p>C语言提供9种控制结构语句，它们分别为：</p>
<p>①if()…else…	（选择结构）</p>
<p>②for(;;)…		 （循环结构）</p>
<p>③while()…	   （循环结构）</p>
<p>④do…while(); （循环结构）</p>
<p>⑤break;		  （结束整个循环）</p>
<p>⑥continue;	 （结束本次循环，执行下次循环）</p>
<p>⑦switch		  （多分支选择结构）</p>
<p>⑧return		  （函数返回语句）</p>
<p>⑨goto			 （跳转语句，在结构化程序中最好不要用goto语句）</p>
<p>（3）函数调用语句</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这是一个简单的调用输出函数的语句。其中printf(“hello world!”)是一个函数调用，加一个分号’;’就是函数调用语句了。</p>
<p>（4）空语句</p>
<p>空语句就是：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;	<span class="comment">//只有一个分号的语句，什么都不做</span></span><br></pre></td></tr></table></figure></div>

<p>（5）复合语句</p>
<p>在C语言中可以用{}把一些语句括起来，形成一条复合语句（又称为语句块）。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;	<span class="comment">//这是一个复合语句（语句块）</span></span><br><span class="line">	<span class="type">int</span> a,b,c;</span><br><span class="line">	a=<span class="number">1</span>;</span><br><span class="line">	b=<span class="number">2</span>;</span><br><span class="line">	c=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>复合语句需要注意变量的作用域问题，其常用于选择分支结构和循环结构等控制语句中，其目的是让控制语句可以控制多条语句，达到我们想要的效果。</p>
<h1 id="四、选择结构和循环结构"><a href="#四、选择结构和循环结构" class="headerlink" title="四、选择结构和循环结构"></a>四、选择结构和循环结构</h1><p>C语言中的基本控制结构分为顺序结构、选择结构和循环结构，它们控制着程序的执行。</p>
<h2 id="1、选择结构"><a href="#1、选择结构" class="headerlink" title="1、选择结构"></a>1、选择结构</h2><p>在很多情况下，需要根据某个条件是否满足来决定是否执行指定的操作任务，或者从给定的两个或多个操作选择其中一个执行，这就需要用到我们的选择结构了。</p>
<p>C语言提供了两种选择结构：if语句和switch语句。</p>
<h3 id="1-1、if语句"><a href="#1-1、if语句" class="headerlink" title="1.1、if语句"></a>1.1、if语句</h3><p>If语句的一般形式：</p>
<p>if（表达式）语句1;</p>
<p>[else 语句2;]</p>
<p>根据if语句的一般形式，可以写成不同的形式，最常用的有以下三种形式：</p>
<p>（1）if(表达式)语句1;	&#x2F;&#x2F;单独的一个if语句，用于实现两个分支的判断选择</p>
<p>（2）if(表达式)语句1;	&#x2F;&#x2F;if和else组合，用于实现两个分支的判断选择</p>
<p>​		  else 语句2;</p>
<p>（3）if(表达式)语句1;	&#x2F;&#x2F;if else嵌套，用于实现多分支结构</p>
<p>​		  else if(表达式)语句2;	&#x2F;&#x2F;if和else的配对问题，就近原则</p>
<p>​		  else if(表达式)语句3;	&#x2F;&#x2F;else和前面最近的没有配对的if配对</p>
<p>​		  else语句4；……</p>
<p>例题1：从键盘输入一个年份，判断其是否为闰年。</p>
<p>提示：闰年是指能被4整除并且不能被100整除（普通闰年），或者能被400整除的年份（世纪闰年），否则就为平年。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> year;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一个年份：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;year);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d年是世纪闰年。\n&quot;</span>, year);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d年是普通闰年。\n&quot;</span>, year);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d年是平年。\n&quot;</span>, year);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="1-2、switch语句"><a href="#1-2、switch语句" class="headerlink" title="1.2、switch语句"></a>1.2、switch语句</h3><p>switch语句的一般形式：</p>
<p>switch(判断条件)</p>
<p>{</p>
<p>case 常量1：语句1；</p>
<p>case 常量2：语句2；</p>
<p>case 常量3：语句3；</p>
<p>……</p>
<p>case 常量n：语句n；</p>
<p>default：语句n+1;</p>
<p>}</p>
<p>例题2：从键盘输入的学生成绩（0~100分），给学生的成绩评定等级。优秀（成绩&gt;&#x3D;90）、良好（90&gt;成绩&gt;&#x3D;80）、及格（80&gt;成绩&gt;&#x3D;60）和不及格（成绩&lt;60）。</p>
<p>（1）用if语句实现</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一个成绩（1~100分）：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成绩等级：&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (score &gt;= <span class="number">90</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;优秀\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;良好\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;及格\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;不及格\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成绩输入错误！\n输入的成绩应该在1~100之间！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（2）用switch语句实现</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一个成绩（1~100分）：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (score &gt;= <span class="number">0</span> &amp;&amp; score &lt;= <span class="number">100</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成绩等级：&quot;</span>);</span><br><span class="line">		<span class="keyword">switch</span> (score / <span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">&quot;优秀\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>: <span class="built_in">printf</span>(<span class="string">&quot;良好\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;及格\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;不及格\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成绩输入错误！\n输入的成绩应该在1~100之间！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="2、循环结构"><a href="#2、循环结构" class="headerlink" title="2、循环结构"></a>2、循环结构</h2><p>在程序所处理的问题中，我们常常会需要重复处理同一类操作，这样我们就需要循环控制它们的执行了。</p>
<h3 id="2-1、for循环"><a href="#2-1、for循环" class="headerlink" title="2.1、for循环"></a>2.1、for循环</h3><p>for循环的一般格式为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>) 		<span class="comment">//注意：表达式之间的分隔符‘;’不能少</span></span><br><span class="line">&#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//表达式1：条件的初始化语句</span></span><br><span class="line"><span class="comment">//表达式2：循环继续的条件</span></span><br><span class="line"><span class="comment">//表达式3：改变循环条件的语句</span></span><br></pre></td></tr></table></figure></div>

<p>如：循环输出整数0~9</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">10</span>;a++)</span><br><span class="line">	<span class="built_in">printf</span>(“a=%d\t”,a);</span><br></pre></td></tr></table></figure></div>

<h3 id="2-2、while循环"><a href="#2-2、while循环" class="headerlink" title="2.2、while循环"></a>2.2、while循环</h3><p>while循环的一般格式为：</p>
<p>while(表达式)</p>
<p>{</p>
<p>​	循环体;</p>
<p>}</p>
<h3 id="2-3、do-while循环"><a href="#2-3、do-while循环" class="headerlink" title="2.3、do  while循环"></a>2.3、do  while循环</h3><p>do  while循环的一般格式：</p>
<p>do</p>
<p>{</p>
<p>​	循环体;</p>
<p>}while(表达式);</p>
<h3 id="2-4、循环结构的分类"><a href="#2-4、循环结构的分类" class="headerlink" title="2.4、循环结构的分类"></a>2.4、循环结构的分类</h3><p>（1）当型循环</p>
<p>当循环条件满足时才执行循环体中的语句。</p>
<p>（2）直到型循环</p>
<p>直到条件不满足时才结束循环，至少会执行一次循环体。 </p>
<p>例题：输出以下图案：</p>
<p>（1）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">***</span><br><span class="line">***</span><br><span class="line">***</span><br><span class="line">***</span><br></pre></td></tr></table></figure></div>

<p>C语言代码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>i++)	<span class="comment">//for循环</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;***\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">where(i--)	<span class="comment">//where循环</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;***\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">do</span>	<span class="comment">//do where循环</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;***\n&quot;</span>);</span><br><span class="line">&#125;where(--i);</span><br></pre></td></tr></table></figure></div>



<h2 id="3、跳转语句"><a href="#3、跳转语句" class="headerlink" title="3、跳转语句"></a>3、跳转语句</h2><h3 id="3-1、break语句"><a href="#3-1、break语句" class="headerlink" title="3.1、break语句"></a>3.1、break语句</h3><p>break语句用于switch分支结构和循环结构中，起到跳出switch分支结构或者跳出整个循环结构的作用。</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、continue语句"><a href="#3-2、continue语句" class="headerlink" title="3.2、continue语句"></a>3.2、continue语句</h3><p>continue语句用于循环语句中，起到跳出本次循环，继续执行下次循环的作用。</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3、goto跳转语句"><a href="#3-3、goto跳转语句" class="headerlink" title="3.3、goto跳转语句"></a>3.3、goto跳转语句</h3><p>goto语句支持跳转到指定的位置。</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标记:	<span class="comment">//标记的命名需要符合标识符的命名规则</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">goto</span> 标记;	<span class="comment">//执行goto语句后，会跳转到指定标记的位置</span></span><br></pre></td></tr></table></figure></div>

<p>由于goto语句使程序执行的流程变复杂，不利于结构化程序的结构控制和意义的理解，所以一般不使用goto语句。</p>
<h1 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h1><p>在之前的程序中使用的变量都属于基本类型，如整型、字符型、浮点型数据，这些都是简单的数据类型。对于简单的问题，使用这些简单的数据类型就可以了。</p>
<p>由于程序有时候需要处理大批量的数据，如：一个班有60个学生，每个学生都有一个成绩，求这些学生的平均成绩，我们怎么实现呢？按照之前定义变量的方法，需要定义60个float类型的变量才能保存下所有学生的成绩。</p>
<p>只用简单的数据类型虽然也可以实现，但是会太过麻烦。所以人们就想出了一个办法：既然它们都是同一类性质的数据，就可以用同一个名字来代表它们，而在名字后加一个数字来表示是第几个数值。如：用S代表这些学生，那就可以用S1、S2、S3、…、S60代表学生1、学生2、学生3、…、学生60等60个学生的成绩，和数学中的数列类似，这样就产生了数组这样一个概念。</p>
<h2 id="1、什么是数组？"><a href="#1、什么是数组？" class="headerlink" title="1、什么是数组？"></a>1、什么是数组？</h2><p>数组的定义可以用以下3点来说明：</p>
<p>（1）数组是一组有序数据的集合。<br>数组中各数据的排列是有一定规律的，下标代表数据在数组中的序号。</p>
<p>（2）用一个数组名和下标来唯一地标识确定数组中的元素。<br>如：S10就代表第十个学生的成绩。</p>
<p>（3）数组中的每一个元素都是属于同一数据类型。<br>规定不能把不同数据类型的数据放在同一个数组中。</p>
<h2 id="2、一维数组的定义和引用"><a href="#2、一维数组的定义和引用" class="headerlink" title="2、一维数组的定义和引用"></a>2、一维数组的定义和引用</h2><h3 id="2-1、定义一维数组"><a href="#2-1、定义一维数组" class="headerlink" title="2.1、定义一维数组"></a>2.1、定义一维数组</h3><p>基本格式：数据类型 数组名[数组大小];</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> S[<span class="number">60</span>]; </span><br><span class="line"><span class="comment">//定义一个浮点型数组，取名为S，大小为60，用于保存60个学生的成绩。</span></span><br></pre></td></tr></table></figure></div>

<p>其中，flost为数据类型（int、char、double），S为数组名，60为数组下标，也就是数组的大小。</p>
<h3 id="2-2、使用数组及引用数组元素"><a href="#2-2、使用数组及引用数组元素" class="headerlink" title="2.2、使用数组及引用数组元素"></a>2.2、使用数组及引用数组元素</h3><p>基本格式：数组名[下标];</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S[<span class="number">0</span>]=<span class="number">1</span>; </span><br><span class="line">S[<span class="number">1</span>]=S[<span class="number">0</span>];</span><br><span class="line">S[<span class="number">10</span>]=S[<span class="number">0</span>]+S[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></div>

<p>注意：</p>
<p>（1）数组名的命名规则和变量名相同，要遵循标识符的命名规则。</p>
<p>（2）在定义数组时，需要指定数组中元素的个数，也就是数组的大小，在定义数组时[]方括号中必须是常量表达式，可以包括数值常量和符号常量。如：int a[6+8]; char b[‘a’];</p>
<p>（3）在C语言中数组下标是从0开始的，如：S[0]代表第一个数组元素。</p>
<p>思考一下数组的最后一个元素是多少？</p>
<p>（4）整个数组的内存大小为元素个数*单个元素类型所占字节数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(数组名);	<span class="comment">//求数组内存大小</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3、一维数组的初始化"><a href="#2-3、一维数组的初始化" class="headerlink" title="2.3、一维数组的初始化"></a>2.3、一维数组的初始化</h3><p>为了使程序简洁，常在定义数组的同时，给个数组元素赋值，这称为数组的初始化。</p>
<p>可以用“初始化列表”的方法实现数组的初始化。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<p>可以只给数组的部分元素赋初值。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<p>那未赋值的元素初始值是多少呢？ 没有赋初值的元素初始值默认为0</p>
<p>也可以不给数组的大小，利用数据初始化赋值决定数组大小。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//此时数组大小根据初始化时元素的多少来决定，这里的数组大小为7</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-4、一维数组的输入输出"><a href="#2-4、一维数组的输入输出" class="headerlink" title="2.4、一维数组的输入输出"></a>2.4、一维数组的输入输出</h3><p>可以使用循环输入&#x2F;输出每一个数组元素的值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(“%d”,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%d”,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="3、二维数组"><a href="#3、二维数组" class="headerlink" title="3、二维数组"></a>3、二维数组</h2><p>二维数组就是多个相同类型相同大小的一维数组的组合。</p>
<p>如果把一维数组看成一行数据的话，二维数组就像一个Excel表格一样，可以写成行和列的排列形式。</p>
<h3 id="3-1、二维数组的定义"><a href="#3-1、二维数组的定义" class="headerlink" title="3.1、二维数组的定义"></a>3.1、二维数组的定义</h3><p>基本格式：数据类型 数组名 数组行数 数组列数;</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure></div>

<p>此二维数组有3行4列，如下图所示：</p>
<p>二维数组的内存：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行数*列数*单个元素类型所占字节数</span><br></pre></td></tr></table></figure></div>



<h3 id="3-2、二维数组的初始化"><a href="#3-2、二维数组的初始化" class="headerlink" title="3.2、二维数组的初始化"></a>3.2、二维数组的初始化</h3><p>（1）给全部元素赋值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line"><span class="comment">//定义一个3行4列的二维数组，并给它的元素初始化赋值</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#125;;<span class="comment">//全部赋值为0</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//全部赋值为0</span></span><br></pre></td></tr></table></figure></div>

<p>（2）给每一行元素赋值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] =&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></div>

<p>（3）给部分元素赋值</p>
<p>可以不指定数组行大小，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//给数组前两个元素赋值，数组行数为1，此行最后一个元素默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//给数组前四个元素赋值，数组行数为2，第二行最后两个元素默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//给数组每行的前两个元素赋值，数组行数为2，每行最后一个元素默认为0</span></span><br></pre></td></tr></table></figure></div>

<p>虽然可以不给定数组行的大小，但是必须给定数组列的大小，也必须初始化赋值，因为数组行的大小是由初始化列表中数据的个数决定。</p>
<h3 id="3-3、二维数组元素的访问"><a href="#3-3、二维数组元素的访问" class="headerlink" title="3.3、二维数组元素的访问"></a>3.3、二维数组元素的访问</h3><p>二维数组与一维数组类似，通过数组名带下标的形式访问数组元素，由于是二维数组，所以需要带两个下标。</p>
<p>如有以下定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>];	<span class="comment">//访问数组第1行第1个元素</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>];	<span class="comment">//访问数组第2行第1个元素</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>];	<span class="comment">//访问数组第3行2个元素</span></span><br></pre></td></tr></table></figure></div>



<h3 id="3-4、二维数组的输入输出"><a href="#3-4、二维数组的输入输出" class="headerlink" title="3.4、二维数组的输入输出"></a>3.4、二维数组的输入输出</h3><p>可以使用双重循环输入&#x2F;输出每一个二维数组元素的值。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(“%d”,&amp;a[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(“%d”,a[i][j]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="4、字符数组"><a href="#4、字符数组" class="headerlink" title="4、字符数组"></a>4、字符数组</h2><p>字符数组简单的来说就是char类型的数组。</p>
<p>为什么要把字符数组分开讲呢？<br>字符数组是一类特殊的数组，由于C语言中没有字符串类型，所以字符串是存放在字符型数组中的。</p>
<h3 id="4-1、字符数组的定义及初始化"><a href="#4-1、字符数组的定义及初始化" class="headerlink" title="4.1、字符数组的定义及初始化"></a>4.1、字符数组的定义及初始化</h3><p>用来存放字符数据的数组就是字符数组。字符数组中的一个元素存放一个字符。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">6</span>]=&#123;‘a’,’b’,’c’,’d’,’e’,’f’&#125;; 	<span class="comment">//定义一个字符数组c，并以单个字符初始化赋值</span></span><br><span class="line"><span class="type">char</span> s[<span class="number">8</span>]=”abcdefg”;	<span class="comment">//定义一个字符数组c，并以字符串初始化赋值</span></span><br></pre></td></tr></table></figure></div>

<p>注意：以字符串的形式初始化赋值时，字符串的结尾有一个字符串结束标志’\0’，所以定义的数组大小至少要比字符串的长度大一个。</p>
<h3 id="4-2、引用字符数组中的元素"><a href="#4-2、引用字符数组中的元素" class="headerlink" title="4.2、引用字符数组中的元素"></a>4.2、引用字符数组中的元素</h3><p>通过数组名带下表的形式访问数组元素，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>]; <span class="comment">//定义一个字符数组</span></span><br><span class="line">s[<span class="number">0</span>]=’a’;	<span class="comment">//引用字符数组s的第一个元素s[0]并赋值</span></span><br><span class="line">s[<span class="number">1</span>]=’b’;	<span class="comment">//引用字符数组s的第二个元素s[1]并赋值</span></span><br></pre></td></tr></table></figure></div>



<h3 id="4-3、字符数组的输入和输出"><a href="#4-3、字符数组的输入和输出" class="headerlink" title="4.3、字符数组的输入和输出"></a>4.3、字符数组的输入和输出</h3><p>如有定义以下字符数组：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>

<p>方法一：以%c的格式循环输入&#x2F;输出字符数组中的每个数组元素的值</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(“%c”,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%c”,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>方法二：以%s的格式输入&#x2F;输出字符串</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(“%s”,a);</span><br><span class="line"><span class="built_in">printf</span>(“%s”,a);</span><br></pre></td></tr></table></figure></div>



<h3 id="4-4、二维字符数组"><a href="#4-4、二维字符数组" class="headerlink" title="4.4、二维字符数组"></a>4.4、二维字符数组</h3><p>二维字符数组与普通数组的定义方式一致。如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">3</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>

<p>二维字符数组的每一行都可以存储一个字符串。</p>
<p>如：二维字符数组的输入输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(“%s”,s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">	printf(“%s”,s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="4-5、字符串处理函数"><a href="#4-5、字符串处理函数" class="headerlink" title="4.5、字符串处理函数"></a>4.5、字符串处理函数</h3><p>常用的字符串处理函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(字符数组);</span><br><span class="line">	<span class="comment">//字符串的输出函数</span></span><br><span class="line"></span><br><span class="line">gets(字符数组);</span><br><span class="line">	<span class="comment">//字符串的输入函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strlen</span>(字符串);</span><br><span class="line">	<span class="comment">//测字符串长度函数，只计算有效字符，不包括’\0’</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcat</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//字符串连接函数,将字符串2连接到字符串1的末尾，并返回字符串1的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//字符串复制函数，将字符串2复制到字符串1中，并返回字符串1的起始地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcmp</span>(字符串<span class="number">1</span>,字符串<span class="number">2</span>);</span><br><span class="line">	<span class="comment">/*字符串比较函数</span></span><br><span class="line"><span class="comment">	比较字符串1和字符串2的大小，从两个字符串的第一个字符开始，按照各字母的ASCII码比较各个字符的大小，</span></span><br><span class="line"><span class="comment">	如果字符串1比字符串2大，则返回1，如果字符串1比字符串2小，则返回-1，如果相等则返回0</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strstr</span>(字符串<span class="number">1</span>,字符串<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//求子串函数，求字符串1（父串）中字符串2（子串）首次出现的位置（地址）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>使用字符串处理函数需要包含头文件：#include&lt;string.h&gt;</p>
<h1 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h1><h2 id="1、函数的基本概念"><a href="#1、函数的基本概念" class="headerlink" title="1、函数的基本概念"></a>1、函数的基本概念</h2><p>什么是函数？<br>所谓“函数”是从英文function翻译过来的，其意思既是“函数”，也是“功能”。从本质意义上来说明函数就是用来完成一定功能的，是把实现功能的代码封装起来，给这些封装起来的代码取个名字就是函数名，每一个函数用来实现一个特定的功能，函数的名字对应其代表的功能。</p>
<p>为什么要使用函数呢？<br>函数就是为了提高代码的复用性，提高程序的可读性，在使用过程中比较灵活，更加方便了程序代码的编写。</p>
<h2 id="2、函数的定义"><a href="#2、函数的定义" class="headerlink" title="2、函数的定义"></a>2、函数的定义</h2><p>C语言要求，在程序中用到的所有函数，必须“先定义，后使用”。</p>
<p>定义函数应包括以下几个内容：</p>
<p>（1）指定函数的名字，以便后续按名调用。<br>（2）指定函数的类型，即函数返回值的类型。<br>（3）指定函数参数的名字、数据类型和个数，以便在调用函数时向它们传递数据。（无参函数不需要这一项）<br>（4）指定函数所完成的功能，也就是规定函数要完成什么操作，说明函数是做什么的，这是最重要的一点，函数的功能都是写在函数体中的。</p>
<p>函数定义的一般格式如下：</p>
<h3 id="2-1、定义无参无返回值函数"><a href="#2-1、定义无参无返回值函数" class="headerlink" title="2.1、定义无参无返回值函数"></a>2.1、定义无参无返回值函数</h3><p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 函数名()	<span class="comment">//void为空类型</span></span><br><span class="line">&#123;</span><br><span class="line">	函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在函数体里描述函数实现的功能。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“--------------------------------------------------\n”);</span><br><span class="line">&#125;<span class="comment">//这里定义了一个函数，函数名为fun，无返回值，完成打印分隔线的功能。</span></span><br></pre></td></tr></table></figure></div>



<h3 id="2-2、定义有参数无返回值函数"><a href="#2-2、定义有参数无返回值函数" class="headerlink" title="2.2、定义有参数无返回值函数"></a>2.2、定义有参数无返回值函数</h3><p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 函数名(函数参数<span class="number">1</span>,函数参数<span class="number">2</span>,……)</span><br><span class="line">&#123;</span><br><span class="line">	函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如：求两个数据的和并输出</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> z;</span><br><span class="line">	z=x&gt;y?x:y;</span><br><span class="line">	<span class="built_in">printf</span>(“%d\n”,,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出两个数之间的最大值</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3、定义有参数有返回值函数"><a href="#2-3、定义有参数有返回值函数" class="headerlink" title="2.3、定义有参数有返回值函数"></a>2.3、定义有参数有返回值函数</h3><p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名(函数参数<span class="number">1</span>,函数参数<span class="number">2</span>,……)</span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> 值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> z;</span><br><span class="line">	z=x&gt;y?x:y;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最大值函数并返回</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-4、定义无参数有返回值函数"><a href="#2-4、定义无参数有返回值函数" class="headerlink" title="2.4、定义无参数有返回值函数"></a>2.4、定义无参数有返回值函数</h3><p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名()</span><br><span class="line">&#123;</span><br><span class="line">	函数体;</span><br><span class="line">	<span class="keyword">return</span> 值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SCANF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入一个整型数据：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="3、函数的调用"><a href="#3、函数的调用" class="headerlink" title="3、函数的调用"></a>3、函数的调用</h2><h3 id="3-1、函数调用语句"><a href="#3-1、函数调用语句" class="headerlink" title="3.1、函数调用语句"></a>3.1、函数调用语句</h3><p>函数调用的基本格式：函数名(实参列表);</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,c;</span><br><span class="line">c=max(a,b);	<span class="comment">//函数调用语句，调用max函数求a和b两个数中的最大值赋值给c</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、函数参数"><a href="#3-2、函数参数" class="headerlink" title="3.2、函数参数"></a>3.2、函数参数</h3><p>函数的参数分为实参和形参。</p>
<p>在调函数时，我们将调用其他函数的函数称为主调函数，将被调用的函数称为被调函数。在调用有参函数时，主调函数和被调函数之间有数据传递关系。主调函数中将值传递出去的参数称为“实际参数”（简称实参），被调函数中用于接收主调函数所传递过来值的参数称为“形式参数”或“虚拟参数”（简称形参）。</p>
<h3 id="3-3、实参和形参之间的数据传递"><a href="#3-3、实参和形参之间的数据传递" class="headerlink" title="3.3、实参和形参之间的数据传递"></a>3.3、实参和形参之间的数据传递</h3><p>在调用函数的过程中，系统会把实参的值传递给被调函数的形参，或者说形参从实参得到一个值。</p>
<p>函数调用过程中需要注意以下几点：</p>
<p>（1）实参可以是常量、变量或表达式。如：max(3,a+b);</p>
<p>（2）实参与形参的数据类型应相同或者赋值兼容，并且实参在实参列表中的位置与形参在形参列表中的位置必须对应。</p>
<p>（3）函数遇到return返回语句返回过后，不再继续执行return之后的语句了。</p>
<p>（4）形参在其所在函数的调用期间有效，可以参加此函数中的运算，但是不能用于其他函数中。</p>
<p>（5）函数的形参和实参是两个不同的变量，所以，一般情况下形参值的改变不影响实参的值，除非在函数参数的传递类型为引用传递（地址传递）。在未调用函数时，形参并不占用存储单元，开始函数调用时，才给形参开辟存储空间，函数调用结束后，形参的存储单元就会被释放。</p>
<h3 id="3-4、函数的返回值"><a href="#3-4、函数的返回值" class="headerlink" title="3.4、函数的返回值"></a>3.4、函数的返回值</h3><p>函数通过return语句带回返回值，应注意返回值类型应与函数类型一致，即函数类型决定返回值的类型。函数的返回值可以根据函数的功能拟定，并不固定。</p>
<h2 id="4、函数的声明"><a href="#4、函数的声明" class="headerlink" title="4、函数的声明"></a>4、函数的声明</h2><p>问：把某自定义函数的定义放在最后，主函数里能够调用此函数吗？<br>答：不能，函数需要先定义后使用，除非在调用函数之前有此函数的声明。</p>
<p>函数声明语句的一般格式：<br>    函数类型 函数名(参数类型1 参数名1,参数类型2 参数名2,……,参数类型n 参数名n);</p>
<p>函数声明其实就是将函数头部前置。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//max函数的声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;	<span class="comment">//函数头部</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    max(<span class="number">10</span>,<span class="number">20</span>);	<span class="comment">//函数调用在函数定义之前</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;	<span class="comment">//求最大值函数，返回两个数之间的最大值</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在一个函数中调用另一个函数（即被调函数）需要具备以下条件：</p>
<p>（1）首先被调用函数必须是已经定义好的函数（库函数或自定义的函数）。<br>（2）如果使用库函数，应该在本文件开头用#include指令将调用相关库函数时所需用到的信息“包含”到本文件中来。如：#include&lt;stdio.h&gt;。<br>（3）如果使用用户自定义的函数，在调用函数之前必须要有被调函数相关的声明语句，也就是函数需要先声明后使用。</p>
<h2 id="5、局部变量和全局变量"><a href="#5、局部变量和全局变量" class="headerlink" title="5、局部变量和全局变量"></a>5、局部变量和全局变量</h2><p>按照变量作用域的不同，我们将变量分为局部变量和全局变量。</p>
<h3 id="5-1、局部变量"><a href="#5-1、局部变量" class="headerlink" title="5.1、局部变量"></a>5.1、局部变量</h3><p>局部变量的作用范围只在一定范围内有效</p>
<p>局部变量的定义可能有以下几种情况：</p>
<p>（1）在函数开头定义；</p>
<p>（2）在函数内部的复合语句中定义；</p>
<h3 id="5-2、全局变量"><a href="#5-2、全局变量" class="headerlink" title="5.2、全局变量"></a>5.2、全局变量</h3><p>全局变量的作用范围相对于局部变量来说更为广泛，其在函数外部定义，也称为外部变量</p>
<h3 id="5-3、静态变量与动态变量"><a href="#5-3、静态变量与动态变量" class="headerlink" title="5.3、静态变量与动态变量"></a>5.3、静态变量与动态变量</h3><p>程序中所定义的变量默认是动态局部变量（auto）。</p>
<p>在定义变量前加一个static可定义一个静态变量。</p>
<p>静态变量在程序开始后定义，结束前才会被释放，所以其生命周期比较长，在函数调用中只会被定义一次，不会被定义多次，当再次执行到定义语句时，其值不会被重置（初始化），会保留上次改变的值。</p>
<h2 id="6、函数的嵌套调用"><a href="#6、函数的嵌套调用" class="headerlink" title="6、函数的嵌套调用"></a>6、函数的嵌套调用</h2><p>函数的定义时相互平行、独立的，在定义函数时，一个函数内不能再定义另一个函数，也就是说，函数不能嵌套定义。但是函数可以嵌套调用，也就是再调用一个函数的过程中，又调用另一个函数。</p>
<p>思考：怎么实现求三个数中的最大值的函数呢？</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(max(x,y),z);</span><br></pre></td></tr></table></figure></div>

<h2 id="7、函数的递归调用"><a href="#7、函数的递归调用" class="headerlink" title="7、函数的递归调用"></a>7、函数的递归调用</h2><p>在调用一个函数的过程中又出现直接或间接地调用此函数本身，称为函数的递归调用。</p>
<p>函数的递归调用演示示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归求1~n的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>&gt;=n)<span class="keyword">return</span> n; <span class="comment">//结束递归的条件</span></span><br><span class="line">	<span class="keyword">return</span> n+function(n<span class="number">-1</span>); <span class="comment">//这里在函数中调用此函数本身，实现递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：递归的函数中应有结束递归的条件，否则会和死循环一样，陷入无限递归，或者说死递归。</p>
<h2 id="8、数组作为函数参数传递"><a href="#8、数组作为函数参数传递" class="headerlink" title="8、数组作为函数参数传递"></a>8、数组作为函数参数传递</h2><p>数组名为数组的首地址，所以整个数组作为函数参数传递实际上是引用传递，传递的是地址，形参的改变会影响到实参。</p>
<p>如：字符串的输出</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PUTS</span><span class="params">(<span class="type">char</span> str[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> S[<span class="number">20</span>]=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">	PUTS(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里数组作为函数参数传递是数组的首地址，有涉及到指针的相关概念，之后讲到指针时再详细讲解。</p>
<p>注意：在函数中改变形参数组元素的值，那实参数组元素的值是否会被改变呢？</p>
<h1 id="七、预处理"><a href="#七、预处理" class="headerlink" title="七、预处理"></a>七、预处理</h1><p>预处理是在编译前所做的工作，编译器自动调用预处理程序对源码中以’#’开头的预处理部分进行处理，处理完毕后，进入源码的编译阶段。</p>
<h2 id="1、预定义符号"><a href="#1、预定义符号" class="headerlink" title="1、预定义符号:"></a>1、预定义符号:</h2><p> 常用的预定义符号：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_CRT_SECURE_NO_WARNINGS <span class="comment">//安全检查</span></span><br><span class="line"></span><br><span class="line">__FILE__	<span class="comment">//当前编译的文件名.  </span></span><br><span class="line">__FUNCTION__<span class="comment">//当前所在函数的函数名.</span></span><br><span class="line">__DATE__	<span class="comment">//当前编译日期.</span></span><br><span class="line">__TIME__	<span class="comment">//当前编译时间.</span></span><br><span class="line"><span class="comment">//注意标识符前后都有两个下划线&#x27;_&#x27;，以上格式占位符都用%s ，如：printf(&quot;%s&quot;,__FILE__);</span></span><br><span class="line"></span><br><span class="line">__LINE__	<span class="comment">//当前行数，格式占位符用%d，如：printf(&quot;%d&quot;,LINE);</span></span><br></pre></td></tr></table></figure></div>

<h2 id="2、宏定义"><a href="#2、宏定义" class="headerlink" title="2、宏定义"></a>2、宏定义</h2><p>宏定义，又称为宏替换，自定义一个宏(要符合标识符的命名规则)，用于替换任意数据、标识符或者表达式。</p>
<h3 id="2-1、无参宏定义"><a href="#2-1、无参宏定义" class="headerlink" title="2.1、无参宏定义"></a>2.1、无参宏定义</h3><p>基本格式：#define 宏名 宏替换</p>
<p>比如: </p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> A 35   		<span class="comment">//用A代表数据35</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT int   	<span class="comment">//用INT代替int</span></span></span><br><span class="line"></span><br><span class="line">INT a=A;	<span class="comment">//使用宏定义别名定义int类型的变量a，并初始化赋值为35</span></span><br></pre></td></tr></table></figure></div>

<p>不能给宏定义的常量赋值</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">66</span>; <span class="comment">// 错误，不能给宏定义常量赋值</span></span><br></pre></td></tr></table></figure></div>



<h3 id="2-2、带参宏定义"><a href="#2-2、带参宏定义" class="headerlink" title="2.2、带参宏定义"></a>2.2、带参宏定义</h3><p>基本格式：#define 宏名(参数表) 宏替换</p>
<p>带参宏可以像函数一样调用，比如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M(a,b) a+b-2</span></span><br><span class="line"></span><br><span class="line">K = M(<span class="number">1</span>,<span class="number">2</span>) * <span class="number">4</span>;</span><br><span class="line"><span class="comment">//K = 1+2-2*4 = 1+2-8 = -5</span></span><br></pre></td></tr></table></figure></div>

<p>注意：宏定义是替换，其在替换完成前并不会计算。</p>
<p>宏名尽量用大写，使其在程序中容易辨别区分</p>
<h3 id="2-3、常量的定义："><a href="#2-3、常量的定义：" class="headerlink" title="2.3、常量的定义："></a>2.3、常量的定义：</h3><p>除了宏定义以外，还可以通过const关键字定义常量:</p>
<p> 定义常量的基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;cosnt&gt; &lt;数据类型&gt; &lt;常量名&gt; = &lt;常量值&gt;;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">30</span>; <span class="comment">//定义一个常量a，其值等于30</span></span><br></pre></td></tr></table></figure></div>

<p>定义成常量后，值不可被改变。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">40</span>; <span class="comment">//错误，不能给常量赋值</span></span><br></pre></td></tr></table></figure></div>



<h2 id="3、文件包含"><a href="#3、文件包含" class="headerlink" title="3、文件包含"></a>3、文件包含</h2><h3 id="3-1、包含头文件"><a href="#3-1、包含头文件" class="headerlink" title="3.1、包含头文件"></a>3.1、包含头文件</h3><p>我们想要用库函数就需要包含头文件，也就是文件包含，当然也可以编写自定义头文件，包含自己编写的头文件。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">	<span class="comment">//包含系统头文件用&lt;&gt;，只会在系统头文件中找</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;name.h&quot;</span></span></span><br><span class="line">	<span class="comment">//包含自定义头文件用&quot;&quot;，在自定义头文件中找不到就会在系统头文件中找</span></span><br></pre></td></tr></table></figure></div>

<p> 文件包含允许嵌套，即在一个被包含文件中可以包含其它文件。</p>
<h3 id="3-2、头文件的重复包含"><a href="#3-2、头文件的重复包含" class="headerlink" title="3.2、头文件的重复包含"></a>3.2、头文件的重复包含</h3><p>头文件的嵌套包含可能会引起头文件的重复包含，从而出现函数和变量的重定义问题，所以需要避免头文件重复包含，某些宏定义语句可以防止头文件重复包含，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once 	<span class="comment">//不让文件被包含两次，在头文件最前面添加</span></span></span><br></pre></td></tr></table></figure></div>

<p>此预处理语句是vs独有的，有使用平台的限制，其他平台可能不存在。</p>
<h2 id="4、条件编译"><a href="#4、条件编译" class="headerlink" title="4、条件编译"></a>4、条件编译</h2><p>所谓的条件编译就是根据不同的条件编译不同的代码段。</p>
<h3 id="4-1、-if……-else的使用"><a href="#4-1、-if……-else的使用" class="headerlink" title="4.1、#if……#else的使用"></a>4.1、#if……#else的使用</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 表达式</span></span><br><span class="line"><span class="comment">//判断表达式的逻辑值(真或假),若逻辑值为真,则编译代码段1,否则编译代码段2</span></span><br><span class="line">	代码段<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	代码段<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-2、-ifdef……-endif的使用"><a href="#4-2、-ifdef……-endif的使用" class="headerlink" title="4.2、#ifdef……#endif的使用"></a>4.2、#ifdef……#endif的使用</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line"><span class="comment">//如果定义了宏&quot;宏名&quot;,则编译代码段</span></span><br><span class="line">	代码段;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line"><span class="comment">//如果定义了宏&quot;宏名&quot;,则编译代码段1,否则编译代码段2;</span></span><br><span class="line">	代码段<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	代码段<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-3、-ifndef……-endif的使用"><a href="#4-3、-ifndef……-endif的使用" class="headerlink" title="4.3、#ifndef……#endif的使用"></a>4.3、#ifndef……#endif的使用</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 宏名</span></span><br><span class="line">    <span class="comment">//如果没有定义宏&quot;宏名&quot;,则编译代码段</span></span><br><span class="line">代码段;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 宏名</span></span><br><span class="line"><span class="comment">//如果没有定义宏&quot;宏名&quot;,则编译代码段1,否则编译代码段2;</span></span><br><span class="line">	代码段<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	代码段<span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>



<h1 id="八、构造数据类型"><a href="#八、构造数据类型" class="headerlink" title="八、构造数据类型"></a>八、构造数据类型</h1><h2 id="1、结构体"><a href="#1、结构体" class="headerlink" title="1、结构体"></a>1、结构体</h2><p>构造数据类型：用户自己建立的数据类型（自定义数据类型）。</p>
<p>C语言中的构造数据类型有：数组类型、结构体类型和共用体类型。</p>
<h3 id="1-1、什么是结构体？"><a href="#1-1、什么是结构体？" class="headerlink" title="1.1、什么是结构体？"></a>1.1、什么是结构体？</h3><p>C语言允许用户根据需要自己建立的由不同类型数据组成的组合型的数据类型，我们把它称之为结构体（struct）。</p>
<h3 id="1-2、为什么要用结构体？"><a href="#1-2、为什么要用结构体？" class="headerlink" title="1.2、为什么要用结构体？"></a>1.2、为什么要用结构体？</h3><p>在日常生活中有许多事物用单一的数据类型可能没办法完全表示出来，例如：学校要存储学生的学号、姓名、性别、年龄、成绩和家庭地址等信息，这些信息需要用不同的数据类型来存储，显然用我们一个普通的单一的数据类型是无法全部存储起来的，就比如说数组，我们常用它来存储一串连续的信息，但是它的数据类型单一，显然无法把学生的这些信息全部保存。</p>
<p>所以，结构体这种数据类型就诞生了，它能根据用户需要来更方便的存储各种各样的信息。</p>
<h3 id="1-3、结构体类型的声明和结构体变量的定义"><a href="#1-3、结构体类型的声明和结构体变量的定义" class="headerlink" title="1.3、结构体类型的声明和结构体变量的定义"></a>1.3、结构体类型的声明和结构体变量的定义</h3><p>（1）声明一个结构体类型的一般形式为：</p>
<p>​	struct 结构体类型名{成员列表}；</p>
<p>（2）定义一个结构体类型的变量：</p>
<p>可以在声明的时候直接定义结构体变量,也可以先声明后定义结构体变量。</p>
<p>例如：学生类结构体</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> id;				<span class="comment">//学生学号</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];		<span class="comment">//学生姓名</span></span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];		<span class="comment">//学生性别</span></span><br><span class="line">	<span class="type">int</span> age;			<span class="comment">//学生年龄</span></span><br><span class="line">	<span class="type">int</span> score;			<span class="comment">//学生成绩</span></span><br><span class="line">	<span class="type">char</span> address[<span class="number">20</span>];	<span class="comment">//学生家庭住址</span></span><br><span class="line">&#125;S1,S2,S3;	<span class="comment">//声明时定义结构体变量S1,S2,S3</span></span><br></pre></td></tr></table></figure></div>

<p>这里定义了一个结构体，其中struct为结构体关键字，srtuct student为结构体类型名，id、name、sex、age、score、address为结构体成员名，S1、S2、S3为结构体变量名。</p>
<p>注意：一定要区分清楚什么是结构体类型名、结构体成员名和结构体变量名。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">S4</span>,<span class="title">S5</span>;</span><span class="comment">//声明之后使用结构体类型名定义的结构体变量S4,S5</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（3）不指定结构体类型名而直接定义结构体类型的变量</p>
<p>其一般形式为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> //这里缺省了结构体类型名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	成员列表;</span><br><span class="line">&#125;变量名列表;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">srtuct	<span class="comment">//这里没有给定结构体类型名</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">	<span class="type">char</span> address[<span class="number">20</span>]; </span><br><span class="line">&#125;t1,t2,t3;	<span class="comment">//由于没有给定类型名，所以变量只能声明时定义</span></span><br></pre></td></tr></table></figure></div>

<p>注意：以此方式定义结构体，由于没有结构体类型名，只能在声明时定义此结构体的变量，而不能再以此结构体类型名去定义其他变量了。（这种方式用得不多）</p>
<h3 id="1-4、结构体变量的初始化和引用"><a href="#1-4、结构体变量的初始化和引用" class="headerlink" title="1.4、结构体变量的初始化和引用"></a>1.4、结构体变量的初始化和引用</h3><p>（1）结构体变量的初始化：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">srtuct student&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;s1=&#123;<span class="number">666</span>,<span class="string">&quot;小李&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="number">30</span>,<span class="number">100</span>&#125;,t2,t3;</span><br><span class="line"><span class="comment">//这里给srtuct student类型的结构体变量s1赋初值（初始化赋值）</span></span><br><span class="line"><span class="comment">//在定义结构体变量的同时给变量赋初值，应按次序给每一个成员或部分成员赋值</span></span><br></pre></td></tr></table></figure></div>

<p>（2）结构体变量和成员的引用</p>
<p>相同结构体类型的结构体能够相互赋值：<br>    如有定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span>,<span class="title">s2</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>​	就可以有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1=s2;</span><br></pre></td></tr></table></figure></div>

<p>不同结构体类型的结构体不能相互赋值：<br>    如有定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> <span class="title">t</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>​	则不能有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=t;</span><br></pre></td></tr></table></figure></div>

<p>​	也不能有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student = teacher;</span><br></pre></td></tr></table></figure></div>

<p>结构体成员引用符：’.’</p>
<p>结构体成员引用的一般格式：结构体变量名.成员名</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.id=<span class="number">1</span>;	s2.name;	s3.score;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-5、使用typedef关键字自定义类型名"><a href="#1-5、使用typedef关键字自定义类型名" class="headerlink" title="1.5、使用typedef关键字自定义类型名"></a>1.5、使用typedef关键字自定义类型名</h3><p>typedef：简单来说就是用一个新的标识符名代替原有的类型名。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;	<span class="comment">//这里用INT代替int,之后定义整型变量就可以用INT了 </span></span><br></pre></td></tr></table></figure></div>

<p>typedef的使用方法与#define INT int 类似，相当于给数据类型关键字取别名。</p>
<p>但是需要注意的是：typedef只能用于给数据类型关键字取别名，除此之外没有其他用途。</p>
<p>使用typedef取的别名也需要遵循标识符的命名规则</p>
<p>可以给一个数据类型取多个别名(没有意义)</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT,I,inter;</span><br></pre></td></tr></table></figure></div>

<p>或者：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> I;</span><br></pre></td></tr></table></figure></div>

<p>typedef一般使用在数据类型名比较长的情况下，</p>
<p>如：声明结构体</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> id;	<span class="comment">//学生学号</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];	<span class="comment">//学生姓名</span></span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];	<span class="comment">//学生性别</span></span><br><span class="line">	<span class="type">int</span> age;	<span class="comment">//学生年龄</span></span><br><span class="line">	<span class="type">int</span> score;	<span class="comment">//学生成绩</span></span><br><span class="line">	<span class="type">char</span> address[<span class="number">20</span>];	<span class="comment">//学生家庭住址</span></span><br><span class="line">&#125;S; <span class="comment">//这里的S是代表struct student这个数据类型的别名，而不是结构体的变量名了</span></span><br></pre></td></tr></table></figure></div>

<p>我们可以用struct student定义此结构体类型的变量，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span>,<span class="title">s2</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>也可以用struct student的别名S等于此结构体类型的变量，如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S s3,s4;</span><br></pre></td></tr></table></figure></div>

<p>思考一下：结构体变量所占的内存大小怎么计算？</p>
<p>​	一般来说结构体类型所占内存大小是所有成员大小之和，但是存在内存补齐。</p>
<h3 id="1-6、结构体的嵌套定义"><a href="#1-6、结构体的嵌套定义" class="headerlink" title="1.6、结构体的嵌套定义"></a>1.6、结构体的嵌套定义</h3><p>用一个结构体类型作为另一个结构体类型的成员。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test1</span></span></span><br><span class="line"><span class="class">	&#123;</span>	<span class="comment">//结构体的嵌套定义：一个结构体类型中定义了另一个结构体类型</span></span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">	&#125;z;</span><br><span class="line">&#125;n;</span><br></pre></td></tr></table></figure></div>

<p>通过结构体变量n引用成员变量x：**n.z.x&#x3D;10;	&#x2F;&#x2F;给成员变量x赋值为10</p>
<h3 id="1-7、结构体数组"><a href="#1-7、结构体数组" class="headerlink" title="1.7、结构体数组"></a>1.7、结构体数组</h3><p>（1）结构体数组的定义</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">S</span>[3];</span></span><br></pre></td></tr></table></figure></div>

<p>这是一个struct student类型的结构体数组，此数组中有三个struct student结构体类型的元素，分别为S[0],S[1],S[2]。</p>
<p>（2）结构体数组元素的使用</p>
<p>使用结构体数组元素成员的一般格式：结构体数组名[数组下标].成员变量名;</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S[<span class="number">0</span>].id=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//这里引用了struct student类型的结构体数组S的第1个元素S[0]的成员id，使其值等于1</span></span><br><span class="line"><span class="built_in">printf</span>(“%s\n”,S[<span class="number">2</span>].name);</span><br><span class="line"><span class="comment">//这里是输出struct student类型的结构体数组S的第3个元素S[2]的成员name的值</span></span><br></pre></td></tr></table></figure></div>

<p>如有以下定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span>[3],<span class="title">s2</span>[3];</span></span><br></pre></td></tr></table></figure></div>

<p>那么可以有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1[<span class="number">0</span>]=s2[<span class="number">1</span>];	<span class="comment">//相同类型的结构体数组元素赋值</span></span><br></pre></td></tr></table></figure></div>

<p>不能有：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1=s2;	<span class="comment">//错误，结构体数组之间不能相互赋值</span></span><br></pre></td></tr></table></figure></div>

<p>思考一下：结构体数组所占的内存大小怎么计算？</p>
<h2 id="2、共用体"><a href="#2、共用体" class="headerlink" title="2、共用体"></a>2、共用体</h2><h3 id="2-1、什么是共用体？"><a href="#2-1、什么是共用体？" class="headerlink" title="2.1、什么是共用体？"></a>2.1、什么是共用体？</h3><p>共用体关键字：union</p>
<p>有时候想用同一段内存单元存放不同类型的变量。如：把一个整型变量、浮点型变量和字符型变量放在同一个内存单元中，它们在内存中所占字节数不同，但是共用同一段内存地址，也就是共用体了。</p>
<h3 id="2-2、共用体类型的声明和共用体变量的定义"><a href="#2-2、共用体类型的声明和共用体变量的定义" class="headerlink" title="2.2、共用体类型的声明和共用体变量的定义"></a>2.2、共用体类型的声明和共用体变量的定义</h3><p>共用体类型声明和定义的一般格式为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	成员列表;</span><br><span class="line">&#125;变量列表;</span><br></pre></td></tr></table></figure></div>

<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line">&#125;d1=&#123;<span class="number">1</span>&#125;,d2,d3;	<span class="comment">//可以对共用体变量进行初始化，但是初始化列表中只能有一个常量。</span></span><br><span class="line">d1.a=<span class="number">10</span>;</span><br><span class="line">d1.b=<span class="number">6.6</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(d1.c,”abcdefg”);	<span class="comment">//这里分别给共用体成员赋值</span></span><br></pre></td></tr></table></figure></div>

<p>#注意：由于共用体中的每个成员共用一段内存空间，所以共用体在同一时刻只能保存一个成员的值，也就是保存最后一个赋值的成员的值。</p>
<h3 id="2-3、共用体类型所占内存"><a href="#2-3、共用体类型所占内存" class="headerlink" title="2.3、共用体类型所占内存"></a>2.3、共用体类型所占内存</h3><p>由于共用体类型中所有成员是共用一段内存的，所以整个共用体类型所占内存是最大成员所占的内存空间（也存在内存补齐）。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line">&#125;d1,d2,d3;</span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,<span class="keyword">sizeof</span>(d1));	<span class="comment">//这里输出共用体的内存大小为16（两个double的大小）</span></span><br></pre></td></tr></table></figure></div>



<h2 id="3、枚举类型"><a href="#3、枚举类型" class="headerlink" title="3、枚举类型"></a>3、枚举类型</h2><h3 id="3-1、枚举类型的概念"><a href="#3-1、枚举类型的概念" class="headerlink" title="3.1、枚举类型的概念"></a>3.1、枚举类型的概念</h3><p>如果一个变量只有几种可能的取值，就可以定义为枚举类型，所谓的“枚举”就是指吧可能的值一一列举出来，枚举变量的取值范围只限于列举出来的值的范围内，也就是只能在值的集合内选择。</p>
<p>枚举类型本质上是作为int类型数据做运算的，也可以将枚举类型看成取值范围受限的整型。</p>
<h3 id="3-2、枚举类型的声明"><a href="#3-2、枚举类型的声明" class="headerlink" title="3.2、枚举类型的声明"></a>3.2、枚举类型的声明</h3><p>枚举类型关键字：enum</p>
<p>枚举类型定义的基本格式：enum 类型名{枚举元素列表};</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span>&#123;</span>sun,mon,tue,wed,thu,fri,sat&#125;;</span><br><span class="line"><span class="comment">//以上声明了一个枚举类型的变量Weekday，用于表示星期，其变量的取值范围为星期天至星期六</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-3、枚举变量的定义"><a href="#3-3、枚举变量的定义" class="headerlink" title="3.3、枚举变量的定义"></a>3.3、枚举变量的定义</h3><p>根据以上声明我们可以定义此枚举类型的变量。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> <span class="title">workday</span>,<span class="title">weekend</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>其中workday和weekend是此枚举类型的变量，其每个变量的取值范围为集合{sun,mon,tue,wed,thu,fri,sat}中的一个值。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">workday=mon;</span><br><span class="line">weekend=sun; </span><br><span class="line"></span><br><span class="line">workday=abc;	<span class="comment">//错误，不存在枚举值abc</span></span><br></pre></td></tr></table></figure></div>

<p>可以在声明时同时定义变量。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span>&#123;</span>sun,mon,tue,wed,thu,fri,sat&#125;workday,weekend;</span><br></pre></td></tr></table></figure></div>

<p>声明的枚举类型也可以没有类型名，但如果需要使用此枚举类型的话，就必须在声明时同时定义变量。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>sun,mon,tue,wed,thu,fri,sat&#125;workday,weekend;</span><br></pre></td></tr></table></figure></div>

<p>说明：</p>
<p>（1）在C语言中枚举类型的枚举元素是按照常量进行处理的，所以又称为枚举常量。不要因为它们是标识符而把它们当作变量来使用，在使用时是不能对它们赋值的。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun=<span class="number">0</span>;	mon=<span class="number">1</span>;	sun = <span class="number">7</span>; <span class="comment">//错误，不能给枚举常量赋值</span></span><br></pre></td></tr></table></figure></div>

<p>（2）每一个枚举元素都代表一个整数，C语言编译器按照定义时的顺序默认它们的值为0，1，2，3，4，5，6……。在上面的声明中，sun的值为0，mon的值为1，tue的值为2，依次类推。</p>
<p>如果有赋值语句：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workday=mon;</span><br></pre></td></tr></table></figure></div>

<p>就相当于：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workday=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>枚举常量的引用和输出：</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“%d”,sun);<span class="comment">//输出整数0</span></span><br></pre></td></tr></table></figure></div>

<p>枚举变量的引用和输出：</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workday=mon;</span><br><span class="line"><span class="built_in">printf</span>(“%d”,workday);<span class="comment">//输出整数1</span></span><br></pre></td></tr></table></figure></div>

<p>（3）我们也可以人为的指定枚举元素的数值，在声明的枚举类型的时候显式指定。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span>&#123;</span>sun=<span class="number">7</span>,mon=<span class="number">1</span>,tue,wed,thu,fri,sat&#125;workday,weekend;</span><br></pre></td></tr></table></figure></div>

<p>指定枚举常量sun的值为7，mon的值为1，之后的值顺序加1，也就是tue的值为2，sat的值为6。</p>
<p>由于枚举类型的值为整数，因此C99把枚举类型也作为整型数据的一种，即用户自己定义的整数类型。</p>
<p>（4）枚举类型可以用来比较和判断。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(workday==mon)&#123;……&#125;</span><br><span class="line"><span class="keyword">if</span>(workday&lt;=sat)&#123;……&#125;</span><br></pre></td></tr></table></figure></div>

<p>枚举类型的比较规则是按照其初始化时指定的整数大小来进行比较的。如果声明时没有人为指定，就按默认规则处理，即第一个枚举元素的值为0，第二个枚举元素的值为1，依次类推，所以mon&gt;sun,sat&gt;fri。</p>
<h3 id="3-4、枚举类型应用举例"><a href="#3-4、枚举类型应用举例" class="headerlink" title="3.4、枚举类型应用举例"></a>3.4、枚举类型应用举例</h3><p>猜拳游戏：玩家输入1、2、3进行猜拳。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">InputType</span>&#123;</span> 石头, 剪刀, 布 &#125;;	<span class="comment">//猜拳枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FingerGuessing</span><span class="params">()</span>	<span class="comment">//猜拳游戏</span></span><br><span class="line">&#123;</span><br><span class="line">	InputType computer, player;		<span class="comment">//电脑和玩家</span></span><br><span class="line">	srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));	<span class="comment">//随机种子</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		computer = (InputType)(rand() % <span class="number">3</span>);	<span class="comment">//电脑随机猜拳</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n猜拳游戏\n0、石头\n1、剪刀\n2、布\n请猜拳：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;player);</span><br><span class="line">		<span class="keyword">switch</span> (player)	<span class="comment">//比较玩家猜的拳</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> 石头:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;玩家：石头\n&quot;</span>);</span><br><span class="line">			<span class="keyword">switch</span> (computer)	<span class="comment">//比较电脑猜的拳</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> 石头:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：石头\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;平局！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 剪刀:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：剪刀\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家赢了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 布:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：布\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家输了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> 剪刀:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;玩家：剪刀\n&quot;</span>);</span><br><span class="line">			<span class="keyword">switch</span> (computer)	<span class="comment">//比较电脑猜的拳</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> 石头:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：石头\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家输了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 剪刀:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：剪刀\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;平局！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 布:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：布\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家赢了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> 布:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;玩家：布\n&quot;</span>);</span><br><span class="line">			<span class="keyword">switch</span> (computer)	<span class="comment">//比较电脑猜的拳</span></span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> 石头:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：石头\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家赢了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 剪刀:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：剪刀\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;玩家输了！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> 布:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;电脑：布\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;平局！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FingerGuessing();</span><br><span class="line">    </span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="九、C语言文件操作"><a href="#九、C语言文件操作" class="headerlink" title="九、C语言文件操作"></a>九、C语言文件操作</h1><h2 id="1、什么是文件？"><a href="#1、什么是文件？" class="headerlink" title="1、什么是文件？"></a>1、什么是文件？</h2><p>文件有不同的类型，在程序设计中，主要用到两种文件：</p>
<p>（1）程序文件。包括源程序文件（后缀名为.c）、目标文件（后缀名为.obj）、可执行文件（后缀名为.exe）等。这一类型的文件主要用于存储程序代码。</p>
<p>（2）数据文件。此文件的内容不是程序，而是程序运行时读写的数据，比如程序运行过程中输出到磁盘或其他设备上的数据，或在程序运行过程中供程序读取的数据。</p>
<p>这里C语言的文件操作主要是对数据文件的操作。</p>
<p>在之前程序中所处理的数据的输入和输出都是以终端为对象的，都是从键盘输入数据，然后运行结果输出到终端显示器上。实际上，我们有时候需要将一些数据（程序运行的最终结果或者中间数据）保存起来，方便以后需要时再调用，而这就需要用到磁盘文件了。</p>
<h3 id="1-1、文件的概念"><a href="#1-1、文件的概念" class="headerlink" title="1.1、文件的概念"></a>1.1、文件的概念</h3><p>每一个文件都需要一个唯一的文件标识，以便用户使用，就像我们的变量名一样，同一程序中不能有相同的变量名。</p>
<p>文件标识也称为文件名，它由3部分组成：</p>
<p>①文件路径：表示文件在外存设备中的存储位置；</p>
<p>②文件名主干：表示文件的名字，可由用户自定义，命名规则应遵循标识符的命名规则。</p>
<p>③文件后缀：表示文件的性质，也称为文件的格式，用于描述文件的类型（如txt、ppt等）。</p>
<p>文件路径能唯一标识文件在外存中的位置。</p>
<p>如：D:\C++\VSproject\TEXT\text.c</p>
<h3 id="1-2、文件的分类"><a href="#1-2、文件的分类" class="headerlink" title="1.2、文件的分类"></a>1.2、文件的分类</h3><p>根据数据的组织形式，数据文件可分为ASCII文件和二进制文件。</p>
<p>数据在内存中是以二进制形式存储的，如果不加转换的输出到外存，就是二进制文件，可以认为它是存储在内存的数据的映像，所以称之为映像文件。如果要求在外存上以ASCII码形式存储，就需要在存储前进行转换。ASCII文件又称为文本文件，每一个字节存放一个字符的ACSII码。</p>
<h3 id="1-3、文件存储方法的区别"><a href="#1-3、文件存储方法的区别" class="headerlink" title="1.3、文件存储方法的区别"></a>1.3、文件存储方法的区别</h3><p>一个数据在磁盘上存储，字符一律以ASCII形式存储，数值型既可以用ASCII形式存储也可以用二进制形式存储。如整数10000，用ASCII码形式存储在磁盘上占5个字节（每个字符占一个字节），而用二进制形式存储在磁盘上只占4个字节（00000000 00000000 00100111 00010000‬）。用ASCII形式存储时字符与字节一一对应，一个字节代表一个字符，便于逐个处理，但占的存储空间较多，而且处理的时候要花费转换时间（二进制与ASCII码之间的转换）。二进制形式存储就相当于直接把内存中的内容原封不动存储在磁盘上，由于不需要转换，所以二进制文件更加方便计算机处理。</p>
<h2 id="2、指向文件的指针"><a href="#2、指向文件的指针" class="headerlink" title="2、指向文件的指针"></a>2、指向文件的指针</h2><p>C语言要想操作内存，需要用到各种数据类型的指针，而文件也是需要调用到内存中才能够使用，所以就需要用到“指向文件的指针”，就是“文件类型的指针”，简称“文件指针”。</p>
<p>每一个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的相关信息（如文件的名字、文件的状态和文件的位置等）。这些信息是保存在一个结构体变量中的，此结构体类型是由系统声明的，取名为FILE，其被包含在stdio.h头文件中。</p>
<h3 id="2-1、文件指针的定义"><a href="#2-1、文件指针的定义" class="headerlink" title="2.1、文件指针的定义"></a>2.1、文件指针的定义</h3><p>由于文件类型已经在stdio.h头文件中有声明了，所以我们不需要另外声明，直接使用就行了。</p>
<p>文件指针的定义格式为：FILE *指针类型名;</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br></pre></td></tr></table></figure></div>

<p>定义一个指针fp用于指向FILE类型的数据，可以使fp指向某一个文件在内存中的文件信息区（结构体变量），通过此文件信息区能够访问此文件。也就是说通过文件指针变量能够找到并可以操作其指向的文件。</p>
<h3 id="2-2、打开与关闭文件"><a href="#2-2、打开与关闭文件" class="headerlink" title="2.2、打开与关闭文件"></a>2.2、打开与关闭文件</h3><p>（1）用fopen函数打开文件</p>
<p>​	C语言规定用文件标准输入输出函数fopen来实现打开文件。</p>
<p>fopen函数的调用方式为：</p>
<p>​	fopen(文件名,使用文件的方式);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fopen(<span class="string">&quot;text1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>):</span><br><span class="line">	<span class="comment">//以只读的方式打开名为“text1.txt”文件。</span></span><br></pre></td></tr></table></figure></div>

<p>此时fopen函数返回的是“text1.txt”文件的起始地址，我们通常将fopen函数的返回值赋值给一个文件指针，用文件指针指向此文件的地址。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;<span class="comment">//定义一个文件指针fp</span></span><br><span class="line">fp=fopen(<span class="string">&quot;text1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//使fp指向文件“text1.txt”的首地址</span></span><br></pre></td></tr></table></figure></div>

<p>这样fp就与文件“text1.txt”有联系了。在打开一个文件时，给定编译系统以下3个信息：</p>
<p>①需要打开的文件名称；②文件的打开方式；③使用哪个文件指针指向被打开的文件。</p>
<p>（2）文件的打开方式</p>
<p>文件打开方式与含义如下表所示：</p>
<table>
<thead>
<tr>
<th>文件的打开方式</th>
<th>含义</th>
<th>如果指定的文件不存在</th>
</tr>
</thead>
<tbody><tr>
<td>“r”（只读）</td>
<td>为了输入数据，打开一个已存在的文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“w”（只写）</td>
<td>为了输出数据，打开一个文本文件</td>
<td>新建文件</td>
</tr>
<tr>
<td>“a”（追加）</td>
<td>向文本文件尾部添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>“rb”（只读）</td>
<td>为了输入数据，打开一个已存在的二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>“wb”（只写）</td>
<td>为了输出数据，打开一个二进制文件</td>
<td>新建文件</td>
</tr>
<tr>
<td>“ab”（追加）</td>
<td>向二进制文件尾部添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>“r+”（读写）</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“w+”（读写）</td>
<td>为了读和写，打开一个文本文件</td>
<td>新建文件</td>
</tr>
<tr>
<td>“a+”（读写）</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“rb+”（读写）</td>
<td>为了读和写，打开一个二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>“wb+”（读写）</td>
<td>为了读和写，打开一个二进制文件</td>
<td>新建文件</td>
</tr>
<tr>
<td>“ab+”（读写）</td>
<td>为了读和写，打开一个二进制文件</td>
<td>出错</td>
</tr>
</tbody></table>
<p>（3）用fclose函数关闭文件</p>
<p>在使用完一个文件之后，为了防止它被误用，应该关闭它。“关闭”就是撤销文件信息区和文件缓冲区，使指针不再指向此文件了，也无法操作此文件了，除非重新打开此文件，使指针指向此文件。</p>
<p>关闭文件用fclose函数。</p>
<p>fclose函数的基本格式为：</p>
<p>​	fclose(文件指针);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure></div>

<p>在每次程序终止之前都要养成习惯关闭所有的文件，当fclose函数成功关闭文件时，返回0；否则返回EOF（-1）。</p>
<h2 id="3、顺序读写文件"><a href="#3、顺序读写文件" class="headerlink" title="3、顺序读写文件"></a>3、顺序读写文件</h2><p>文件打开完成之后就可以对它进行读写操作了。</p>
<p>常用的文件操作函数如下所示：</p>
<h3 id="3-1、字符输入和输出函数"><a href="#3-1、字符输入和输出函数" class="headerlink" title="3.1、字符输入和输出函数"></a>3.1、字符输入和输出函数</h3><p>（1）字符读取函数<br>使用字符读取函数fgetc从文件读取一个字符</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch=fgetc(fp);</span><br></pre></td></tr></table></figure></div>

<p>从文件指针fp指向的位置读取一个字符存入字符变量ch中，</p>
<p>读取成功返回所读的字符，失败则返回为你文件结束标志EOF（-1）。</p>
<p>（2）字符写入函数<br>使用字符写入函数fputc向文件写入一个字符。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fputc(ch,fp);</span><br></pre></td></tr></table></figure></div>

<p>向文件指针fp指向的位置写入字符ch，写入成功返回输出的字符，失败则返回EOF（-1）</p>
<h3 id="3-2、字符串输入和输出函数"><a href="#3-2、字符串输入和输出函数" class="headerlink" title="3.2、字符串输入和输出函数"></a>3.2、字符串输入和输出函数</h3><p>（1）字符串读取函数<br>使用字符串读取函数fgets从文件读取一个字符串。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgets(str,n,fp);</span><br></pre></td></tr></table></figure></div>

<p>从文件指针fp指向的位置读取一个长度位n-1的字符串（最后一位赋值‘\0’，用作字符串结束标志），存放在字符数组str中。</p>
<p>读取成功返回地址str，失败则返回NULL。</p>
<p>（2）字符串写入函数<br>使用字符串写入函数fputs向文件写入一个字符串。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(str，fp);</span><br></pre></td></tr></table></figure></div>

<p>把str所指向的字符串写入文件指针fp指向的位置，写入成功返回0，否则返回非0值。</p>
<h3 id="3-3、文件格式化输入和输出函数"><a href="#3-3、文件格式化输入和输出函数" class="headerlink" title="3.3、文件格式化输入和输出函数"></a>3.3、文件格式化输入和输出函数</h3><p>（1）格式化输出函数<br>使用格式化输出函数fprintf向文件写入数据：</p>
<p>​	fprintf(文件指针,”格式化字符串”,输出列表);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d,%c&quot;</span>,x,y);</span><br></pre></td></tr></table></figure></div>

<p>将变量x以整型的形式写入文件指针fp指向的位置，把变量y以字符的形式写入文件指针fp指向的位置。</p>
<p>（2）格式化输入函数<br>使用格式化输入函数fscanf从文件读取数据：</p>
<p>​	fscanf(文件指针,”格式化字符串”,输入列表);</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d,%f&quot;</span>,&amp;x,&amp;y);</span><br></pre></td></tr></table></figure></div>

<p>从文件指针fp指向的位置读入一个整型数据和一个单精度型数据，分别存入变量x和变量y中。</p>
<h3 id="3-4、以二进制的形式读写数据"><a href="#3-4、以二进制的形式读写数据" class="headerlink" title="3.4、以二进制的形式读写数据"></a>3.4、以二进制的形式读写数据</h3><p>（1）二进制读取函数</p>
<p>使用fread函数以二进制的形式从文件读出数据：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread(arr,size,count,fp);</span><br></pre></td></tr></table></figure></div>

<p>把数组arr中size个count大小的数据放入文件指针fp所指向的文件中。</p>
<p>arr是一个地址（数组），用于存储从文件读取出来的数据，size为需要读取的字节数，count为需要读取数据项的个数（每个数据项的大小为size）。</p>
<p>（2）二进制写入函数</p>
<p>使用fwrite函数以二进制的形式向文件写入数据：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fwrite(arr,size,count,fp);</span><br></pre></td></tr></table></figure></div>

<p>从文件指针fp所指向的文件中读取size个count大小的数据放入数组arr中。</p>
<h2 id="4、随机读写文件"><a href="#4、随机读写文件" class="headerlink" title="4、随机读写文件"></a>4、随机读写文件</h2><p>可以通过改变文件指针的位置标记及定位来实现文件的随机读写。</p>
<h3 id="4-1、强制使文件指针指向文件开头"><a href="#4-1、强制使文件指针指向文件开头" class="headerlink" title="4.1、强制使文件指针指向文件开头"></a>4.1、强制使文件指针指向文件开头</h3><p>使用rewind函数强制使文件指针fp指向文件开头的位置。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewind(fp);</span><br></pre></td></tr></table></figure></div>

<h3 id="4-2、使文件指针指向文件中的任意位置"><a href="#4-2、使文件指针指向文件中的任意位置" class="headerlink" title="4.2、使文件指针指向文件中的任意位置"></a>4.2、使文件指针指向文件中的任意位置</h3><p>使用fseek函数使文件指针指向文件中任意位置。</p>
<p>基本格式：<br>    fseek(fp,位移量,起始点);</p>
<p>起始点用0、1、2代替，0代表文件开始位置，1代表当前位置，2代表文件末尾位置。<br>位移量是指以起始点为基础，向前移动的字节数，其为long类型的参数。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">100</span>,<span class="number">0</span>);	<span class="comment">//将文件指针fp向后移动到离文件开头100个字节处</span></span><br><span class="line">fseek(fp,<span class="number">50</span>,<span class="number">1</span>);	<span class="comment">//将文件指针fp向后移动到离当前位置50个字节处</span></span><br><span class="line">fseek(fp,<span class="number">-10</span>,<span class="number">2</span>);	<span class="comment">//将文件指针fp向前移动到离文件末尾10个字节处</span></span><br></pre></td></tr></table></figure></div>

<p>fseek一般用于二进制文件。</p>
<p>用rewind和fseek函数实现随机读写。</p>
<h2 id="5、文件的出错检测"><a href="#5、文件的出错检测" class="headerlink" title="5、文件的出错检测"></a>5、文件的出错检测</h2><h3 id="5-1、文件读写出错检测"><a href="#5-1、文件读写出错检测" class="headerlink" title="5.1、文件读写出错检测"></a>5.1、文件读写出错检测</h3><p>ferror函数用于检测文件读写出错，如果文件读写正常返回0，出错则返回非零值。</p>
<p>基本格式：</p>
<p>​	ferror(fp)；</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ferror(fp))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“文件读写失败！”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-2、文件末尾判断"><a href="#5-2、文件末尾判断" class="headerlink" title="5.2、文件末尾判断"></a>5.2、文件末尾判断</h3><p>feof函数用于检测文件指针是否读到了文件末尾，如果文件指针读到了文件末尾则返回非零值，否则返回0。</p>
<p>基本格式：</p>
<p>​	feof(fp);</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(feof(fp))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“文件读写完毕！”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-3、文件错误标志"><a href="#5-3、文件错误标志" class="headerlink" title="5.3、文件错误标志"></a>5.3、文件错误标志</h3><p>clearerr函数的作用是使文件错误标志和文件结束标志置为0。如果在文件读写出错后，ferror函数值为一个非零值，应该立即调用clearerr(fp)，使ferror(fp)的值变为0，以便进行下次检测。</p>
<p>基本格式：</p>
<p>​	clearerr(fp);</p>
<p>注意：只要出现文件读写错误标志，它就会一直保留，直到调用clearerr函数或rewind函数，或其他任何一个输入输出函数。</p>
<h1 id="十、C语言的灵魂——指针"><a href="#十、C语言的灵魂——指针" class="headerlink" title="十、C语言的灵魂——指针"></a>十、C语言的灵魂——指针</h1><h2 id="1、什么是指针？"><a href="#1、什么是指针？" class="headerlink" title="1、什么是指针？"></a>1、什么是指针？</h2><p>在了解指针之前先要弄清楚地址的概念。</p>
<p>如果在程序中定义了一个变量，在对程序进行编译时，系统就会给这个变量分配内存单元。编译系统根据城西中定义的变量类型，分配一定长度的空间。例如：整型变量分配4个字节，字符型分配1个字节，单精度分配4个字节等。内存区的每一个字节有一个编号，这就是“地址编号”，它就相当于旅馆中的房间号，每一个房间都可以看作一块内存区域，都可以用来存放东西，我们给每个房间都编一个房间门牌号，用于更好的区分每一个房间，内存中也是一样的，整个内存由很多个字节组成，每个字节都有其对应的“房间号”，这就是“地址”了。通过这个“房间号”就可以找到其对应的“房间”，然后就可以从房间里取东西，或者把东西放进房间里了。</p>
<p>理解了地址的概念之后，那所谓的指针，就是内存地址，也就是地址的编号，可以把“指针指向地址”理解成“用小本本把房间号记下来”，那这个小本本就相当于一个用于记房间号的指针了，一个变量的地址称为此变量的“指针”。</p>
<h2 id="2、指针常量与指针变量"><a href="#2、指针常量与指针变量" class="headerlink" title="2、指针常量与指针变量"></a>2、指针常量与指针变量</h2><h3 id="2-1、指针常量"><a href="#2-1、指针常量" class="headerlink" title="2.1、指针常量"></a>2.1、指针常量</h3><p>之前有了解过不同数据类型的变量所占内存字节数的这个概念，那么系统在编译时给一个变量分配的内存地址就称为此变量的“指针”，这个指针的指向是无法改变的，所以又称为指针常量，数组的地址也是指针常量（也称为地址常量）。</p>
<h3 id="2-2、指针变量"><a href="#2-2、指针变量" class="headerlink" title="2.2、指针变量"></a>2.2、指针变量</h3><p>（1）指针变量的概念</p>
<p>如果有一个变量专门用来存放另一个变量的地址，则称这个变量为“指针变量”，也就是说C语言中有一类变量是专门用来存储（指向）地址的，我们将它称为“指针变量”，指针变量的中存储的地址可以被改变，也就是可以改变指针变量的指向，就好比一张纸或一个小本本，写着一个房间的房间号，那把这个房间的房间号擦掉，写上另一个房间的房间号也是可以的，这就是指针变量和指针常量最大的区别所在了，可以改变指针变量的指向。</p>
<p>（2）指针变量的定义</p>
<p>定义指针变量的一般格式：</p>
<p>类型名 *指针变量名;</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p,*q;</span><br><span class="line"><span class="type">char</span> *p1,*q1;</span><br><span class="line"><span class="type">double</span> *p2,*q2;</span><br></pre></td></tr></table></figure></div>

<p>注意：左端的int、char等是在定义指针变量时必须指定的“基类型”。指针变量的基类型用来规定此指针变量可以指向的变量的类型。如：上面定义的p和q只能用于指向int整型变量的地址，p2和q2只能用于指向double双精度类型变量的地址。</p>
<p>（3）指针变量的引用</p>
<p>与指针和地址相关运算符：’*’（指针运算符）和’&amp;’（取地址运算符）这里的取地址运算符要区别对待位运算符&amp;</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,*p;	p=&amp;a;	*p=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>在引用指针变量时，有以下几种情况：</p>
<p>①给指针变量赋值</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *p=&amp;a;</span><br><span class="line"><span class="comment">//定义一个整型指针变量p，初始化p的值为a的地址，也就是p指向a地址</span></span><br></pre></td></tr></table></figure></div>

<p>②解引用<br>解引用就是通过指针使用其所指向地址中存储的数据。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*p=<span class="number">30</span>;	<span class="comment">//通过指针变量p引用a变量，改变a的值为30</span></span><br><span class="line">	<span class="comment">//这里的’*’为解引用符号，p引用指针变量p所指向地址中对应的值</span></span><br><span class="line"><span class="built_in">scanf</span>(“%d”,p);	<span class="comment">//scanf通过指针变量p给变量a赋值</span></span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,*p);	<span class="comment">//通过指针变量p解引用输出变量a的值</span></span><br><span class="line">*p=b;	<span class="comment">//将b的值放入指针变量p所指向的内存地址中（a的地址单元中）</span></span><br><span class="line">p=&amp;b;	<span class="comment">//改变指针p的指向，指针p不再指向a的地址了，而是指向b的地址</span></span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,*p);	<span class="comment">//输出变量b的值</span></span><br></pre></td></tr></table></figure></div>

<p>③输出内存地址编号</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(“%p\n”,p);	<span class="comment">//以十六进制的格式输出指针变量p所指向地址的内存地址编号</span></span><br><span class="line"><span class="built_in">printf</span>(“%d\n”,&amp;a);	<span class="comment">//以十进制的格式输出变量a所在的内存地址编号</span></span><br><span class="line"><span class="built_in">printf</span>(“%o\n”,&amp;b);	<span class="comment">//以八进制的格式输出变量b所在的内存地址编号</span></span><br><span class="line"><span class="built_in">printf</span>(“%p\n”,&amp;p);	<span class="comment">//以十六进制的格式输出指针变量p所在的内存地址编号</span></span><br></pre></td></tr></table></figure></div>



<h2 id="3、指针变量作为函数参数"><a href="#3、指针变量作为函数参数" class="headerlink" title="3、指针变量作为函数参数"></a>3、指针变量作为函数参数</h2><p>函数的参数不仅可以是整型、浮点型、字符型的数据，还可以是指针类型。它的作用是将一个变量的地址传递到另一个函数中。</p>
<h3 id="3-1、函数参数为指针类型的函数"><a href="#3-1、函数参数为指针类型的函数" class="headerlink" title="3.1、函数参数为指针类型的函数"></a>3.1、函数参数为指针类型的函数</h3><p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;<span class="comment">//这里定义了一个普通函数fun1</span></span><br><span class="line">	<span class="built_in">printf</span>(“x=%d\ty=%d\n”,x++,y++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> *y)</span></span><br><span class="line">&#123;<span class="comment">//这里定义了一个形参为整型指针类型函数fun2,其形参为指针类型的变量</span></span><br><span class="line">	<span class="built_in">printf</span>(“x=%d\ty=%d\n”,*x++,*y++);</span><br><span class="line">	<span class="comment">//注意：和printf(“x=%d\ty=%d\n”,x++,y++);的区别，也就是没有和有的区别</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,*p,*q;</span><br><span class="line">	fun(a,b);	<span class="comment">//调用普通函数fun1</span></span><br><span class="line">	<span class="built_in">printf</span>(“a=%d\tb=%d\n”,a,b);</span><br><span class="line">	fun2(&amp;a,&amp;b);	<span class="comment">//这里调用函数fun时，所传递的实参必须是地址</span></span><br><span class="line">	<span class="built_in">printf</span>(“a=%d\tb=%d\n”,a,b);</span><br><span class="line">	p=&amp;a;	<span class="comment">//使用整型指针变量p指向整型变量a的地址</span></span><br><span class="line">	q=&amp;b;	<span class="comment">//使用整型指针变量q指向整型变量b的地址</span></span><br><span class="line">	fun(p,q);	<span class="comment">//这里使用指针变量p和q作为实参传递</span></span><br><span class="line">	<span class="built_in">printf</span>(“p=%d\tq=%d\n”,*p,*q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、指针函数"><a href="#3-2、指针函数" class="headerlink" title="3.2、指针函数"></a>3.2、指针函数</h3><p>函数返回值为指针类型的函数称为“指针函数”，通常用来返回一个地址。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">fun3</span><span class="params">(<span class="type">int</span> *x,<span class="type">int</span> y)</span><span class="comment">//这是一个指针函数，返回值类型为整型int指针类型</span></span><br><span class="line">&#123;</span><br><span class="line">	*x+=y;</span><br><span class="line">	<span class="built_in">printf</span>(“%d”,++*x);</span><br><span class="line">	<span class="keyword">return</span> x;	<span class="comment">//返回指针变量x所指向的内存地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="4、通过指针引用数组"><a href="#4、通过指针引用数组" class="headerlink" title="4、通过指针引用数组"></a>4、通过指针引用数组</h2><h3 id="4-1、数组元素的地址"><a href="#4-1、数组元素的地址" class="headerlink" title="4.1、数组元素的地址"></a>4.1、数组元素的地址</h3><p>数组元素的地址表示：</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,*p;</span><br><span class="line">&amp;a[<span class="number">0</span>];	<span class="comment">//引用数组元素a[0]地址的表示方法</span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-2、指针指向数组元素"><a href="#4-2、指针指向数组元素" class="headerlink" title="4.2、指针指向数组元素"></a>4.2、指针指向数组元素</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;a[<span class="number">1</span>];	<span class="comment">//指针变量p指向数组元素a[1]的地址</span></span><br></pre></td></tr></table></figure></div>

<h3 id="4-3、指针指向的移动（指针的偏移）"><a href="#4-3、指针指向的移动（指针的偏移）" class="headerlink" title="4.3、指针指向的移动（指针的偏移）"></a>4.3、指针指向的移动（指针的偏移）</h3><p>指针的偏移：指针每次会以其基类型所占字节数为单位进行偏移。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;a[<span class="number">0</span>];</span><br><span class="line">++*p;	<span class="comment">//指针指向地址中的数值加1</span></span><br><span class="line"><span class="built_in">printf</span>(“%<span class="meta">#p\n”,p);	<span class="comment">//打印指针变量p所指向的地址编号</span></span></span><br><span class="line">p++;	<span class="comment">//指针移动到数组元素a[1]的位置</span></span><br><span class="line"><span class="built_in">printf</span>(“%#X\n”,p);	<span class="comment">//打印移动后指针变量p所指向的地址编号</span></span><br><span class="line"><span class="comment">//指针变量++（或--）移动一次是移动其基类型大小的内存区域</span></span><br></pre></td></tr></table></figure></div>

<p>使用指针的偏移输入&#x2F;输出数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%d”,*(p+i));	<span class="comment">//通过指针移动引用数组元素，输出数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%d”,p[i]));	<span class="comment">//通过指针带下标的形式引用数组元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-4、指针指向字符串"><a href="#4-4、指针指向字符串" class="headerlink" title="4.4、指针指向字符串"></a>4.4、指针指向字符串</h3><p>指针可以用于直接引用字符串常量。<br>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = “abcdefg”;</span><br><span class="line"><span class="keyword">while</span> (*p)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, *p++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：可能VS某些版本需要在指针定义之前加一个const定义指针为常量指针</p>
<h2 id="5、指向函数的指针（函数指针）"><a href="#5、指向函数的指针（函数指针）" class="headerlink" title="5、指向函数的指针（函数指针）"></a>5、指向函数的指针（函数指针）</h2><p>之前有学到过函数参数是指针类型的函数以及指针函数，熟悉了一些基本的指针与函数的应用，了解了变量的地址与指针变量。</p>
<p>思考一下：那既然变量有地址，数组也有地址，那么函数会有对应的地址么？</p>
<h3 id="5-1、什么是函数指针？"><a href="#5-1、什么是函数指针？" class="headerlink" title="5.1、什么是函数指针？"></a>5.1、什么是函数指针？</h3><p>首先，函数是会占内存空间的。在程序中定义了一个函数，在编译时，编译系统会为函数代码分配一段存储空间，这段存储空间就是函数的地址，这段地址的起始地址（又称入口地址）就称为这个函数的指针（或函数的首地址）。</p>
<p>既然函数也有地址，那么我们能不能用一个指针指向函数的地址呢？</p>
<p>既然都是地址，那么就可以用指针指向它。</p>
<p>指向整型变量地址的指针是整型指针，指向字符型变量地址的指针是字符型指针，指向单精度变量地址的指针是float型指针，那指向函数的指针是什么指针呢？</p>
<p>这就是接下来要接触到的函数指针了。</p>
<h3 id="5-2、函数指针的定义"><a href="#5-2、函数指针的定义" class="headerlink" title="5.2、函数指针的定义"></a>5.2、函数指针的定义</h3><p>简单来说，函数指针就是指向函数的指针。</p>
<p>定义函数指针的一般格式：*数据类型 (函数指针名)(函数参数列表);</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*funp)(<span class="type">int</span>,<span class="type">char</span>);</span><br><span class="line"><span class="comment">//定义了一个指针函数，用于指向返回值类型为int型、函数参数为(int,char)型的函数</span></span><br></pre></td></tr></table></figure></div>



<h3 id="5-3、函数指针的初始化及使用"><a href="#5-3、函数指针的初始化及使用" class="headerlink" title="5.3、函数指针的初始化及使用"></a>5.3、函数指针的初始化及使用</h3><p>函数指针可以用于指向与其类型匹配的函数。<br>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">funsum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;	<span class="comment">//求和函数</span></span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">funmax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;	<span class="comment">//求最大值函数</span></span><br><span class="line">	<span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">funmin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;	<span class="comment">//求最小值函数</span></span><br><span class="line">	<span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> (*funp)(<span class="type">int</span>,<span class="type">int</span>)=funsum;	<span class="comment">//定义一个函数指针funp，初始化赋值指向函数funsum</span></span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>,c;	<span class="comment">//函数指针有以下两个赋值方式和两种调用方式</span></span><br><span class="line">	c=(*funp)(a,b);	<span class="comment">//通过函数指针funp调用函数funsum，(*)区分funp是个函数指针</span></span><br><span class="line">	funp=&amp;funmax;	<span class="comment">//改变函数指针funp的指向，&amp;取函数地址，使其指向函数funmax</span></span><br><span class="line">	c=funp(a,b);	<span class="comment">//此时是通过函数指针funp调用函数funmax</span></span><br><span class="line">	funp=funmin;	<span class="comment">//改变函数指针funp的指向，可以省略&amp;取址符，使其指向函数funmin</span></span><br><span class="line">	c=funp(a,b);	<span class="comment">//通过函数指针funp调用函数funmin</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="5-4、使用函数指针作为函数参数（回调函数）"><a href="#5-4、使用函数指针作为函数参数（回调函数）" class="headerlink" title="5.4、使用函数指针作为函数参数（回调函数）"></a>5.4、使用函数指针作为函数参数（回调函数）</h3><p>函数指针的一个重要的用途是把函数的地址作为参数传递到其他函数。</p>
<p>回调函数：通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就称这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> (fun)(<span class="type">int</span>,<span class="type">int</span>))</span></span><br><span class="line">&#123;<span class="comment">//这里的函数形式参数fun为函数指针类型</span></span><br><span class="line">	<span class="keyword">return</span> (*fun)(x,y);	<span class="comment">//可以通过函数fun调用其所指向的函数</span></span><br><span class="line">&#125;</span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>,sum);	<span class="comment">//调用时直接以函数名作为函数参数</span></span><br><span class="line">function(<span class="number">10</span>,<span class="number">20</span>,max);</span><br></pre></td></tr></table></figure></div>



<h3 id="5-5、使用typedef给函数指针取别名"><a href="#5-5、使用typedef给函数指针取别名" class="headerlink" title="5.5、使用typedef给函数指针取别名"></a>5.5、使用typedef给函数指针取别名</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> (*funp)(<span class="type">int</span>,<span class="type">int</span>);		<span class="comment">//给 (*)(int,int)类型的函数指针取一个别名为funp</span></span><br><span class="line">funp p1;	<span class="comment">//用别名funp定义()(int,int)类型的函数指针p1*</span></span><br><span class="line">p1 = sum;	<span class="comment">//函数指针p1指向函数sum</span></span><br><span class="line">p1(<span class="number">1</span>,<span class="number">2</span>);	<span class="comment">//通过函数指针p1调用函数</span></span><br></pre></td></tr></table></figure></div>

<h3 id="5-6、指针函数和函数指针的区别"><a href="#5-6、指针函数和函数指针的区别" class="headerlink" title="5.6、指针函数和函数指针的区别"></a>5.6、指针函数和函数指针的区别</h3><p>所谓的指针函数，其本质上是个函数，是返回值为指针类型的函数</p>
<p>所谓的函数指针，其本质上是个指针，是指向函数的指针</p>
<h2 id="6、指针数组和数组指针"><a href="#6、指针数组和数组指针" class="headerlink" title="6、指针数组和数组指针"></a>6、指针数组和数组指针</h2><h3 id="6-1、指针数组"><a href="#6-1、指针数组" class="headerlink" title="6.1、指针数组"></a>6.1、指针数组</h3><p>（1）什么指针数组</p>
<p>所谓指针数组，其本质上是一个数组，数组中的每一个元素都是指针类型的，都可以指向对应数据类型的地址。</p>
<p>（2）指针数组的定义</p>
<p>定义的一般格式：数据类型 *指针数组名[数组元素个数];</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">6</span>];	<span class="comment">//定义一个指针数组，有6个元素，分别可以指向六个地址</span></span><br></pre></td></tr></table></figure></div>

<p>（3）指针数组的使用</p>
<p>使用指针数组指向二维字符数组</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">10</span>][<span class="number">10</span>],*p[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	p[i]=arr[i];	<span class="comment">//指针数组p中的每个元素指向二维数组arr的每一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(“%s”,p[i]);	<span class="comment">//使用指针数组p给二维数组arr赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(“%s”,p[i]);	<span class="comment">//使用指针数组p输出二维数组arr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用指针数组存储字符串的形式代替二维字符数组，达到省空间的目的</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> p[<span class="number">6</span>]=&#123;“abc”,”<span class="number">123456</span>”,”abcdefg”,”hello world!”,”xiaowei”,”x”&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-2、数组指针"><a href="#6-2、数组指针" class="headerlink" title="6.2、数组指针"></a>6.2、数组指针</h3><p>（1）什么是数组指针</p>
<p>所谓的数组指针，其本质上是一个指针，是一个用于指向数组地址的指针。</p>
<p>（2）数组指针的定义</p>
<p>定义的一般格式：数据类型 (指针变量名)[所指向数组的大小];*</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>];	<span class="comment">//定义一个整型数组指针p，用于指向大小为4的整型数组</span></span><br><span class="line">p=a;	<span class="comment">//将整型数组指针p指向二维数组a的第一行</span></span><br></pre></td></tr></table></figure></div>

<p>（3）数组指针的使用</p>
<p>使用数组指针完成二维数组的输入和输出</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a3;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">6</span>];</span><br><span class="line">p = a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,p[i][j]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>（4）数组指针的移动</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p++;	<span class="comment">//移动一整行</span></span><br><span class="line">*(*(p+i)+j)	<span class="comment">//可以把数组指针理解成为一个二级指针，通过两次解引用得到元素值</span></span><br><span class="line">p[i][j];	<span class="comment">//指针带数组下标的形式访问数组元素</span></span><br></pre></td></tr></table></figure></div>



<h2 id="7、指针常量与常量指针"><a href="#7、指针常量与常量指针" class="headerlink" title="7、指针常量与常量指针"></a>7、指针常量与常量指针</h2><p>7.1、指针常量</p>
<p>指针常量就是指针的指向不能够被改变的指针，也就是指针类型的常量，指针中存储的地址不可被改变。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p;</span><br></pre></td></tr></table></figure></div>

<p>它的指向不能被改变，但是能够改变值。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b=<span class="number">20</span>; </span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> q = &amp;a; <span class="comment">//必须初始化指针指向 </span></span><br><span class="line">*q = <span class="number">30</span>; <span class="comment">//可以改变值 </span></span><br><span class="line"><span class="comment">//q = &amp;b; //错误：不能改变指针的指向 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*q);</span><br></pre></td></tr></table></figure></div>

<p>7.2、常量指针</p>
<p>常量指针就是指向常量的指针，也就是指针指向的地址内的值不可被改变，其又被称为只读指针。</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br></pre></td></tr></table></figure></div>

<p>它的能够改变指向，但是不能够改变地址内的值</p>
<p>示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b=<span class="number">20</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p; </span><br><span class="line">p = &amp;a; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p); </span><br><span class="line"><span class="comment">//*p=30; //错误：不能通过指针改变变量的值 </span></span><br><span class="line">p = &amp;b; <span class="comment">//可以改变指针的指向 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p); </span><br></pre></td></tr></table></figure></div>

<p>指针常量和常量指针一般用于函数参数的传递，为了使在函数使用中不改变值以及指针的指向。</p>
<p>如：指向常量的指针常量</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p)</span> <span class="comment">//指向常量的指针常量 </span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//指针p是一个只读指针，既不能改变指针的指向，也不能改变其指向地址里的值，在函数中防止被篡改 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="8、动态内存分配"><a href="#8、动态内存分配" class="headerlink" title="8、动态内存分配"></a>8、动态内存分配</h2><h3 id="8-1、什么是动态内存分配"><a href="#8-1、什么是动态内存分配" class="headerlink" title="8.1、什么是动态内存分配"></a>8.1、什么是动态内存分配</h3><p>动态内存分配就是使用户可以根据自己的需要，向系统申请所需大小的内存空间；由于没有声明部分来定义它们是为变量的地址还是为数组的地址，所有只能通过指针来引用它们。</p>
<p>动态内存分配的内存空间可以像普通的变量或数组一样使用，也支持存入和取出数据。</p>
<h3 id="8-2、怎样建立内存的动态分配"><a href="#8-2、怎样建立内存的动态分配" class="headerlink" title="8.2、怎样建立内存的动态分配"></a>8.2、怎样建立内存的动态分配</h3><p>①使用malloc函数动态申请内存</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="type">int</span> size);</span><br></pre></td></tr></table></figure></div>

<p>malloc函数用于动态申请一个大小为size的内存区域，并返回这块区域的首地址。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">//动态开辟一块大小为100个字节的内存区域，并使指针s指向这块区域的首地址</span></span><br></pre></td></tr></table></figure></div>

<p>size可以直接写大小，但是一般有sizeof计算</p>
<p>②使用calloc函数动态申请数组内存</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="type">unsigned</span> n,<span class="type">int</span> size);</span><br></pre></td></tr></table></figure></div>

<p>calloc函数用于分配n个大小为size的连续内存区域，可以开辟一个一维数组大小的动态内存空间，n为数组元素个数，每个数组元素的大小为size。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="comment">//动态申请10个int类型大小的连续空间，并使指针p指向那块空间的首地址</span></span><br></pre></td></tr></table></figure></div>



<p>③使用realloc函数扩大&#x2F;缩小动态内存</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">realloc</span>(<span class="type">void</span> *p,<span class="type">unsigned</span> <span class="type">int</span> size);</span><br></pre></td></tr></table></figure></div>

<p>realloc函数用于重新分配已通过malloc函数或calloc函数开辟的内存空间，可以改变其内存空间的大小。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">realloc</span>(p,<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//将指针p所指向的动态内存区域调整为5个整型大小</span></span><br></pre></td></tr></table></figure></div>



<p>④使用free函数释放动态内存空间</p>
<p>基本格式：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br></pre></td></tr></table></figure></div>

<p>free函数用于释放指针所指向的动态内存空间。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);	<span class="comment">//释放掉p指针所指向的动态内存</span></span><br></pre></td></tr></table></figure></div>

<p>用于释放指针变量p所指向的动态内存空间，使得这部分空间能被其他变量使用，否则这段内存空间需要等到程序结束后才会被释放。</p>
<p>每次使用完动态内存空间的时候记得释放内存空间。</p>
<p>开辟的内存空间大小size一般由sizeof(数据类型);来进行计算</p>
<p>（注意：以上函数的声明在stdlib.h头文件中，使用这些函数之前需要包含stdlib.h头文件）</p>
<h2 id="9、结构体指针"><a href="#9、结构体指针" class="headerlink" title="9、结构体指针"></a>9、结构体指针</h2><h3 id="9-1、指向结构体变量的指针"><a href="#9-1、指向结构体变量的指针" class="headerlink" title="9.1、指向结构体变量的指针"></a>9.1、指向结构体变量的指针</h3><p>所谓的结构体指针就是指向结构体变量的指针，一个结构体变量的起始地址就是这个结构体变量的指针。如果把一个结构体变量的起始地址存放在一个指针变量中，那么这个指针变量就指向此结构体变量。</p>
<h3 id="9-2、结构体指针的定义"><a href="#9-2、结构体指针的定义" class="headerlink" title="9.2、结构体指针的定义"></a>9.2、结构体指针的定义</h3><p>如有以下结构体：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">4</span>];</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">&#125;s1,s2,s3;</span><br></pre></td></tr></table></figure></div>

<p>则可以定义指向struct student类型结构体的指针：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">sp</span>;</span></span><br><span class="line">sp = &amp;s1;<span class="comment">//用struct student类型的结构体指针sp指向struct student类型的结构体变量s1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="9-3、通过结构体指针引用结构体成员"><a href="#9-3、通过结构体指针引用结构体成员" class="headerlink" title="9.3、通过结构体指针引用结构体成员"></a>9.3、通过结构体指针引用结构体成员</h3><p>指向结构体成员运算符：’-&gt;’</p>
<p>通过结构体指针引用结构体成员的基本格式：结构体指针名-&gt;结构体成员名</p>
<p>如：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp-&gt;id=<span class="number">100</span>;	<span class="comment">//通过结构体指针引用结构体成员用指向结构体成员运算符’-&gt;’</span></span><br><span class="line"><span class="built_in">printf</span>(“%s”,sp-&gt;name);</span><br></pre></td></tr></table></figure></div>



<h2 id="10、多重指针（多级指针）"><a href="#10、多重指针（多级指针）" class="headerlink" title="10、多重指针（多级指针）"></a>10、多重指针（多级指针）</h2><h3 id="10-1、什么是多重指针"><a href="#10-1、什么是多重指针" class="headerlink" title="10.1、什么是多重指针"></a>10.1、什么是多重指针</h3><p>之前有了解过变量、函数等都有其对应的地址，都可以由其对应数据类型的指针变量指向这个地址。那么指针变量也有地址么？</p>
<p>指针变量也是有其对应地址的，那么既然有地址，就可以用另一个指针变量指向它的地址，也就是指向指针变量地址的指针，简称指向指针的指针（双重指针&#x2F;二级指针）。而指向指针的指针也是有地址的，那又可以有指向其地址的指针，这就是多重指针了。</p>
<h3 id="10-2、多重指针的定义"><a href="#10-2、多重指针的定义" class="headerlink" title="10.2、多重指针的定义"></a>10.2、多重指针的定义</h3><p>定义双重指针（二级指针）基本格式：数据类型 **指针变量名;</p>
<p>定义三重指针（三级指针）基本格式：数据类型 ***指针变量名;</p>
<p>依次类推：四级指针、五级指针……</p>
<h3 id="10-3、多重指针的使用"><a href="#10-3、多重指针的使用" class="headerlink" title="10.3、多重指针的使用"></a>10.3、多重指针的使用</h3><p>如有以下定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,*p,**q,***r;	<span class="comment">//定义整型变量a、指针p、双重指针q、三重指针r</span></span><br></pre></td></tr></table></figure></div>

<p>就可以有以下赋值语句：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=&amp;a;	<span class="comment">//使一级指针p指向变量a的地址</span></span><br><span class="line">q=&amp;p;	<span class="comment">//使双重指针q指向一级指针p的地址</span></span><br><span class="line">r=&amp;q;	<span class="comment">//使三重指针r指向双重指针q的地址</span></span><br><span class="line">*p=<span class="number">20</span>;	<span class="comment">//使用一级指针p给变量a赋值</span></span><br><span class="line">**q=<span class="number">30</span>;	<span class="comment">//使用二级指针q给变量a赋值</span></span><br><span class="line">***r=<span class="number">40</span>;	<span class="comment">//使用三级指针r给变量a赋值</span></span><br></pre></td></tr></table></figure></div>

<h3 id="10-4、双重指针作为函数形参"><a href="#10-4、双重指针作为函数形参" class="headerlink" title="10.4、双重指针作为函数形参"></a>10.4、双重指针作为函数形参</h3><p>一般来说函数的形参无法改变实参，除非形参是指针类型的。那么如果实参是一个指针，想要在一个函数中改变一个指针的指向应该怎么做？ </p>
<p>例如：若定义了以下函数fun，如果指针p是该函数的形参，要求通过p把动态分配存储单元的首地址传回主调函数，则形参p应当怎样正确定义?</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(……)</span></span><br><span class="line">&#123;</span><br><span class="line">	*p=(<span class="type">int</span> )<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">	fun(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里形参p的类型应该定义为整型双重指针类型：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **p;</span><br></pre></td></tr></table></figure></div>

<p>双重指针可用于在函数中改变一级指针的指向。</p>
<h2 id="11、内存四区"><a href="#11、内存四区" class="headerlink" title="11、内存四区"></a>11、内存四区</h2><p>在系统为程序开辟内存时，将内存区域划分为4部分，分别为：</p>
<p>栈区：存放函数的形参、局部变量等。由编译器自动分配和释放，当函数执行完毕时自动释放。</p>
<p>堆区：用于动态内存的申请与释放，一般由程序员手动分配和释放，若程序员不释放，则程序结束时由操作系统回收。</p>
<p>全局静态常量区（全局区）：存放常量（一般是字符串常量和其他常量）、全局变量和静态变量，在程序结束后由操作系统释放。</p>
<p>代码区：存放可执行的代码，一般为CPU 执行的机器指令。</p>
<h1 id="十一、排序算法"><a href="#十一、排序算法" class="headerlink" title="十一、排序算法"></a>十一、排序算法</h1><h2 id="1、排序的基本概念"><a href="#1、排序的基本概念" class="headerlink" title="1、排序的基本概念"></a>1、排序的基本概念</h2><h3 id="1-1、什么是排序？"><a href="#1-1、什么是排序？" class="headerlink" title="1.1、什么是排序？"></a>1.1、什么是排序？</h3><p>排序是指把一组数据以某种关系（递增或递减）按顺序排列起来的一种算法。</p>
<p>例如：数列 8、3、5、6、2、9、1、0、4、7</p>
<p>递增排序后 0、1、2、3、4、5、6、7、8、9</p>
<p>递减排序后 9、8、7、6、5、4、3、2、1、0 </p>
<h3 id="1-2、排序的稳定性"><a href="#1-2、排序的稳定性" class="headerlink" title="1.2、排序的稳定性"></a>1.2、排序的稳定性</h3><p>如果在一组需要排序的数据序列中，数据ki和kj的值相同，即ki&#x3D; &#x3D;kj，且在排序前ki在序列中的位置领先于kj，那么当排序后，如果ki和kj的相对前后次序保持不变，即ki仍然领先于kj，则称此类排序算法是稳定的。如果ki和kj的相对前后次序变了，即kj领先于ki了，则称此类排序算法是不稳定的。</p>
<h3 id="1-3、排序的分类"><a href="#1-3、排序的分类" class="headerlink" title="1.3、排序的分类"></a>1.3、排序的分类</h3><p>●内部排序：指待排序数据全部存放在内存中进行排序的过程。</p>
<p>●外部排序：指待排序数据的数量很大，内存无法全部容纳所有数据，在排序过程中需要对外存进行访问的排序过程。</p>
<h3 id="1-4、排序的过程"><a href="#1-4、排序的过程" class="headerlink" title="1.4、排序的过程"></a>1.4、排序的过程</h3><p>排序的过程中需要进行如下两种基本操作：</p>
<p>（1）比较两个数据的大小；</p>
<p>（2）移动两个数据的位置。</p>
<h3 id="1-5、排序算法"><a href="#1-5、排序算法" class="headerlink" title="1.5、排序算法"></a>1.5、排序算法</h3><p>排序算法按照其实现的思想和方法的不同，可以分为许多种。</p>
<p>我们比较常用的排序算法有：冒泡排序、 插入排序、选择排序、希尔排序（缩小增量排序）、快速排序、堆排序、归并排序。</p>
<p>排序算法的分类：</p>
<p>交换类排序：冒泡排序、快速排序<br>插入类排序： 直接插入排序、希尔排序（缩小增量排序）<br>选择类排序：简单选择排序、堆排序<br>归并排序<br>基数排序</p>
<h2 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h2><p>冒泡排序的规则：n个数据进行冒泡排序，首先将第一个数据和第二个数据进行比较，如果为逆序就交换两个数据的值，然后比较第二个和第三个数据，依此类推，直到第最后一个和倒数第二个比较完了为止。上述过程为冒泡排序的第一趟冒泡排序，其结果是最大或者最小的数据被放置在末尾的位置。然后进行第二趟排序，把第二大或者第二小的数放置在倒数第二的位置，之后每一趟排序都会使一个数据有序，直到此序列的全部数据都有序为止。</p>
<p>冒泡排序的演示示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> x[],<span class="type">int</span> n)</span><span class="comment">//冒泡排序 </span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> i, j; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;n<span class="number">-1</span>-i; j++) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (x[j] &gt; x[j + <span class="number">1</span>]) </span><br><span class="line">			&#123; </span><br><span class="line">				x[j] += x[j + <span class="number">1</span>]; </span><br><span class="line">				x[j + <span class="number">1</span>] = x[j] - x[j + <span class="number">1</span>]; </span><br><span class="line">				x[j] = x[j] - x[j + <span class="number">1</span>]; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,x[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3、简单选择排序"><a href="#3、简单选择排序" class="headerlink" title="3、简单选择排序"></a>3、简单选择排序</h2><p>对一个序列进行选择排序，首先通过一轮循环比较，从n个数据中找出最大或者最小的那个数据的位置，然后按照递增或者递减的顺序，将此数据与第一个或最后一个数据进行交换。然后再找第二大或者第二小的数据进行交换，以此类推，直到序列全部有序为止。</p>
<p>选择排序与冒泡排序的区别在于，冒泡排序每比较一次后，满足条件的数据就交换，而选择排序是每次比较后，记录满足条件数据的位置，一轮循环过后再作交换。</p>
<p>选择排序的演示示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> n)</span><span class="comment">//选择排序 </span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> i, j, min,k; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">	&#123; </span><br><span class="line">		min=i;</span><br><span class="line">		<span class="keyword">for</span> (j = i; j &lt; n; j++) </span><br><span class="line">		&#123; </span><br><span class="line">			<span class="keyword">if</span> (x[min] &gt; x[j]) </span><br><span class="line">			min = j; </span><br><span class="line">		&#125;</span><br><span class="line">		k = x[i]; </span><br><span class="line">		x[i] = x[min]; </span><br><span class="line">		x[min] = k; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,x[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="4、直接插入排序"><a href="#4、直接插入排序" class="headerlink" title="4、直接插入排序"></a>4、直接插入排序</h2><p>插入排序的规则是：第一轮开始时默认序列中第一个数据是有序的，之后各个数据以此为基准，判断是插入在此数据的前面还是后面，之后的数据依次向后移动，腾出位置，让数据插入，以此类推，直到整个序列有序为止。每比较一次，如果满足条件（升序：前面一个数比后面需要插入的数大），就直接交换。</p>
<p>特点：对基本有序的序列插入排序速度相对而言比较快，插入排序的优势越明显，数据量越多，劣势也越明显</p>
<p>插入排序的演示示例：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> x[], <span class="type">int</span> n)</span><span class="comment">//插入排序 </span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="type">int</span> i, j, k; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">for</span> (j = i; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">		<span class="keyword">if</span> (x[j - <span class="number">1</span>]&gt;x[j]) </span><br><span class="line">		&#123; </span><br><span class="line">			k = x[j - <span class="number">1</span>]; </span><br><span class="line">			x[j - <span class="number">1</span>] = x[j]; </span><br><span class="line">			x[j] = k; </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n;i++) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,x[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>优化后的插入排序：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span><span class="comment">//优化后的插入排序 </span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tempVal; </span><br><span class="line">	<span class="type">int</span> j; </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)<span class="comment">//确定循环次数，改变i是为了把i直接当成下标 </span></span><br><span class="line">	&#123; </span><br><span class="line">		tempVal = arr[i];<span class="comment">//把待插入的数据另行保存一份 </span></span><br><span class="line">		j = i - <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; tempVal &lt; arr[j]) </span><br><span class="line">		&#123; </span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j]; </span><br><span class="line">			--j; </span><br><span class="line">		&#125;</span><br><span class="line">		arr[j + <span class="number">1</span>] = tempVal;<span class="comment">//注意 ： j+1 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="十二、顺序表"><a href="#十二、顺序表" class="headerlink" title="十二、顺序表"></a>十二、顺序表</h1><h2 id="1、顺序表的基本概念"><a href="#1、顺序表的基本概念" class="headerlink" title="1、顺序表的基本概念"></a>1、顺序表的基本概念</h2><p>顺序表是将表中的数据依次存放在计算机内存中一组地址连续的存储单元中的一种数据结构，可以将顺序表看成一个可以动态改变大小的数组。</p>
<p>​	数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系</p>
<p>是线性表的一种，也就是采用顺序存储结构的线性表简称为”顺序表”。</p>
<p>顺序表的存储特点是：只要确定了起始位置 ,数据可以通过指定位置得到：首地址+(位置*偏移大小)</p>
<h2 id="2、顺序表的定义"><a href="#2、顺序表的定义" class="headerlink" title="2、顺序表的定义"></a>2、顺序表的定义</h2><p>顺序表结构的定义如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type <span class="comment">//类型别名的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">	Type *data; <span class="comment">//数据域（存储数据的空间）</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//顺序表的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="3、顺序表的功能实现"><a href="#3、顺序表的功能实现" class="headerlink" title="3、顺序表的功能实现"></a>3、顺序表的功能实现</h2><p>数据的4种基本操作：增、删、改、查，顺序表的基本操作：增、删、改、查。</p>
<p>使用函数实现以下顺序表的基本操作：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顺序表功能函数的实现*/</span></span><br><span class="line"><span class="comment">//①构造一个空的顺序线性表</span></span><br><span class="line"><span class="built_in">array</span> * <span class="title function_">arr_init</span><span class="params">()</span> <span class="comment">//顺序表的初始化函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">array</span> * temp = (<span class="built_in">array</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">array</span>)); <span class="comment">//顺序表结构体的初始化</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表初始化失败：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	temp-&gt;data = (Type *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(Type)); <span class="comment">//顺序表数据域的初始化</span></span><br><span class="line">	temp-&gt;lenth = <span class="number">0</span>; <span class="comment">//顺序表长度的初始化</span></span><br><span class="line">	<span class="keyword">return</span> temp; <span class="comment">//将顺序表返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//②销毁顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_free</span><span class="params">(<span class="built_in">array</span> * arr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr-&gt;data != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">free</span>(arr-&gt;data); <span class="comment">//释放顺序表的数据域</span></span><br><span class="line">		<span class="built_in">free</span>(arr); <span class="comment">//释放整个顺序表</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//③重置为空表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_clear</span><span class="params">(<span class="built_in">array</span> * arr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (int i = 0; i &lt; arr-&gt;lenth; i++)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		arr-&gt;data[i] = 0; //顺序表元素置0</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	arr-&gt;data = (Type *)realloc(arr-&gt;data, sizeof(Type)); //顺序表数据域清空</span></span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(arr-&gt;data);</span><br><span class="line">	arr-&gt;data = (Type *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Type));</span><br><span class="line">	arr-&gt;lenth = <span class="number">0</span>; <span class="comment">//顺序表长度置0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//④判断是否为空表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">arr_empty</span><span class="params">(<span class="built_in">array</span> * arr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;lenth == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⑤插入顺序表元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_push</span><span class="params">(<span class="built_in">array</span> * arr, Type elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Error(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Error(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arr-&gt;lenth++; <span class="comment">//顺序表长度+1</span></span><br><span class="line">	arr-&gt;data = (Type *)<span class="built_in">realloc</span>(arr-&gt;data, <span class="keyword">sizeof</span>(Type)*arr-&gt;lenth); <span class="comment">//顺序表数据域内存扩大</span></span><br><span class="line">	arr-&gt;data[arr-&gt;lenth<span class="number">-1</span>] = elem; <span class="comment">//元素放入顺序表最后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⑥在顺序表指定位置插入新的数据元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_insert</span><span class="params">(<span class="built_in">array</span> * arr, <span class="type">int</span> index, Type elem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr_empty(arr))</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">//判断顺序表是否为空</span></span><br><span class="line"><span class="comment">//	if (index &gt; arr-&gt;lenth) //如果插入的位置大于顺序表最大长度，则插入错误</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		printf(&quot;插入数据的位置错误：&quot;);</span></span><br><span class="line"><span class="comment">// 		return;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	<span class="type">int</span> i = arr-&gt;lenth++;</span><br><span class="line">	arr-&gt;data = (Type *)<span class="built_in">realloc</span>(arr-&gt;data, <span class="keyword">sizeof</span>(Type)*arr-&gt;lenth); <span class="comment">//顺序表数 据域内存扩大</span></span><br><span class="line">	<span class="keyword">for</span> (; i &gt; index - <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		arr-&gt;data[i] = arr-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	arr-&gt;data[i] = elem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⑦删除顺序表指定位置的数据元素, 并返回元素的值</span></span><br><span class="line">Type <span class="title function_">arr_remove</span><span class="params">(<span class="built_in">array</span> * arr, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr_empty(arr))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	&#125;</span><br><span class="line">	Type val = arr-&gt;data[index - <span class="number">1</span>]; <span class="comment">//记录被删除元素</span></span><br><span class="line">	<span class="type">int</span> i = index - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; arr-&gt;lenth; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr-&gt;data[i] = arr-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	arr-&gt;lenth--; <span class="comment">//顺序表长度减1</span></span><br><span class="line">	arr-&gt;data = (Type *)<span class="built_in">realloc</span>(arr-&gt;data, <span class="keyword">sizeof</span>(Type)*arr-&gt;lenth); <span class="comment">//顺序表数据域内存减少</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//⑧输出顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">arr_out</span><span class="params">(<span class="built_in">array</span> * arr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (arr-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序表数据域为空：&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arr_empty(arr); <span class="comment">//判断顺序表是否为空</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr-&gt;lenth; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(P, arr-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="十三、链表"><a href="#十三、链表" class="headerlink" title="十三、链表"></a>十三、链表</h1><h2 id="1、链表的基本概念"><a href="#1、链表的基本概念" class="headerlink" title="1、链表的基本概念"></a>1、链表的基本概念</h2><h3 id="1-1、什么是链表"><a href="#1-1、什么是链表" class="headerlink" title="1.1、什么是链表"></a>1.1、什么是链表</h3><p>链表是数据结构中线性表的一种，其中的每个元素实际上是一个单独的结构体对象，而所有对象都通过</p>
<p>每个元素中的指针链接在一起。它是以结构体为节点，将一个结构体看成数据域和指针域两个部分，数</p>
<p>据域用于存储数据，指针域用于连接下一个节点，链表中每个结构体对象叫做节点，其中第一个数据节</p>
<p>点叫做链表的首元节点；如果第一个节点不用于存储数据，只用于代表链表的起始点，则这个节点称为</p>
<p>链表的头节点。</p>
<h3 id="1-2、链表的特点"><a href="#1-2、链表的特点" class="headerlink" title="1.2、链表的特点"></a>1.2、链表的特点</h3><p>链表有以下特点：</p>
<p>①链表没有固定的长度，可以自由增加节点<br>②链表能够实现快速的插入删除数据，也就是可以快速的插入和删除链表中的节点<br>③与数组类似，链表也是一种线性数据结构<br>④链表的尾结点的后继必定指向空</p>
<h3 id="1-3、链表和数组的区别："><a href="#1-3、链表和数组的区别：" class="headerlink" title="1.3、链表和数组的区别："></a>1.3、链表和数组的区别：</h3><p>数组和顺序表是顺序存储的，也就是内存是连续的；而链表是通过指针将不连续的内存连接起来，实现链式存储的。</p>
<h2 id="2、链表的结构"><a href="#2、链表的结构" class="headerlink" title="2、链表的结构"></a>2、链表的结构</h2><h2 id="3、单链表"><a href="#3、单链表" class="headerlink" title="3、单链表"></a>3、单链表</h2><h3 id="3-1、单链表结构的声明"><a href="#3-1、单链表结构的声明" class="headerlink" title="3.1、单链表结构的声明"></a>3.1、单链表结构的声明</h3><p>单链表结构体的定义如下所示：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type; <span class="comment">//数据类型 通过取别名的形式进行灵活使用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="comment">//单链表节点结构体的声明</span></span><br><span class="line">	Type data; <span class="comment">//链表节点的数据域，用于存储数据</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">//链表节点的指针域，用于指向和连接下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>&#123;</span> <span class="comment">//单链表结构体的声明</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span>;</span> <span class="comment">//链表头节点的指针域，用于指向链表的开头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">//链表尾节点的指针域，用于指向链表的末尾</span></span><br><span class="line">	<span class="type">int</span> lenth; <span class="comment">//链表的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2、单链表的创建与功能实现"><a href="#3-2、单链表的创建与功能实现" class="headerlink" title="3.2、单链表的创建与功能实现"></a>3.2、单链表的创建与功能实现</h3><p>（1）单链表的创建</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建单链表 </span></span><br><span class="line">LL *<span class="title function_">list_init</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">	LL *temp = (LL *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LL)); </span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>) </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	temp-&gt;head = <span class="literal">NULL</span>; <span class="comment">//链表头节点指针置空(初始化) </span></span><br><span class="line">	temp-&gt;end = <span class="literal">NULL</span>; <span class="comment">//链表尾结点指针置空(初始化) </span></span><br><span class="line">	temp-&gt;lenth = <span class="number">0</span>; <span class="comment">//链表长度置0(初始化) </span></span><br><span class="line">	<span class="keyword">return</span> temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（2）单链表节点的链接</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、链接单链表节点</span></span><br><span class="line">Node *<span class="title function_">node_init</span><span class="params">(Type val)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node *temp = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="keyword">if</span> (temp == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	temp-&gt;data = val; <span class="comment">//链表节点的数据域赋值</span></span><br><span class="line">	temp-&gt;next = <span class="literal">NULL</span>; <span class="comment">//(*temp).next = NULL</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（3）单链表的输出</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、单链表的输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_print</span><span class="params">(LL *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;链表为空！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Node *temp = <span class="built_in">list</span>-&gt;head; temp != <span class="literal">NULL</span>; temp = temp-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(T, temp-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（4）单链表节点的插入</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、单链表节点的插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert_end</span><span class="params">(LL *<span class="built_in">list</span>, Type val)</span> <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Node *temp = node_init(val);</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>) <span class="comment">//如果是空链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;end = node_init(val); <span class="comment">//第一个链表节点，其既是头部也是尾部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth++; <span class="comment">//链表长度+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Node *temp = node_init(val);</span></span><br><span class="line">		<span class="comment">//list-&gt;end-&gt;next = temp</span></span><br><span class="line">		<span class="comment">//list-&gt;end = temp;</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;end-&gt;next = node_init(val); <span class="comment">//创建一个新节点，连接到链表当前的末尾</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;end = <span class="built_in">list</span>-&gt;end-&gt;next; <span class="comment">//新节点成为新的尾部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth++; <span class="comment">//链表长度+1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（5）单链表节点的删除</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5、单链表节点的删除</span></span><br><span class="line">Type <span class="title function_">list_delete</span><span class="params">(LL *<span class="built_in">list</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; <span class="built_in">list</span>-&gt;lenth || index &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;删除位置错误！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Node *temp = <span class="built_in">list</span>-&gt;head; <span class="comment">//记录当前头部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;head-&gt;next; <span class="comment">//第二个节点成为新的头部</span></span><br><span class="line">		Type val = temp-&gt;data; <span class="built_in">free</span>(temp);</span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth--;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="built_in">list</span>-&gt;lenth)</span><br><span class="line">	&#123;</span><br><span class="line">		Node *temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; index - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp = temp-&gt;next; <span class="comment">//找到删除位置前一个节点</span></span><br><span class="line">		&#125;</span><br><span class="line">		Type val = temp-&gt;next-&gt;data; <span class="built_in">free</span>(temp-&gt;next);</span><br><span class="line">		temp-&gt;next = <span class="literal">NULL</span>; <span class="comment">//链表末尾指向空</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;end = temp; <span class="comment">//倒数第二个节点成为新的尾部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth--;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line">	Node *temp1 = <span class="built_in">list</span>-&gt;head; Node *temp2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; index - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp1 = temp1-&gt;next;</span><br><span class="line">		<span class="comment">//找到删除位置前一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	Type val = temp1-&gt;next-&gt;data; <span class="comment">//记录被删除节点的数据</span></span><br><span class="line">	temp2 = temp1-&gt;next; <span class="comment">//temp2指向被删除节点</span></span><br><span class="line">	temp1-&gt;next = temp2-&gt;next; <span class="comment">//删除位置前的节点跳过被删除的节点，指向下下一个节点</span></span><br><span class="line">	<span class="built_in">free</span>(temp2); <span class="comment">//释放被删除节点</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;lenth--; </span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（6）向单链表指定位置插入数据</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6、指定位置插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert</span><span class="params">(LL *<span class="built_in">list</span>, <span class="type">int</span> index, Type val)</span> <span class="comment">//index指定位置</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; <span class="built_in">list</span>-&gt;lenth+<span class="number">1</span> || index&lt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;插入位置错误！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="built_in">list</span>-&gt;lenth + <span class="number">1</span>) <span class="comment">//如果插入位置刚好比链表长度大一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		list_insert_end(<span class="built_in">list</span>, val); <span class="comment">//从尾部插入</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">1</span>) <span class="comment">//如果在当前头节点之前插入</span></span><br><span class="line">	&#123;</span><br><span class="line">		Node * New = node_init(val); <span class="comment">//创建新插入的节点</span></span><br><span class="line">		New-&gt;next = <span class="built_in">list</span>-&gt;head; <span class="comment">//新节点指向当前头节点</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;head = New; <span class="comment">//新节点成为新的头部</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;lenth++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node *temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; index<span class="number">-1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = temp-&gt;next; <span class="comment">//找到插入位置前一个节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	Node * New = node_init(val); <span class="comment">//创建新插入的节点</span></span><br><span class="line">	New-&gt;next = temp-&gt;next; <span class="comment">//新节点连接插入位置之后的节点</span></span><br><span class="line">	temp-&gt;next = New; <span class="comment">//链表插入位置之前的节点连接上新节点</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;lenth++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（7）获取单链表指定位置上的数据</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7、获取单链表指定位置上的数据</span></span><br><span class="line">Type <span class="title function_">list_get</span><span class="params">(LL *<span class="built_in">list</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index &gt; <span class="built_in">list</span>-&gt;lenth || index &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;位置错误！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node *temp = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; index; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>（8）单链表的销毁</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8、链表的销毁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_delete_all</span><span class="params">(LL **<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (*<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;错误，链表空间不存在！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	if (list-&gt;head == NULL)</span></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		free(list);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	Node *temp1 = (*<span class="built_in">list</span>)-&gt;head,*temp2;</span><br><span class="line">	<span class="keyword">for</span> (; temp1 != <span class="literal">NULL</span>;) <span class="comment">//循环释放链表中的各个数据节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp2 = temp1;</span><br><span class="line">		temp1 = temp1-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(temp2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(*<span class="built_in">list</span>); <span class="comment">//释放整个链表</span></span><br><span class="line">	*<span class="built_in">list</span> = <span class="literal">NULL</span>;	<span class="comment">//链表指针指向空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h1 id="十四、栈和队列"><a href="#十四、栈和队列" class="headerlink" title="十四、栈和队列"></a>十四、栈和队列</h1><h2 id="1、栈和队列的基本概念"><a href="#1、栈和队列的基本概念" class="headerlink" title="1、栈和队列的基本概念"></a>1、栈和队列的基本概念</h2><p>在数组中，我们可以通过索引（下标）访问随机元素。 但是，在某些情况下，我们可能需要限制处理</p>
<p>顺序，这就产生了栈和队列这两种功能受限的线性结构。</p>
<p>栈和队列是两种不同的处理顺序：先进后出和先进先出，以及两个相应的线性数据结构。</p>
<h2 id="2、数据结构中的栈和队列"><a href="#2、数据结构中的栈和队列" class="headerlink" title="2、数据结构中的栈和队列"></a>2、数据结构中的栈和队列</h2><h3 id="2-1、栈-stack"><a href="#2-1、栈-stack" class="headerlink" title="2.1、栈 (stack)"></a>2.1、栈 (stack)</h3><p>数据后进先出,先进后出：LIFO (last in first out)</p>
<p>栈只有一个开口,先进去的就到下面,后进来的就在上面(top),要是拿出去的话,肯定是从开口端拿出去,所以说先进后出，后进先出。</p>
<p>入栈：push</p>
<p>出栈：pop</p>
<p>获取栈顶元素：top</p>
<p>判断栈是否已经为空：is_empty</p>
<p>判断栈是否已经满了：is_full (如果是数组实现的) </p>
<h3 id="2-2、队列-queue"><a href="#2-2、队列-queue" class="headerlink" title="2.2、队列(queue)"></a>2.2、队列(queue)</h3><p>数据入队规则：先进先出，后进后出，FIFO(first in first out)</p>
<p>队列有队首（front）和队尾（back），数据从队尾入队，从队首出队。</p>
<p>队首（front）指向队列的第一个数据，队尾（back）指向队列中的最后一个数据。</p>
<p>入队：push</p>
<p>出队：pop</p>
<p>队首：front</p>
<p>队尾：back</p>
<h2 id="3、栈和队列的基本结构"><a href="#3、栈和队列的基本结构" class="headerlink" title="3、栈和队列的基本结构"></a>3、栈和队列的基本结构</h2><h3 id="3-1、栈和队列的结构示意图"><a href="#3-1、栈和队列的结构示意图" class="headerlink" title="3.1、栈和队列的结构示意图"></a>3.1、栈和队列的结构示意图</h3><h3 id="3-2、栈和队列中数据的插入和删除"><a href="#3-2、栈和队列中数据的插入和删除" class="headerlink" title="3.2、栈和队列中数据的插入和删除"></a>3.2、栈和队列中数据的插入和删除</h3><p>（1）栈中数据的插入和删除</p>
<p>（2）队列中数据的插入和删除</p>
<h2 id="4、栈和队列的实现"><a href="#4、栈和队列的实现" class="headerlink" title="4、栈和队列的实现"></a>4、栈和队列的实现</h2><h3 id="4-1、栈功能的实现"><a href="#4-1、栈功能的实现" class="headerlink" title="4.1、栈功能的实现"></a>4.1、栈功能的实现</h3><p>可以使用链表或顺序表的结构实现栈。</p>
<p>如：栈的数组实现</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 10 <span class="comment">//栈的最大大小</span></span></span><br><span class="line"><span class="comment">//栈的数组实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> //栈的结构体声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Type data[STACK_SIZE]; <span class="comment">//数据域</span></span><br><span class="line">	<span class="type">int</span> top; <span class="comment">//栈顶元素下标</span></span><br><span class="line">&#125;<span class="built_in">stack</span>;</span><br><span class="line"><span class="comment">/*栈的功能实现*/</span></span><br><span class="line"><span class="comment">//栈的初始化函数</span></span><br><span class="line"><span class="built_in">stack</span> *<span class="title function_">stack_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">stack</span> *temp = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">	assert(temp);</span><br><span class="line">	temp-&gt;top = <span class="number">-1</span>; <span class="comment">//初始化栈顶元素下标为-1，-1表示栈中没有元素</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据入栈函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stack_push</span><span class="params">(<span class="built_in">stack</span> *st, Type val)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(st); <span class="comment">//判断栈是否存在</span></span><br><span class="line">	assert(!stack_full(st)); <span class="comment">//判断栈是否满了</span></span><br><span class="line">	st-&gt;data[++st-&gt;top] = val; <span class="comment">//从栈顶插入元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据出栈函数</span></span><br><span class="line">Type <span class="title function_">stack_pop</span><span class="params">(<span class="built_in">stack</span> *st)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(st); <span class="comment">//判断栈是否存在</span></span><br><span class="line">	assert(!stack_empty(st)); <span class="comment">//判断栈是否空了</span></span><br><span class="line">	Type val = st-&gt;data[st-&gt;top]; <span class="comment">//记录当前栈顶元素</span></span><br><span class="line">	st-&gt;top--; <span class="comment">//栈顶元素下标-1</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取栈顶元素</span></span><br><span class="line">Type <span class="title function_">stack_top</span><span class="params">(<span class="built_in">stack</span> *st)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(st); <span class="comment">//判断栈是否存在</span></span><br><span class="line">	assert(!stack_empty(st)); <span class="comment">//判断栈是否空了</span></span><br><span class="line">	<span class="keyword">return</span> st-&gt;data[st-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">stack_empty</span><span class="params">(<span class="built_in">stack</span> *st)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> st-&gt;top == <span class="number">-1</span>; <span class="comment">//栈空了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈是否满了</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">stack_full</span><span class="params">(<span class="built_in">stack</span> *st)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> st-&gt;top &gt;= STACK_SIZE; <span class="comment">//栈满了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-2、队列功能的实现"><a href="#4-2、队列功能的实现" class="headerlink" title="4.2、队列功能的实现"></a>4.2、队列功能的实现</h3><p>可以使用链表或顺序表的结构实现队列。</p>
<p>如：队列的链表实现</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Type;</span><br><span class="line"><span class="comment">/*队列的链表实现*/</span></span><br><span class="line"><span class="comment">//链表节点结构的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Type data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">//队列链表结构的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Node *front; <span class="comment">//队首指针</span></span><br><span class="line">	Node *back; <span class="comment">//队尾指针</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="comment">/*队列功能的实现*/</span></span><br><span class="line"><span class="comment">//队列单链表的初始化</span></span><br><span class="line">Queue *<span class="title function_">queue_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Queue *temp = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">	assert(temp); <span class="comment">//如果队列初始化失败则报错</span></span><br><span class="line">	temp-&gt;front = temp-&gt;back = <span class="literal">NULL</span>; <span class="comment">//队首和队尾指针初始化为NULL</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列单链表节点的创建函数</span></span><br><span class="line">Node *<span class="title function_">node_create</span><span class="params">(Type val)</span></span><br><span class="line">&#123;</span><br><span class="line">	Node *temp = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	assert(temp);</span><br><span class="line">	temp-&gt;data = val; <span class="comment">//节点数据域的初始化</span></span><br><span class="line">	temp-&gt;next = <span class="literal">NULL</span>; <span class="comment">//节点指针域的初始化</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据入队函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_push</span><span class="params">(Queue *q, Type val)</span> <span class="comment">//链表的尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q);</span><br><span class="line"><span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	q-&gt;front = node_create(val); <span class="comment">//创建队列的第一个节点</span></span><br><span class="line">	q-&gt;back = q-&gt;front; <span class="comment">//队列只有一个节点，其既是头部也是尾部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	q-&gt;back-&gt;next = node_create(val); <span class="comment">//新创建的节点连接到队列尾部</span></span><br><span class="line">	q-&gt;back = q-&gt;back-&gt;next; <span class="comment">//新节点是新的尾部</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据出队函数</span></span><br><span class="line">Type <span class="title function_">queue_pop</span><span class="params">(Queue *q)</span> <span class="comment">//链表的头删法</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q); <span class="comment">//整个链表不存在</span></span><br><span class="line">	assert(q-&gt;front); <span class="comment">//链表为空</span></span><br><span class="line">	Node *temp = q-&gt;front;</span><br><span class="line">	Type val = temp-&gt;data;</span><br><span class="line">	q-&gt;front = q-&gt;front-&gt;next; <span class="comment">//当前队首的下一个节点成为成为新的队首</span></span><br><span class="line">	<span class="built_in">free</span>(temp); <span class="comment">//之前的队首节点释放</span></span><br><span class="line">	temp = <span class="literal">NULL</span>; <span class="comment">//避免temp成为野指针</span></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取队首元素</span></span><br><span class="line">Type <span class="title function_">queue_front</span><span class="params">(Queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q); <span class="comment">//整个链表不存在</span></span><br><span class="line">	<span class="comment">//assert(q-&gt;front); //链表为空</span></span><br><span class="line">	assert(!queue_empty(q)); <span class="comment">//链表为空</span></span><br><span class="line">	<span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取队尾元素</span></span><br><span class="line">Type <span class="title function_">queue_back</span><span class="params">(Queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q); <span class="comment">//整个链表不存在</span></span><br><span class="line">	<span class="comment">//assert(q-&gt;front); //链表为空</span></span><br><span class="line">	assert(!queue_empty(q)); <span class="comment">//链表为空</span></span><br><span class="line">	<span class="keyword">return</span> q-&gt;back-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">queue_empty</span><span class="params">(Queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(q); <span class="comment">//整个链表不存在</span></span><br><span class="line">	<span class="comment">//if (q-&gt;front == NULL) //如果队列为空</span></span><br><span class="line">    <span class="comment">//	return true; //返回真1</span></span><br><span class="line">	<span class="comment">//else</span></span><br><span class="line">	<span class="comment">//	return false; //否则返回假0</span></span><br><span class="line">	<span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>; <span class="comment">//判断队列是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> C语言入门</li>
        <li><strong>作者:</strong> 小颜同学</li>
        <li><strong>创建于:</strong> 2022-09-02 12:36:14</li>
        
            <li>
                <strong>更新于:</strong> 2023-05-28 15:34:33
            </li>
        
        <li>
            <strong>链接:</strong> https://www.wy-studio.cn/2022/09/02/C语言入门/
        </li>
        <li>
            <strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/C%E8%AF%AD%E8%A8%80/">#C语言</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2022/09/02/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">idea快捷键</span>
                                    <span class="post-nav-item">上一篇</span>
                                </span>
                            </a>
                        </div>
                    
                    
                </div>
            


            
                <div class="comment-container">
                    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;评论
    </div>
    

        
            
 
    <div id="waline"></div>
    <script type="module"  data-pjax>
        import { init } from 'https://evan.beee.top/js/waline.mjs';

        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://example.wy-studio.cn',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
            });
        }

        if ('true') {
            const loadWalineTimeout = setTimeout(() => {
                loadWaline();
                clearTimeout(loadWalineTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadWaline);
        }
        
    </script>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">C语言入门</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-text">目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81C%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B"><span class="nav-text">一、C语言简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-text">1、程序语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="nav-text">1.1、程序设计语言概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">1.2、语言处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%88%90%E5%88%86"><span class="nav-text">1.3、程序设计语言的基本成分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFC%E8%AF%AD%E8%A8%80"><span class="nav-text">2、什么是C语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81C%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-text">3、C语言发展历程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">4、C语言的特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">二、基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="nav-text">1、数据的表现形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81%E5%B8%B8%E9%87%8F"><span class="nav-text">1.1、常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81%E5%8F%98%E9%87%8F"><span class="nav-text">1.2、变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">2、基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1、数据类型的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="nav-text">2.2、基本数据类型简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E3%80%81%E7%A1%AE%E5%AE%9A%E5%B8%B8%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.3、确定常量的类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-text">3、格式化输入输出函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E6%9C%89%E5%85%B3%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1、有关数据输入和输出的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E7%94%A8printf%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%EF%BC%88%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-text">3.2、用printf函数输出数据（格式化输出函数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%81%E7%94%A8scanf%E5%87%BD%E6%95%B0%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%88%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-text">3.3、用scanf函数输入数据（格式化输入函数）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">三、运算符和表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">1、C语言运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81C%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">1.1、C运算符的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%9B%AE%E6%95%B0"><span class="nav-text">1.2、运算符的操作数以及目数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">1.3、运算符的优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">2、算术运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">2.1、基本的算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E8%87%AA%E5%A2%9E%E3%80%81%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">2.2、自增、自减运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E3%80%81%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7"><span class="nav-text">2.3、算术表达式与运算符的优先级和结合性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E3%80%81%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E9%97%B4%E7%9A%84%E6%B7%B7%E5%90%88%E8%BF%90%E7%AE%97"><span class="nav-text">2.4、不同类型数据间的混合运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">3、强制类型转换运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">4、关系运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">5、逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">6、条件运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">7、位运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CC%E8%AF%AD%E5%8F%A5"><span class="nav-text">8、表达式和C语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">8.1、表达式和语句的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2%E3%80%81%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">8.2、逗号表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3%E3%80%81%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="nav-text">8.3、最基本的语句——赋值语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4%E3%80%81C%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">8.4、C语句的分类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-text">四、选择结构和循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="nav-text">1、选择结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81if%E8%AF%AD%E5%8F%A5"><span class="nav-text">1.1、if语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81switch%E8%AF%AD%E5%8F%A5"><span class="nav-text">1.2、switch语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-text">2、循环结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81for%E5%BE%AA%E7%8E%AF"><span class="nav-text">2.1、for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81while%E5%BE%AA%E7%8E%AF"><span class="nav-text">2.2、while循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E3%80%81do-while%E5%BE%AA%E7%8E%AF"><span class="nav-text">2.3、do  while循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">2.4、循环结构的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="nav-text">3、跳转语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81break%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.1、break语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81continue%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.2、continue语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%81goto%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.3、goto跳转语句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-text">五、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-text">1、什么是数组？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-text">2、一维数组的定义和引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E5%AE%9A%E4%B9%89%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">2.1、定义一维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%8F%8A%E5%BC%95%E7%94%A8%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="nav-text">2.2、使用数组及引用数组元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">2.3、一维数组的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E3%80%81%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">2.4、一维数组的输入输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">3、二维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">3.1、二维数组的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">3.2、二维数组的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">3.3、二维数组元素的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">3.4、二维数组的输入输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="nav-text">4、字符数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">4.1、字符数组的定义及初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E3%80%81%E5%BC%95%E7%94%A8%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">4.2、引用字符数组中的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-text">4.3、字符数组的输入和输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4%E3%80%81%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="nav-text">4.4、二维字符数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">4.5、字符串处理函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-text">六、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1、函数的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2、函数的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E5%AE%9A%E4%B9%89%E6%97%A0%E5%8F%82%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-text">2.1、定义无参无返回值函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E5%AE%9A%E4%B9%89%E6%9C%89%E5%8F%82%E6%95%B0%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-text">2.2、定义有参数无返回值函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E3%80%81%E5%AE%9A%E4%B9%89%E6%9C%89%E5%8F%82%E6%95%B0%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-text">2.3、定义有参数有返回值函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E3%80%81%E5%AE%9A%E4%B9%89%E6%97%A0%E5%8F%82%E6%95%B0%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-text">2.4、定义无参数有返回值函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-text">3、函数的调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%AF%AD%E5%8F%A5"><span class="nav-text">3.1、函数调用语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">3.2、函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%81%E5%AE%9E%E5%8F%82%E5%92%8C%E5%BD%A2%E5%8F%82%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="nav-text">3.3、实参和形参之间的数据传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">3.4、函数的返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-text">4、函数的声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-text">5、局部变量和全局变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text">5.1、局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-text">5.2、全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-text">5.3、静态变量与动态变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8"><span class="nav-text">6、函数的嵌套调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="nav-text">7、函数的递归调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">8、数组作为函数参数传递</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-text">七、预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E9%A2%84%E5%AE%9A%E4%B9%89%E7%AC%A6%E5%8F%B7"><span class="nav-text">1、预定义符号:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">2、宏定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E6%97%A0%E5%8F%82%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1、无参宏定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E5%B8%A6%E5%8F%82%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">2.2、带参宏定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E3%80%81%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-text">2.3、常量的定义：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="nav-text">3、文件包含</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">3.1、包含头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB"><span class="nav-text">3.2、头文件的重复包含</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-text">4、条件编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E3%80%81-if%E2%80%A6%E2%80%A6-else%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">4.1、#if……#else的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E3%80%81-ifdef%E2%80%A6%E2%80%A6-endif%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">4.2、#ifdef……#endif的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E3%80%81-ifndef%E2%80%A6%E2%80%A6-endif%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">4.3、#ifndef……#endif的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">八、构造数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">1、结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9F"><span class="nav-text">1.1、什么是结构体？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9F"><span class="nav-text">1.2、为什么要用结构体？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">1.3、结构体类型的声明和结构体变量的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-text">1.4、结构体变量的初始化和引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5%E3%80%81%E4%BD%BF%E7%94%A8typedef%E5%85%B3%E9%94%AE%E5%AD%97%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%90%8D"><span class="nav-text">1.5、使用typedef关键字自定义类型名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%B5%8C%E5%A5%97%E5%AE%9A%E4%B9%89"><span class="nav-text">1.6、结构体的嵌套定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="nav-text">1.7、结构体数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93"><span class="nav-text">2、共用体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B1%E7%94%A8%E4%BD%93%EF%BC%9F"><span class="nav-text">2.1、什么是共用体？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2.2、共用体类型的声明和共用体变量的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E7%B1%BB%E5%9E%8B%E6%89%80%E5%8D%A0%E5%86%85%E5%AD%98"><span class="nav-text">2.3、共用体类型所占内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-text">3、枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1、枚举类型的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-text">3.2、枚举类型的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%81%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">3.3、枚举变量的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="nav-text">3.4、枚举类型应用举例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">九、C语言文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6%EF%BC%9F"><span class="nav-text">1、什么是文件？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1.1、文件的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">1.2、文件的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E3%80%81%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.3、文件存储方法的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%8C%87%E5%90%91%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">2、指向文件的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1、文件指针的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="nav-text">2.2、打开与关闭文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-text">3、顺序读写文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-text">3.1、字符输入和输出函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-text">3.2、字符串输入和输出函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%81%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0"><span class="nav-text">3.3、文件格式化输入和输出函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4%E3%80%81%E4%BB%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-text">3.4、以二进制的形式读写数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-text">4、随机读写文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E3%80%81%E5%BC%BA%E5%88%B6%E4%BD%BF%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4"><span class="nav-text">4.1、强制使文件指针指向文件开头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E3%80%81%E4%BD%BF%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE"><span class="nav-text">4.2、使文件指针指向文件中的任意位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%BA%E9%94%99%E6%A3%80%E6%B5%8B"><span class="nav-text">5、文件的出错检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E3%80%81%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%87%BA%E9%94%99%E6%A3%80%E6%B5%8B"><span class="nav-text">5.1、文件读写出错检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E3%80%81%E6%96%87%E4%BB%B6%E6%9C%AB%E5%B0%BE%E5%88%A4%E6%96%AD"><span class="nav-text">5.2、文件末尾判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E3%80%81%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%E6%A0%87%E5%BF%97"><span class="nav-text">5.3、文件错误标志</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%81%B5%E9%AD%82%E2%80%94%E2%80%94%E6%8C%87%E9%92%88"><span class="nav-text">十、C语言的灵魂——指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%EF%BC%9F"><span class="nav-text">1、什么是指针？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="nav-text">2、指针常量与指针变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-text">2.1、指针常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="nav-text">2.2、指针变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">3、指针变量作为函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%BA%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">3.1、函数参数为指针类型的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="nav-text">3.2、指针函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E6%95%B0%E7%BB%84"><span class="nav-text">4、通过指针引用数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E3%80%81%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="nav-text">4.1、数组元素的地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E3%80%81%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="nav-text">4.2、指针指向数组元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E3%80%81%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E7%A7%BB%E5%8A%A8%EF%BC%88%E6%8C%87%E9%92%88%E7%9A%84%E5%81%8F%E7%A7%BB%EF%BC%89"><span class="nav-text">4.3、指针指向的移动（指针的偏移）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4%E3%80%81%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">4.4、指针指向字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%88%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-text">5、指向函数的指针（函数指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9F"><span class="nav-text">5.1、什么是函数指针？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.2、函数指针的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="nav-text">5.3、函数指针的初始化及使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4%E3%80%81%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%EF%BC%88%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-text">5.4、使用函数指针作为函数参数（回调函数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5%E3%80%81%E4%BD%BF%E7%94%A8typedef%E7%BB%99%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%8F%96%E5%88%AB%E5%90%8D"><span class="nav-text">5.5、使用typedef给函数指针取别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6%E3%80%81%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">5.6、指针函数和函数指针的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="nav-text">6、指针数组和数组指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1%E3%80%81%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="nav-text">6.1、指针数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2%E3%80%81%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="nav-text">6.2、数组指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="nav-text">7、指针常量与常量指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">8、动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">8.1、什么是动态内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2%E3%80%81%E6%80%8E%E6%A0%B7%E5%BB%BA%E7%AB%8B%E5%86%85%E5%AD%98%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="nav-text">8.2、怎样建立内存的动态分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-text">9、结构体指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1%E3%80%81%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">9.1、指向结构体变量的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">9.2、结构体指针的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3%E3%80%81%E9%80%9A%E8%BF%87%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98"><span class="nav-text">9.3、通过结构体指针引用结构体成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81%E5%A4%9A%E9%87%8D%E6%8C%87%E9%92%88%EF%BC%88%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-text">10、多重指针（多级指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E9%87%8D%E6%8C%87%E9%92%88"><span class="nav-text">10.1、什么是多重指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2%E3%80%81%E5%A4%9A%E9%87%8D%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">10.2、多重指针的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3%E3%80%81%E5%A4%9A%E9%87%8D%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">10.3、多重指针的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4%E3%80%81%E5%8F%8C%E9%87%8D%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82"><span class="nav-text">10.4、双重指针作为函数形参</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA"><span class="nav-text">11、内存四区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">十一、排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1、排序的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="nav-text">1.1、什么是排序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-text">1.2、排序的稳定性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">1.3、排序的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4%E3%80%81%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">1.4、排序的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">1.5、排序算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">2、冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">3、简单选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">4、直接插入排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-text">十二、顺序表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1、顺序表的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">2、顺序表的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="nav-text">3、顺序表的功能实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-text">十三、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1、链表的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8"><span class="nav-text">1.1、什么是链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">1.2、链表的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E3%80%81%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-text">1.3、链表和数组的区别：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">2、链表的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">3、单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-text">3.1、单链表结构的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.2、单链表的创建与功能实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">十四、栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1、栈和队列的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-text">2、数据结构中的栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%81%E6%A0%88-stack"><span class="nav-text">2.1、栈 (stack)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%81%E9%98%9F%E5%88%97-queue"><span class="nav-text">2.2、队列(queue)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">3、栈和队列的基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-text">3.1、栈和队列的结构示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-text">3.2、栈和队列中数据的插入和删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">4、栈和队列的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E3%80%81%E6%A0%88%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.1、栈功能的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E3%80%81%E9%98%9F%E5%88%97%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">4.2、队列功能的实现</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">小颜同学</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br>
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.2.0</a>
        </div>
        
            <div class="icp-info info-item"><a target="_blank" rel="nofollow" href="
                
                    https://beian.miit.gov.cn/
                
                ">湘ICP备2022018939号</a></div>
        
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <div class="customize-info info-item">祝你看的开心，玩的愉快！</div>
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>



    
<script src="/js/tools/localSearch.js"></script>




    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>






    
<script src="/js/libs/minimasonry.min.js"></script>

    
<script src="/js/plugins/masonry.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/tools/tocToggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
