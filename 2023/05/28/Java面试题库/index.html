<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="小颜同学">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://yan-tongxue/github.io/2023/05/28/java面试题库/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="一，基础1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？Java的数据类型：基本数据类型和引用数据类型        基本数据类型：byte（1），short（2），int（4），long（8），float（4），double（8），char（2），boolean（1）        引用数据类型：类，接口，数组 2、Java语言的几大特性是什么？分">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题库">
<meta property="og:url" content="https://yan-tongxue/github.io/2023/05/28/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/index.html">
<meta property="og:site_name" content="忘忧Studio">
<meta property="og:description" content="一，基础1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？Java的数据类型：基本数据类型和引用数据类型        基本数据类型：byte（1），short（2），int（4），long（8），float（4），double（8），char（2），boolean（1）        引用数据类型：类，接口，数组 2、Java语言的几大特性是什么？分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230528111402.jpg">
<meta property="article:published_time" content="2023-05-28T03:05:48.000Z">
<meta property="article:modified_time" content="2023-05-28T07:34:33.929Z">
<meta property="article:author" content="小颜同学">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yan-tongxue.oss-cn-guangzhou.aliyuncs.com/img/20230528111402.jpg">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/logo.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/logo.png">
    <!--- Page Info-->
    
    <title>
        
            Java面试题库 -
        
        忘忧Studio
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"yan-tongxue","root":"/","language":"zh-CN","path":"search.xml"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"busuanzi_counter":{"enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"pjax":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"小颜同学的博客","subtitle":{"text":["欢迎来到我的博客啦！","Welcome to My Blog!","花会沿路盛开，你的未来也是！"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/yan-tongxue","github-alt":"https://gitee.com/Yan-Tongxue","email":"2279656909@QQ.com"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.2.0","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Github":"https://github.com/EvanNotFound/hexo-theme-redefine","Blog":"https://www.wy-studio.cn"}},"Links":{"icon":"fa-regular fa-link","submenus":{"Link1":"/link1","Link2":"/link2","Link3":"/link3"}},"相册":{"icon":"fa-solid fa-image","path":"/masonry/"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":{"文章":{"path":"/archives","icon":"fa-regular fa-archive"},"标签":{"path":"/tags","icon":"fa-regular fa-tags"},"分类":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/5/20 12:00:00"};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    Global.data_config = {"masonry":true};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/logo.png">
                </a>
            
            <a class="logo-title" href="/">
                
                忘忧Studio
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        归档
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/about">ME
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/EvanNotFound/hexo-theme-redefine">GITHUB
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://www.wy-studio.cn">BLOG
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/link1">LINK1
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/link2">LINK2
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/link3">LINK3
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/masonry/"  >
                                    
                                        
                                            <i class="fa-solid fa-image"></i>
                                        
                                        相册
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                归档
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/about">ME</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://github.com/EvanNotFound/hexo-theme-redefine">GITHUB</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://www.wy-studio.cn">BLOG</a>
                            </li>
                        
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                链接&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link1">LINK1</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link2">LINK2</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/link3">LINK3</a>
                            </li>
                        
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/masonry/"  >
                             
                                
                                    <i class="fa-solid fa-image"></i>
                                
                                相册
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">Java面试题库</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">小颜同学</span>
                            
                                <span class="author-label">Lv4</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-05-28 11:05:48</span>
        <span class="mobile">2023-05-28 11:05</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-05-28 15:34:33</span>
            <span class="mobile">2023-05-28 15:34</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E8%AE%B0%E5%BD%95%E7%AF%87/">记录篇</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Java/">Java</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>32.5k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>116 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="一，基础"><a href="#一，基础" class="headerlink" title="一，基础"></a>一，基础</h1><h2 id="1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？"><a href="#1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？" class="headerlink" title="1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？"></a>1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？</h2><p>Java的数据类型：基本数据类型和引用数据类型<br>        基本数据类型：byte（1），short（2），int（4），long（8），float（4），double（8），char（2），boolean（1）<br>        引用数据类型：类，接口，数组</p>
<h2 id="2、Java语言的几大特性是什么？分别怎么理解？-封装、继承、多态的好处"><a href="#2、Java语言的几大特性是什么？分别怎么理解？-封装、继承、多态的好处" class="headerlink" title="2、Java语言的几大特性是什么？分别怎么理解？(封装、继承、多态的好处)"></a>2、Java语言的几大特性是什么？分别怎么理解？(封装、继承、多态的好处)</h2><p>继承、封装、多态</p>
<p>继承：<br>            继承是从已有类得到继承信息新创类的过程。<br>            提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。<br>            继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p>
<p>封装：<br>            通常认为分装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。<br>            面向对象的本质就是将现实世界描绘成一系列的完全自治、封闭的对象。<br>            在类中编写的方法就是对实现细节的一种封装，编写的一个类就是对数据和数据操作的封装。<br>            可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</p>
<p>多态：<br>            多态性是指允许不同子类型的对象对同一消息做出不同的响应。<br>            简单地说就是用同样的对象引用调用同样的方法，但做了不同的事情。<br>            多态性分为编译时的多态性和运行时的多态性。<br>            如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：<br>            当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的。<br>            方法重载（overload）实现的是编译时的多态性（也就是前绑定），而方法的重写（override）实现的是运行时的  多态性（也称为后绑定）。<br>            运行时的多态时面向对象最精髓的东西，要实现多态需要做两件事：<br>            1）、方法重写（子类继承父类并重写父类中已有的或抽象的方法）<br>            2）、对象造型（用父类引用引用子类对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）</p>
<h2 id="3、Java的权限修饰符有哪些？都能加在哪些地方？分别代表什么意义？"><a href="#3、Java的权限修饰符有哪些？都能加在哪些地方？分别代表什么意义？" class="headerlink" title="3、Java的权限修饰符有哪些？都能加在哪些地方？分别代表什么意义？"></a>3、Java的权限修饰符有哪些？都能加在哪些地方？分别代表什么意义？</h2><p>Java的权限修饰符有4种：<br>            public、protected、default、private<br>        都能加在哪些地方：<br>            类、方法、成员变量<br>        分别代表的意义：<br>            public：公共的，任意位置都能访问<br>            protected：当前类、同一个包下、子类都能访问，其他包下不能访问<br>            default：当前类、同一个包下可访问，子类和其他包下不能访问<br>            private：私有的，只能当前类中访问</p>
<h2 id="4、什么是重写？什么是重载？"><a href="#4、什么是重写？什么是重载？" class="headerlink" title="4、什么是重写？什么是重载？"></a>4、什么是重写？什么是重载？</h2><p>重写：<br>            重写发生在子类和父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型；<br>            比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常<br>重载：<br>            重载发生在一个类中，同名的方法如果有不同的参数列表，则视为重载</p>
<h2 id="5、final关键字能加在哪些地方？分别代表什么？"><a href="#5、final关键字能加在哪些地方？分别代表什么？" class="headerlink" title="5、final关键字能加在哪些地方？分别代表什么？"></a>5、final关键字能加在哪些地方？分别代表什么？</h2><p>属性：属性不可变<br>方法：方法不可覆盖<br>类：被其修饰的类不可继承</p>
<h2 id="6、static关键字能加在哪些地方？分别代表什么？"><a href="#6、static关键字能加在哪些地方？分别代表什么？" class="headerlink" title="6、static关键字能加在哪些地方？分别代表什么？"></a>6、static关键字能加在哪些地方？分别代表什么？</h2><p>成员变量：使其变成静态变量，该类的所以实例都将共享此变量<br>    方法：使其变成静态方法，类加载后，便可以直接调用此方法，而不需要一个该类的实例<br>    代码块：类加载时，会执行这一段代码</p>
<h2 id="7、接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？（注意JDK1-8接口中是可以出现非抽象方法的：default方法、静态方法）"><a href="#7、接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？（注意JDK1-8接口中是可以出现非抽象方法的：default方法、静态方法）" class="headerlink" title="7、接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？（注意JDK1.8接口中是可以出现非抽象方法的：default方法、静态方法）"></a>7、接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？（注意JDK1.8接口中是可以出现非抽象方法的：default方法、静态方法）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">接口：</span><br><span class="line">    在接口类中，成员变量必须是常量，也就是final修饰的</span><br><span class="line">    接口中的方法默认都是 public abstract 都是抽象的</span><br><span class="line">抽象类：</span><br><span class="line">    抽象方法（包含）</span><br><span class="line">    成员变量（可包含，子类可以直接继承）</span><br><span class="line">    成员方法（可包含，子类可以直接继承，提高子类的功能）</span><br><span class="line">    常量（可包含，子类可以直接继承）</span><br><span class="line">    静态方法（可拥有，子类可以直接继承，抽象类的类名也可以直接调用）</span><br><span class="line">    构造方法（可包含，因为抽象类中可能包含成员变量，成员变量需要初始化和二次赋值）</span><br><span class="line">区别：</span><br><span class="line">    1、接口中不能定义构造器；抽象类中可以定义构造器</span><br><span class="line">    2、接口中方法全部都是抽象方法；抽象类中可以有抽象方法和具体方法</span><br><span class="line">    3、接口中的成员都是 public 的；抽象类中的成员可以是 private、默认、protected、public</span><br><span class="line">    4、接口中定义的成员变量实际上都是常量；抽象类中可以定义成员变量</span><br><span class="line">    5、接口中不能有静态方法；抽象类中可以包含静态方法</span><br><span class="line">    6、一个类可以实现多个接口；一个类只能继承一个抽象类</span><br></pre></td></tr></table></figure></div>

<h2 id="8、Java异常体系是什么-运行时异常和检查-编译-异常有什么区别？常见的运行时异常有哪些？"><a href="#8、Java异常体系是什么-运行时异常和检查-编译-异常有什么区别？常见的运行时异常有哪些？" class="headerlink" title="8、Java异常体系是什么? 运行时异常和检查(编译)异常有什么区别？常见的运行时异常有哪些？"></a>8、Java异常体系是什么? 运行时异常和检查(编译)异常有什么区别？常见的运行时异常有哪些？</h2><p>异常体系：<br>            Thorwable类是所以异常和错误的父类<br>            两个直接子类为 Error和 Exception ，分别表示错误和异常。<br>            其中异常类 Exception 又分为运行时异常和编译时异常<br>        运行时异常和检查(编译)异常的区别：<br>            编译时异常：<br>                是Java要求必须处理的，如果程序在编译时期未处理，该程序编译时就会发生错误无法编译，try…catch或throw抛出。<br>            运行时异常：<br>                是代码在运行是才会出现的异常，编译时不需要try…catch。<br>                如：除数是0，数组角标越界，其产生频繁，处理麻烦，若显示声明或者捕获将会对程序的可读性和运行效率影响很大。<br>                    所以由系统自动检测并将它们交给缺少的异常处理程序。如果有处理要求也可显示捕获。</p>
<h2 id="9、-x3D-x3D-和-equals的异同？"><a href="#9、-x3D-x3D-和-equals的异同？" class="headerlink" title="9、&#x3D;&#x3D; 和 equals的异同？"></a>9、&#x3D;&#x3D; 和 equals的异同？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">==：</span><br><span class="line">			== 是运算符，如果比较的对象是基本数据类型，则比较的是数值是否相等；</span><br><span class="line">			如果比较的是引用数据类型，则比较的是对象的地址值</span><br><span class="line">equals：</span><br><span class="line">			equals 是方法，用来比较两个对象的内容是否相等</span><br><span class="line">			equals 方法不能用于基本数据类型的变量，如果没有对 equals 方法进行重写，</span><br><span class="line">			则比较的是引用类型的变量所指向的对象的地址值</span><br></pre></td></tr></table></figure></div>

<h2 id="10、-amp-与-amp-amp-、-与-的区别？"><a href="#10、-amp-与-amp-amp-、-与-的区别？" class="headerlink" title="10、&amp;与&amp;&amp;、|与||的区别？"></a>10、&amp;与&amp;&amp;、|与||的区别？</h2><p>&amp;：左右两边的布尔值都是true，整个表达式的值才是true<br>        &amp;&amp;：如果左边的表达式的值为false，右边的表达式会被直接短路掉，不会进行运算，整个表达式的值就是false<br>        |：左右两边的布尔值只要有一个为true，整个表达式的值就是true<br>        ||：如果左边的表达式的值为true，右边的表达式会被直接短路掉，不会进行运算，整个表达式的值就是true</p>
<h2 id="11、String可以修改本身吗？为什么？"><a href="#11、String可以修改本身吗？为什么？" class="headerlink" title="11、String可以修改本身吗？为什么？"></a>11、String可以修改本身吗？为什么？</h2><p>不可以<br>        字符串内部其实就是一个使用final关键字定义的char[]数组，数组长度一档声明则不可改变<br>        字符串一旦声明则不可改变，变的只是引用变量所指向的对象</p>
<h2 id="12、StringBuffer和StringBuilder的区别是什么？"><a href="#12、StringBuffer和StringBuilder的区别是什么？" class="headerlink" title="12、StringBuffer和StringBuilder的区别是什么？"></a>12、StringBuffer和StringBuilder的区别是什么？</h2><p>StringBuilder实在单线程环境下使用的，因为它的使用方法都没有被 synchronized 修饰，因此理论上它的效率比 StringBuffer 高</p>
<h2 id="13、valueOf和toString的区别？"><a href="#13、valueOf和toString的区别？" class="headerlink" title="13、valueOf和toString的区别？"></a>13、valueOf和toString的区别？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toString：变换的值是 null 的情况，则会抛出 NullPointerException 异常</span><br><span class="line">valueOf：会首先对转换的对象进行非空判断，如果为 null 则返回 &quot;null&quot; 字符串，</span><br><span class="line">以至于不抛出 NullPointerException 异常</span><br></pre></td></tr></table></figure></div>

<h2 id="14、大量字符串用-“-”-号进行拼接效率高吗？为什么？应该用什么替代？为什么？"><a href="#14、大量字符串用-“-”-号进行拼接效率高吗？为什么？应该用什么替代？为什么？" class="headerlink" title="14、大量字符串用 “+” 号进行拼接效率高吗？为什么？应该用什么替代？为什么？"></a>14、大量字符串用 “+” 号进行拼接效率高吗？为什么？应该用什么替代？为什么？</h2><p>不高<br>        大量字符串用 “+” 号进行拼接，每次拼接一次都会创建一个 StringBuilder 对象，时间和空间开销太大<br>        大量字符串拼接可以使用 StringBuilder 中的 append() 方法代替<br>        append( )方法其实是创建了一个新的数组，扩大了长度，将需要添加的字符串给复制到这个新的数组中</p>
<h2 id="15、创建一个类的实例都有哪些办法？"><a href="#15、创建一个类的实例都有哪些办法？" class="headerlink" title="15、创建一个类的实例都有哪些办法？"></a>15、创建一个类的实例都有哪些办法？</h2><p>1、new 关键字。工厂模式是对这种方式的包装<br>        2、类实现克隆接口，克隆一个实例<br>        3、用该类的加载器，newinstance()方法。反射，反射使用实例：Spring的依赖注入、切面编程中的动态代理<br>        4、sun.misc。Unsafe类，allocateInstance()方法创建一个实例<br>        5、实现序列化接口的类，通过IO流反序列化读取一个类，获得实例</p>
<h2 id="16、Java集合的体系是什么样的？"><a href="#16、Java集合的体系是什么样的？" class="headerlink" title="16、Java集合的体系是什么样的？"></a>16、Java集合的体系是什么样的？</h2><p>Java集合的体系分为两大部分：Collection 和 Map<br>        Collection 接口下常见的子类有 List、Set 接口<br>            List 接口下有 ArrayList、LinkedList 等实现类<br>            Set 接口下有 HashSet、LinkedHashSet、TreeSet 等实现类<br>        Map 接口下有 HashMap、TreeMap、Hashtable 等实现类</p>
<h2 id="17、Set和List分别有哪些特点？Set去重的原理？"><a href="#17、Set和List分别有哪些特点？Set去重的原理？" class="headerlink" title="17、Set和List分别有哪些特点？Set去重的原理？"></a>17、Set和List分别有哪些特点？Set去重的原理？</h2><p>List 中存储的数据是有顺序，并且允许重复；Set 中存储的数据是无序的，且不允许有重复<br>        Set的去重是通过 hash 和 eq 结合实现的<br>            当两个变量的哈希值不相同时，就认为这两个变量不同<br>            当两个变量哈希值一样时，调用 eq 方法，放返回值为 true 时，去除一个；返回 false 时，不去重</p>
<h2 id="18、ArrayList底层原理是什么？扩容原理？"><a href="#18、ArrayList底层原理是什么？扩容原理？" class="headerlink" title="18、ArrayList底层原理是什么？扩容原理？"></a>18、ArrayList底层原理是什么？扩容原理？</h2><p>构造方法：<br>            空参构造：new 一个空参 ArrayList 的时候，系统内部使用了一个 new Object[0]数组<br>            带参构造1：传入一个 int 值，该值作为数组的长度值。如果该值小于0，则抛出一个运行时异常。<br>                       如果等于0，则使用一个空数组。如果大于0，则创建一个长度为该值的新数组<br>            带参构造2：如果调用构造方法时传入了一个 Collection 的子类，那么先判断该集合是否为null，为null则抛出空指针异常。<br>                       如果不是null则将该集合转为数组a，然后将该数组赋值为成员变量array，将该数组的长度作为成员变量size。<br>        add 方法：<br>            1、首先将成员变量 array 赋值给局部变量 a，将成员变量 size 赋值给局部变量 s<br>            2、判断集合长度 s 是否等于数组的长度（如果集合的长度已经等于数组的长度了，说明数组已满，该重新分配新数组了），<br>               重新分配数组的时候需要计算新分配内存的空间大小，如果当前的长度小于 MIN_CAPACITY_INCREMENT&#x2F;2 ，<br>               （这个常量值是12，除以2就是6，也就是如果当前集合长度小于6）则分配12个长度，如果集合长度大于6则分配当前长度s的一半<br>            3、将新添加的 object 对象作为数组的 a[s] 个元素<br>            4、修改集合长度 size 为 s+1<br>            5、modCotun++，该变量是父类中声明的，用于记录集合修改的次数，<br>               记录集合修改的次数是为了在用迭代器迭代集合时避免并发修改异常，或者说用于判断是否出现并发修改异常的<br>            6、return true，这个返回值意义不大，因为一直返回true，除非报了一个运行时异常<br>        remove 方法：<br>            1、先将成员变量 array 和 size 赋值给局部变量 a 和 s<br>            2、判断形参 index 是否大于等于集合的长度，如果成立则抛出运行时异常<br>            3、获取数组中角标为 index 的对象 result，该对象作为方法的返回值<br>            4、调用 System 的 arraycopy 方法，将删除的元素后面的所有元素全部往前移一位<br>            5、因为删了一个元素，而且集合整体向前移动了一位，因此要将集合最后一个元素置为 null，否则就会内存泄漏<br>            6、重新给成员变量 array 和 size 赋值<br>            7、记录修改次数<br>            8、返回删除的元素<br>        clear 方法：<br>            如果集合长度不等于0，则将数组所有的值都为 null，然后将成员变量 size 设置为0，最后将修改记录加1</p>
<h2 id="19、LinkedList底层原理是什么？和ArrayList的区别是什么？"><a href="#19、LinkedList底层原理是什么？和ArrayList的区别是什么？" class="headerlink" title="19、LinkedList底层原理是什么？和ArrayList的区别是什么？"></a>19、LinkedList底层原理是什么？和ArrayList的区别是什么？</h2><p>LinkedList底层原理：<br>            LinkedList 的底层是通过双向链表实现的。<br>            链表的单元是节点，链表由多个节点构成，每个节点都包含三个部分，<br>            头节点指向上一个节点的尾节点，中间节点指向该节点，尾节点指向下一个节点的头节点<br>        和ArrayList的区别：<br>            1、数据结构实现：ArrayList是动态数组的数据结构实现；LinkedList是双向链表的数据结构实现<br>            2、随机访问效率：ArrayList比LinkedList在随机访问的时候效率要高，<br>                             因为LinkedList是线性的数据存储方式，使用需要移动指针从前向后一次查找<br>            3、增加和删除效率：在非首尾的增删操作，LinkedList要比ArarryList的效率高，因为ArrayList增删操作要影响数组内其他数据的角标<br>            综合来说，在需要频繁读取集中的元素时，更推荐使用ArrayList，而在增删操作比较多时，更加推荐使用LinkedList</p>
<h2 id="20、HashMap的底层原理是什么？扩容原理？"><a href="#20、HashMap的底层原理是什么？扩容原理？" class="headerlink" title="20、HashMap的底层原理是什么？扩容原理？"></a>20、HashMap的底层原理是什么？扩容原理？</h2><p>HashMap的底层采用了一个数组，该数组的默认大小为16且每一个元素都是一个链表的头节点，<br>        每当添加一个元素，就先计算元素Key的hash值，以此确定存放在数组的位置，<br>        如果出现了同一hash值的元素时，这时新元素就会挂在老元素的下面，形成链表，<br>        当链表的长度太长，大于8时，链表就会转换为红黑树，就能提高查找的效率<br>        扩容阈值：<br>            当前容量 * 加载因子 &#x3D; 阈值，默认的加载因子为0.75<br>        扩容的机制：<br>            当数组中的元素达到阈值时，第一次扩容即16 * 0.75 &#x3D; 12时，就会触发扩容机制，扩大到元素组的2倍<br>        加载因子：<br>            - 加载因子的大小决定了HashMap的数据密度。<br>            - 加载因子越大HashMap的数据密度也大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入的次数增多，性能下降。<br>            - 加载因子越小，就越容易触发扩容，数据密度也就越小，发生碰撞的几率越小，数组中的链表就越短，查询和插入时比较的次数也越小，<br>              性能会更高，但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预留大一点的空间。<br>            - 所以会将加载因子设置为0.7-0.75，此时平均检索长度接近于常数。</p>
<h2 id="21、concurrentHashMap原理是什么？"><a href="#21、concurrentHashMap原理是什么？" class="headerlink" title="21、concurrentHashMap原理是什么？"></a>21、concurrentHashMap原理是什么？</h2><p>底层采用分段的数组+链表实现，线程安全<br>        通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。<br>        Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术<br>        有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁<br>        扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容</p>
<h2 id="22、JDK8对于HashMap做了哪些优化？"><a href="#22、JDK8对于HashMap做了哪些优化？" class="headerlink" title="22、JDK8对于HashMap做了哪些优化？"></a>22、JDK8对于HashMap做了哪些优化？</h2><p>JDK8之前采用的是数组加链表，JDK8之后采用的是数据加链表加红黑树</p>
<h2 id="23、什么是socket？什么是IO-x2F-NIO-x2F-BIO-x2F-AIO？区别是什么？"><a href="#23、什么是socket？什么是IO-x2F-NIO-x2F-BIO-x2F-AIO？区别是什么？" class="headerlink" title="23、什么是socket？什么是IO&#x2F;NIO&#x2F;BIO&#x2F;AIO？区别是什么？"></a>23、什么是socket？什么是IO&#x2F;NIO&#x2F;BIO&#x2F;AIO？区别是什么？</h2><p>socket：<br>            socket是一个接口，在用户进程与TCP&#x2F;IP协议之间充当中间人，完成TCP&#x2F;IP协议的书写<br>        IO：<br>            在Java中，用流的方式完成IO。<br>            所有IO都被视为单个的字节的移动，通过一个称为Stream的对象一次移动一个字节。<br>            流I&#x2F;O用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。<br>        NIO：<br>             NIO不需要为每个连接开启一个线程，而是统一由Selector管理，当连接没有IO操作时，不需要阻塞线程等待数据，<br>             只有当Selector检测到呢个Channel有有效的IO请求时，再为其开启线程操作，节省线程的开销，操作结束后返回结果，故为同步非阻塞。<br>        BIO：<br>            在BIO通信模式下，服务端每收到一个链接（socket），就会创建专门的线程（serverssocket）响应该连接。<br>            这个连接会一直存在等待读取发来的数据，这个过程会阻塞搜在线程，不能做别的事，直到操作结束后返回结果值，因此这是同步阻塞。<br>            BIO模式下，服务端连接多个客户端时，会开启多个线程响应连接。<br>        AIO：<br>            没有线程阻塞，与AIO不同的是NIO会主动轮询操作系统数据是否准备完毕，而AIO则是等待系统主动通知，再去读取数据</p>
<h2 id="24、什么是反射？可以用来干嘛？列举一下反射应用场景？什么是暴力反射？"><a href="#24、什么是反射？可以用来干嘛？列举一下反射应用场景？什么是暴力反射？" class="headerlink" title="24、什么是反射？可以用来干嘛？列举一下反射应用场景？什么是暴力反射？"></a>24、什么是反射？可以用来干嘛？列举一下反射应用场景？什么是暴力反射？</h2><p>反射：<br>            反射的核心是 JVM 在运行时才动态加载类或调用方法&#x2F;访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁<br>            Java 中的反射首先是能够获取到 Java 中要反射类的字节码，获取字节码有三种方法：<br>            1、Class.forName(className)        2、类名.class    3、this.getClass()<br>            然后将字节码中的方法，变量，构造函数等映射成相应的Method，Filed，Constructor等类，这些类中提供了丰富的方法供使用<br>        反射的作用：<br>            1、在运行时判定任意一个对象的所属类<br>            2、在运行时构造任意一个类的对象<br>            3、在运行时判定任意一个类所有具有的成员变量和方法<br>            4、在运行时调用任意一个对象的方法<br>            5、生成动态代理<br>        应用场景：<br>            反射最重要的用途就是开发各种通用框架。<br>            很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，<br>            它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。<br>        暴力反射：<br>            反射里的Constructor,Field,Method三个类都有一个 getDeclaredXxx 方法,<br>            可以不受权限控制的获取类的构造函数,字段,方法,如果想要私有构造函数创建对象,字段赋值,方法调用的话,<br>            会自动的访问类的isAccessable,默认的是false,<br>            所以,想要访问类中的私有成员的时候,就要调用setAccessable()方法,将其改为true,这样,就可以对类中的私有成员进行操作了</p>
<h2 id="25、算法了解过吗？冒泡排序、选择排序、快排原理？"><a href="#25、算法了解过吗？冒泡排序、选择排序、快排原理？" class="headerlink" title="25、算法了解过吗？冒泡排序、选择排序、快排原理？"></a>25、算法了解过吗？冒泡排序、选择排序、快排原理？</h2><p>冒泡排序：<br>            1、比较相邻的元素。如果第一个比第二个大，就交换它们两个；<br>            2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；<br>            3、针对所有的元素重复以上的步骤，除了最后一个；<br>            4、重复步骤1~3，直到排序完成。<br>        选择排序：<br>            首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，<br>            然后，再从剩余未排序元素中继续寻找最小(大)元素，再放到已排序序列的末尾。<br>            以此类推，直到所有元素均排序完毕<br>        快速排序：<br>            1、从数列中挑出一个元素，称为 “基准”(pivot)；<br>            2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。<br>               在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作；<br>            3、递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<h2 id="26、JDK1-8的新特性有哪些-lamda表达式、stream流、函数式接口、接口中默认方法、方法引用等等"><a href="#26、JDK1-8的新特性有哪些-lamda表达式、stream流、函数式接口、接口中默认方法、方法引用等等" class="headerlink" title="26、JDK1.8的新特性有哪些?(lamda表达式、stream流、函数式接口、接口中默认方法、方法引用等等)"></a>26、JDK1.8的新特性有哪些?(lamda表达式、stream流、函数式接口、接口中默认方法、方法引用等等)</h2><p>Lambda表达式，函数式接口，方法引用和构造器调用，Stream API，接口中的默认方法和静态方法，新时间日期API</p>
<h2 id="27、IO流体系"><a href="#27、IO流体系" class="headerlink" title="27、IO流体系"></a>27、IO流体系</h2><p>1、按流向分：<br>            输入流：程序可以从内存中读取数据的流<br>            输出流：程序可以向磁盘中写入数据的流<br>        2、按数据传输单位分：<br>            字节流：以字节为单位传输数据的流<br>            字符流：以字符为单位传输数据的流</p>
<h2 id="28、如何实现分布式主键自增？"><a href="#28、如何实现分布式主键自增？" class="headerlink" title="28、如何实现分布式主键自增？"></a>28、如何实现分布式主键自增？</h2><p>Redis和IdWork工具类</p>
<h1 id="二、JVM"><a href="#二、JVM" class="headerlink" title="二、JVM"></a>二、JVM</h1><h2 id="1、JDK和JRE的区别是什么？"><a href="#1、JDK和JRE的区别是什么？" class="headerlink" title="1、JDK和JRE的区别是什么？"></a>1、JDK和JRE的区别是什么？</h2><p>JDK：开发工具<br>JRE：运行时环境</p>
<h2 id="2、JVM内存模型是什么样的？"><a href="#2、JVM内存模型是什么样的？" class="headerlink" title="2、JVM内存模型是什么样的？"></a>2、JVM内存模型是什么样的？</h2><p>1、线程隔离私有数据区<br>            1、程序计数器<br>            2、栈<br>                1、线程栈<br>                2、本地方法栈<br>        2、线程数据共享区<br>            1、堆<br>                1、新生代区<br>                2、老年代区<br>            2、方法区</p>
<h2 id="3、JVM双亲委派加载机制，为什么JVM这么做？有违反双亲委派的例子吗？"><a href="#3、JVM双亲委派加载机制，为什么JVM这么做？有违反双亲委派的例子吗？" class="headerlink" title="3、JVM双亲委派加载机制，为什么JVM这么做？有违反双亲委派的例子吗？"></a>3、JVM双亲委派加载机制，为什么JVM这么做？有违反双亲委派的例子吗？</h2><p>双亲委派加载机制：<br>            加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，<br>            如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类<br>        为什么JVM这么做：<br>            1、可以防止核心API库被随意篡改<br>            2、避免类的重复加载：当父亲已经加载了该类时，就没有必要子 ClassLoader 再加载一次，保证被加载类的唯一性<br>        违反双亲委派的例子：<br>            服务供应商接口 SPI，常见的 SPI 有 JDBC、JNDI、JAXP 等</p>
<h2 id="4、类的加载流程是什么样的，每个阶段解释一下"><a href="#4、类的加载流程是什么样的，每个阶段解释一下" class="headerlink" title="4、类的加载流程是什么样的，每个阶段解释一下"></a>4、类的加载流程是什么样的，每个阶段解释一下</h2><p>1、加载：<br>            通过一个类的全限定名获取该类的二进制流；<br>            将该二进制流的静态存储结构转化为方法区运行时数据结构；<br>            在内存中生成该类的Class对象，作为该类的数据访问入口；<br>        2、链接:<br>            验证：验证的目的是为了确保Class文件的字节流中的信息不会危害到虚拟机；<br>            准备：准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。<br>                  准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<br>            解析：主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。<br>        3、初始化：<br>            初始化是类加载的最后一步，真正开始执行类中定义的Java程序代码</p>
<h2 id="5、JVM的GC的主要区域以及各自的GC机制是什么样的？"><a href="#5、JVM的GC的主要区域以及各自的GC机制是什么样的？" class="headerlink" title="5、JVM的GC的主要区域以及各自的GC机制是什么样的？"></a>5、JVM的GC的主要区域以及各自的GC机制是什么样的？</h2><p>GC的主要区域：<br>            堆内存<br>        各自的GC机制：<br>            新生代区：Minor GC<br>                1、当Eden区满了时，触发一次MG，即：<br>                    还存活的对象从Eden或者Survivor From&#x2F;Survivor To区中用copy复制算法移至Survivor To&#x2F;Survivor From区中<br>                    Eden中剩下的待回收的对象进行回收，且存活对象的MG次数+1，当对象上的MG次数大于15次时，该对象将会移至老年代区<br>                2、JVM每次只会使用Eden和其中的一块Suivivor区域来为对象服务，所以无论什么时候，总是有一块Survivor区域是空闲的<br>                   因此，新生代实际可用的内存空间为90%的新生代空间，所以这种回收机制是比较浪费内存的，优点是简单高效<br>            老年代区：Full GC<br>                当老年代没有内存空间容纳新进来的对象时，触发一次FG，即：<br>                    1、首先stop the world：暂停GC回收线程外的所有线程；<br>                    2、然后使用标记-清除&#x2F;整理算法，标记出</p>
<h2 id="6、JVM的GC算法都有哪些？"><a href="#6、JVM的GC算法都有哪些？" class="headerlink" title="6、JVM的GC算法都有哪些？"></a>6、JVM的GC算法都有哪些？</h2><p>1、确定哪些是垃圾的算法：<br>            1、引用计数法：<br>                每被引用一次，引用次数+1， 弊端：无法解决对象相互循环引用而无法被回收问题<br>            2、GC Root可达性算法：<br>                从根节点出发，给所有可达对象做标记（解决对象相互循环引用而无法被回收问题）<br>                Java中可作为GC Root的对象有：<br>                    1、虚拟机栈中引用的对象（本地变量表）<br>                    2、方法区中静态属性引用的对象<br>                    3、方法区中常量引用的对象<br>                    4、本地方法栈中引用的对象（Native对象）<br>        2、最终回收垃圾的算法<br>            1、标记-清除：效率较高，但最后得到的内存空间不连续<br>            2、标记-整理：最后得到的内存空间是连续的，但整理压缩耗费性能，效率较低<br>            3、复制算法：将内存空间分为两块，每次只使用其中的一块，回收时，将存活的对象复制到另一块中，简单高效，但是浪费内存空间<br>            针对以上的回收算法的利弊，引出分代算法，新生代区使用复制算法，老年代区使用标记-清除&#x2F;标记-整理算法</p>
<h1 id="三、Spring-amp-SpringBoot"><a href="#三、Spring-amp-SpringBoot" class="headerlink" title="三、Spring &amp; SpringBoot"></a>三、Spring &amp; SpringBoot</h1><h2 id="1、说下对SpringIOC的理解，怎么理解控制反转？IOC容器中Bean的生命周期？"><a href="#1、说下对SpringIOC的理解，怎么理解控制反转？IOC容器中Bean的生命周期？" class="headerlink" title="1、说下对SpringIOC的理解，怎么理解控制反转？IOC容器中Bean的生命周期？"></a>1、说下对SpringIOC的理解，怎么理解控制反转？IOC容器中Bean的生命周期？</h2><p>IOC：<br>            是spring的核心，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在对象内部直接控制<br>        控制反转：<br>            所有的类都会在spring容器中登记，告诉spring你是什么，你需要什么，然后spring会在系统运行到适当的时候，把你要的东西主动给你，<br>            同时也把你交给其他需要你的东西。<br>            所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。<br>            对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转<br>        生命周期：<br>            1、通过构造器或工厂方法创建Bean的实例<br>            2、为Bean的属性赋值或对其他Bean的引用<br>            3、调用Bean的初始化方法<br>            4、使用Bean<br>            5、当容器关闭时，调用Bean的销毁方法</p>
<h2 id="2、Spring如何解决IOC中的循环依赖问题？"><a href="#2、Spring如何解决IOC中的循环依赖问题？" class="headerlink" title="2、Spring如何解决IOC中的循环依赖问题？"></a>2、Spring如何解决IOC中的循环依赖问题？</h2><p>三级缓存。<br>        比如说：<br>            实例化A的时候，先将A创建（早期对象）放入一个池子中。<br>            这个时候虽然属性没有赋值，但是容器已经能认识这个是A对象，只是属性全是null而已。在<br>            populateBean 方法中对属性赋值的时候，发现A依赖了B，那么就先去创建B了，又走一遍bean的创建过程（创建B）。<br>            同样也会把B的早期对象放入缓存中。<br>            当B又走到 populateBean 方法的时候，发现依赖了A，<br>            又去创建A，但是这个时候去创建A，发现我们在缓存能找到A（早期对象）。<br>            就可以把B的A属性赋值了，这个时候B就初始化完成了。<br>            现在回到A调用的populateBean方法中。<br>            返回的就是B对象了，对A的B属性进行赋值就可以了。</p>
<h2 id="3、说下对SpringAOP的理解、有哪些通知？使用场景有哪些？（底层原理：两种动态代理）"><a href="#3、说下对SpringAOP的理解、有哪些通知？使用场景有哪些？（底层原理：两种动态代理）" class="headerlink" title="3、说下对SpringAOP的理解、有哪些通知？使用场景有哪些？（底层原理：两种动态代理）"></a>3、说下对SpringAOP的理解、有哪些通知？使用场景有哪些？（底层原理：两种动态代理）</h2><p>AOP 面向切面编程：<br>            将与业务无关，却为业务模块所共同调用的逻辑封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于可操作性和可维护性<br>        有哪些通知：<br>            1、前置通知：在目标方法执行之前执行执行的通知<br>            2、环绕通知：在目标方法执行之前和之后都可以执行额外代码的通知<br>            3、后置通知：在目标方法执行之后执行的通知<br>            4、异常通知：在目标方法抛出异常时执行的通知<br>            5、最终通知：最终通知无论如何都会在目标方法调用过后执行，即使目标方法没有正常的执行完成<br>        使用场景有哪些：<br>            事务、日志、缓存</p>
<h2 id="4、说下SpringMvc的流程（从访问一个URL到得到页面结果的具体流程：DispatcherServlet的职责流程）"><a href="#4、说下SpringMvc的流程（从访问一个URL到得到页面结果的具体流程：DispatcherServlet的职责流程）" class="headerlink" title="4、说下SpringMvc的流程（从访问一个URL到得到页面结果的具体流程：DispatcherServlet的职责流程）"></a>4、说下SpringMvc的流程（从访问一个URL到得到页面结果的具体流程：DispatcherServlet的职责流程）</h2><p>1、用户发送请求至前端控制器DispatcherServlet<br>        2、前端控制器DispatcherServlet收到请求调用HandlerMapping处理器映射器<br>        3、处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)，一并返回给DispatcherServlet<br>        4、DispatcherServlet调用HandlerAdapter处理器适配器<br>        5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)<br>        6、Controller执行完成返回ModelAndView<br>        7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet<br>        8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器<br>        9、ViewReslover解析后返回具体View<br>        10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）<br>        11、DispatcherServlet响应用户</p>
<h2 id="5、对Spring声明式事务的理解？Spring的事务隔离级别？Spring事务传播行为？"><a href="#5、对Spring声明式事务的理解？Spring的事务隔离级别？Spring事务传播行为？" class="headerlink" title="5、对Spring声明式事务的理解？Spring的事务隔离级别？Spring事务传播行为？"></a>5、对Spring声明式事务的理解？Spring的事务隔离级别？Spring事务传播行为？</h2><p>理解：<br>            Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的<br>        Spring的事务隔离级别：<br>            默认、读未提交、读已提交、可重复读、串行化<br>        Spring事务传播行为：<br>            1、required（默认属性）<br>                如果存在一个事务，则支持当前事务，如果没有事务，则开启一个新的事务<br>            2、Mandatory<br>                支持当前事务，如果当前没有事务，就抛出异常<br>            3、Never<br>                以非事务方式执行，如果当前存在事务，则抛出异常<br>            4、Not_supports<br>                以非事务方式执行操作，如果当前存在事务，把当前事务挂起<br>            5、requires_new<br>                新建事务，如果当前存在事务，则把当前事务挂起<br>            6、Supports<br>                支持当前事务，如果当前没有事务，就以非事务方式执行<br>            7、Nested<br>                支持当前事务，新增Savepoint点，与当前事务同步提交或者回滚</p>
<h2 id="6、什么情况下会让spring事务失效"><a href="#6、什么情况下会让spring事务失效" class="headerlink" title="6、什么情况下会让spring事务失效"></a>6、什么情况下会让spring事务失效</h2><p>1、发生自调用，类里面使用this调用本类中的方法，此时这个this不是代理对象，所以事务失效<br>        2、方法不是public的<br>        3、数据库不支持事务<br>        4、没有被spring管理<br>        5、异常被try、catch，事务不会回滚</p>
<h2 id="7、Spring有哪些核心注解？分别的作用？"><a href="#7、Spring有哪些核心注解？分别的作用？" class="headerlink" title="7、Spring有哪些核心注解？分别的作用？"></a>7、Spring有哪些核心注解？分别的作用？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller：Web控制器模式注解</span><br><span class="line">@Service：服务模式注解</span><br><span class="line">@Configuration：配置类模式注解</span><br><span class="line">@Component：通用组件模式注解</span><br><span class="line">@Autowired：    Bean依赖注入，支持多种依赖查找方式</span><br><span class="line">@Bean：替换XML元素&lt;bean/&gt;</span><br><span class="line">@Import：限定@Autowired依赖注入范围(导入对应的 @Configuration 标识类)</span><br><span class="line">@ComponentScan：扫描制定package下标注Spring模式注解的类</span><br></pre></td></tr></table></figure></div>

<h2 id="8、Spring和SpringBoot的关系？"><a href="#8、Spring和SpringBoot的关系？" class="headerlink" title="8、Spring和SpringBoot的关系？"></a>8、Spring和SpringBoot的关系？</h2><p>Spring Boot不是一门新技术。从本质上来说，Spring Boot就是Spring，它做了一些对Spring Bean的默认配置。<br>        它消除了设置 Spring 应用程序所需的 XML配置，为更快，更高效的开发生态系统铺平了道路。</p>
<h2 id="9、SpringBoot的自动装配原理是什么？"><a href="#9、SpringBoot的自动装配原理是什么？" class="headerlink" title="9、SpringBoot的自动装配原理是什么？"></a>9、SpringBoot的自动装配原理是什么？</h2><p>@EnableAutoConfiguration 这个注解通过 @springbootapplication 这个注解被间接的标记在了springboot的启动类上，<br>        在springapplication.run(…)的内部就会执行selectimports()方法，<br>        找到所有javaconfig自动配置类的全限定类名对应的class，然后将所有的自动配置类加载到spring容器中</p>
<h2 id="10、SpringBoot的核心注解是哪个？详细说下"><a href="#10、SpringBoot的核心注解是哪个？详细说下" class="headerlink" title="10、SpringBoot的核心注解是哪个？详细说下"></a>10、SpringBoot的核心注解是哪个？详细说下</h2><p>核心注解是@SpringBootApplication，它主要由 @SpringBootConfiguration，@EnableAutoConfiguration、@ComponentScan 这三个构成<br>            @SpringBootConfiguration：<br>                里面就只有一个 @Configuration 主要注解，也就是把该类变成一个配置类所以 @SpringBootConfiguration 就相当于 @Configuration<br>            @EnableAutoConfiguration：<br>                是由 @AutoConfigurationPackage 和 @Import(EnableAutoConfigurationImportSelector.class) 这两个组成的<br>                    @AutoConfigurationPackage ：<br>                        是自动配置包，包括了一个@Import注解，给容器导入了自动配置包的注册器<br>                        AutoConfigurationPackages.Registrar.class：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器<br>                    @Import(AutoConfigurationImportSelector.class)：<br>                        导入自动配置导入选择器组件<br>                        AutoConfigurationImportSelector.class：自动配置导入选择器，主要是从类路径下的META-INF&#x2F;spring.factories中获取资源<br>            @ComponentScan：扫描包，该注解默认会扫描该类所在的包下所有的配置类</p>
<h2 id="11、SpringBoot项目的启动加载流程大概说下"><a href="#11、SpringBoot项目的启动加载流程大概说下" class="headerlink" title="11、SpringBoot项目的启动加载流程大概说下"></a>11、SpringBoot项目的启动加载流程大概说下</h2><p>第一部分：<br>            SpringApplication初始化模块，配置一些基本的环境变量、资源、监听器、构造器<br>        第二部分：<br>            实现了应用具体的启动方案，包括流程的监听模块，加载配置环境模块以及上下文环境模块<br>        第三部分：<br>            自动化配置模块，这个模块是实现SpringBoot的自动装配</p>
<h2 id="12、SpringBoot项目读取配置文件的方式有几种？"><a href="#12、SpringBoot项目读取配置文件的方式有几种？" class="headerlink" title="12、SpringBoot项目读取配置文件的方式有几种？"></a>12、SpringBoot项目读取配置文件的方式有几种？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value</span><br><span class="line">    @ConfigurationProperties</span><br></pre></td></tr></table></figure></div>

<h2 id="13、如何自定义SpringBoot-starter？"><a href="#13、如何自定义SpringBoot-starter？" class="headerlink" title="13、如何自定义SpringBoot starter？"></a>13、如何自定义SpringBoot starter？</h2><p>1、引入 SpringBoot 自动化配置依赖<br>        2、创建配置属性类<br>        3、创建 Starter 包的服务类<br>        4、创建自动配置类<br>        5、配置 spring.factories</p>
<h1 id="四、Mysql-amp-Mybatis？"><a href="#四、Mysql-amp-Mybatis？" class="headerlink" title="四、Mysql &amp; Mybatis？"></a>四、Mysql &amp; Mybatis？</h1><h2 id="1、什么是索引？"><a href="#1、什么是索引？" class="headerlink" title="1、什么是索引？"></a>1、什么是索引？</h2><p>本质是帮助MySQL高效获取数据的数据结构</p>
<h2 id="2、Mysql的数据结构是什么（mysql索引的数据结构）？为什么用这种结构？（如何提高磁盘IO效率）"><a href="#2、Mysql的数据结构是什么（mysql索引的数据结构）？为什么用这种结构？（如何提高磁盘IO效率）" class="headerlink" title="2、Mysql的数据结构是什么（mysql索引的数据结构）？为什么用这种结构？（如何提高磁盘IO效率）"></a>2、Mysql的数据结构是什么（mysql索引的数据结构）？为什么用这种结构？（如何提高磁盘IO效率）</h2><p>Mysql的数据结构：<br>            MySql中主要应用的索引数据结构为B+Tree<br>        为什么用这种结构：<br>            由于数据存储于物理磁盘，所以要尽量减少从磁盘IO数据的次数<br>            IO次数取决于B+Tree的高度<br>            B+Tree把真实的数据放到叶子节点，数据项占的空间越小，数据项的数量越多，树的高度越低</p>
<h2 id="3、Mysql的数据IO查找流程是什么样的？"><a href="#3、Mysql的数据IO查找流程是什么样的？" class="headerlink" title="3、Mysql的数据IO查找流程是什么样的？"></a>3、Mysql的数据IO查找流程是什么样的？</h2><p>1、对于聚集索引（主键索引）来说，也就是通过主键查询，一次查询就能查询到具体的行数据信息；<br>        2、对于非聚集索引来说（唯一索引、普通索引、全文索引），<br>        如果需要查询的数据列在索引中，如A+B联合索引，根据A去查询B，则通过一次查询就能直接拿到索引上的数据，也就是覆盖索引现象；<br>        如果需要查询的数据不在索引中，则需要先去普通索引树中进行第一次查找得到行数据的主键值，<br>        然后通过主键值去主键索引树中第二次搜索得到真实数据，这种需要二次查询的现象叫做回表查询</p>
<h2 id="4、B-tree和Btree由什么组成？他们的异同？"><a href="#4、B-tree和Btree由什么组成？他们的异同？" class="headerlink" title="4、B+tree和Btree由什么组成？他们的异同？"></a>4、B+tree和Btree由什么组成？他们的异同？</h2><p>异同：<br>            1、B+tree是Btree的变体<br>            2、在Btree的基础上增加了叶子节点的顺序访问指针，B+Tree提高了顺序访问的性能<br>            3、Btree每个节点的指针上限为2d+1，B+Tree每个节点的指针上限为2d<br>            4、B+Tree非叶子节点只存储索引值，叶子节点存储真实数据，Btree所有节点上都存储数据</p>
<h2 id="5、Mysql两种存储引擎（InnoDB和Mysiam）的区别？这两种引擎B-tree的叶子结点和非叶子结点分别存储的什么？"><a href="#5、Mysql两种存储引擎（InnoDB和Mysiam）的区别？这两种引擎B-tree的叶子结点和非叶子结点分别存储的什么？" class="headerlink" title="5、Mysql两种存储引擎（InnoDB和Mysiam）的区别？这两种引擎B+tree的叶子结点和非叶子结点分别存储的什么？"></a>5、Mysql两种存储引擎（InnoDB和Mysiam）的区别？这两种引擎B+tree的叶子结点和非叶子结点分别存储的什么？</h2><p>区别：<br>            1、InnoDB支持事务和外键，MySIAM不支持<br>            2、InnoDB支持行锁，MySIAM只支持表锁<br>            3、InnoDB的真实数据和索引都存储在同一个文件中，MMySIAM存储在两个文件中<br>            4、InnoDB不支持全文索引，MySIAM支持<br>        InnoDB：<br>            叶节点data域保存了完整的数据记录<br>        MySIAM：<br>            叶节点的data域存放的是数据记录的地址</p>
<h2 id="6、Mysql索引有哪些类型？什么场景使用哪种索引？"><a href="#6、Mysql索引有哪些类型？什么场景使用哪种索引？" class="headerlink" title="6、Mysql索引有哪些类型？什么场景使用哪种索引？"></a>6、Mysql索引有哪些类型？什么场景使用哪种索引？</h2><p>普通索引、唯一索引、主键索引、联合索引、全文索引</p>
<h2 id="7、如何进行Mysql优化？（sql优化层面和服务器优化层面）"><a href="#7、如何进行Mysql优化？（sql优化层面和服务器优化层面）" class="headerlink" title="7、如何进行Mysql优化？（sql优化层面和服务器优化层面）"></a>7、如何进行Mysql优化？（sql优化层面和服务器优化层面）</h2><p>SQL层面：<br>            1、尽量避免使用select *<br>            2、规范sql语句大小写，sql时有缓存的，避免每次都需要解析<br>            3、使用exsits代替in<br>            4、mysql sql解析执行过程是从右到左，from后面能过滤掉更多数据的基础表放在后面，where后面能过滤掉更多数据的查询条件放在后面<br>            5、查询条件中用相同类型去查询，比如避免数值列用字符串查询条件<br>            6、合理使用索引<br>            7、explain命令进行sql慢查询排查<br>        服务器优化层面：<br>            1、读写分离：主节点写，从节点读<br>            2、分库：根据业务或者其他维度把数据存放到不同数据库<br>            3、分表：<br>                1、水平分表：字段都一样，分多张表存放不同时间范围或不同维度的数据，如实时数据表、历史数据表<br>                2、垂直分表：将不同字段放在多张表，使用外键关联<br>            4、常用分库分表中间件：阿里的Cobar及开源社区基于Cobar维护的Mycat</p>
<h2 id="8、Sql调优你会从何入手（措施）？"><a href="#8、Sql调优你会从何入手（措施）？" class="headerlink" title="8、Sql调优你会从何入手（措施）？"></a>8、Sql调优你会从何入手（措施）？</h2><p>explain命令进行sql慢查询排查：<br>            1、id：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，id相同，执行顺序从上至下，id值越大，优先级越高，越先执行<br>            2、select_type：查询类型 SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT<br>                SIMPLE：表示简单杳询，其中不包括连接查询和子查询；<br>                PRIMARY：表示主查询，或者最外层的查询语句；<br>                SUBQUERY：子查询中的第一个SELECT语句；<br>                DERIVED：导出表的SELECT (FROM语句的子查询)；<br>                UNION：表示连接查询的第2个或后面的查询语句；<br>                UNION RESULT：连接查询的结果；<br>            3、table：正在访问哪个表<br>            4、partitions：匹配的分区<br>            5、type：访问的类型，效率从快到慢：<br>                NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;ref_or_null&gt;index_merge&gt;range&gt;index&gt;ALL<br>            6、possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到<br>            7、key：实际使用到的索引，如果为NULL，则没有使用索引<br>            8、key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度<br>            9、ref：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值<br>            10、rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数，这个数量越小越好<br>            11、filtered：查询的表行占表的百分比<br>            12、Extra：包含不适合在其它列中显示但十分重要的额外信息</p>
<h2 id="9、Mysql中如何合理使用索引？有哪些会使索引失效的情况？"><a href="#9、Mysql中如何合理使用索引？有哪些会使索引失效的情况？" class="headerlink" title="9、Mysql中如何合理使用索引？有哪些会使索引失效的情况？"></a>9、Mysql中如何合理使用索引？有哪些会使索引失效的情况？</h2><p>何合理使用索引<br>            1、为合适的列添加索引(主键、唯一索引、组合索引)<br>            2、尽量建立联合索引，也省空间成本<br>            3、尽量使用覆盖索引<br>            4、避免会使索引失效的操作<br>        会使索引失效的情况：<br>            1、索引列有null值不走索引<br>            2、使用is null或is not null不走索引<br>            3、各种负向查询not ，not in， not like ，&lt;&gt; ,!&#x3D; ,!&gt; ,!&lt;  不会使用索引<br>            4、like将%放左边不走索引<br>            5、查询条件的数据类型做了隐式转换<br>            6、使用in或union代替or，or两侧有非索引列就不会走索引<br>            7、尽量保持索引列干净，不在索引列上使用函数转换、运算<br>            8、联合索引要遵循最左匹配原则<br>            9、使用比较运算或between会使联合索引从使用比较运算的下一个索引处断开</p>
<h2 id="10、Mysql如何排查慢查询（哪个关键字）？分别会列出来哪些信息项？"><a href="#10、Mysql如何排查慢查询（哪个关键字）？分别会列出来哪些信息项？" class="headerlink" title="10、Mysql如何排查慢查询（哪个关键字）？分别会列出来哪些信息项？"></a>10、Mysql如何排查慢查询（哪个关键字）？分别会列出来哪些信息项？</h2><p>explain命令进行sql慢查询排查：<br>            1、id：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，id相同，执行顺序从上至下，id值越大，优先级越高，越先执行<br>            2、select_type：查询类型 SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT<br>                SIMPLE：表示简单杳询，其中不包括连接查询和子查询；<br>                PRIMARY：表示主查询，或者最外层的查询语句；<br>                SUBQUERY：子查询中的第一个SELECT语句；<br>                DERIVED：导出表的SELECT (FROM语句的子查询)；<br>                UNION：表示连接查询的第2个或后面的查询语句；<br>                UNION RESULT：连接查询的结果；<br>            3、table：正在访问哪个表<br>            4、partitions：匹配的分区<br>            5、type：访问的类型，效率从快到慢：<br>                NULL&gt;system&gt;const&gt;eq_ref&gt;ref&gt;ref_or_null&gt;index_merge&gt;range&gt;index&gt;ALL<br>            6、possible_keys：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到<br>            7、key：实际使用到的索引，如果为NULL，则没有使用索引<br>            8、key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度<br>            9、ref：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值<br>            10、rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数，这个数量越小越好<br>            11、filtered：查询的表行占表的百分比<br>            12、Extra：包含不适合在其它列中显示但十分重要的额外信息</p>
<h2 id="11、事务的特性是什么？Mysql事务隔离级别有哪几种？分别会产生什么问题？Mysql默认隔离级别是什么？Oracle呢？"><a href="#11、事务的特性是什么？Mysql事务隔离级别有哪几种？分别会产生什么问题？Mysql默认隔离级别是什么？Oracle呢？" class="headerlink" title="11、事务的特性是什么？Mysql事务隔离级别有哪几种？分别会产生什么问题？Mysql默认隔离级别是什么？Oracle呢？"></a>11、事务的特性是什么？Mysql事务隔离级别有哪几种？分别会产生什么问题？Mysql默认隔离级别是什么？Oracle呢？</h2><p>事务的特性：<br>            原子性、一致性、隔离性、永久性<br>        Mysql事务隔离级别：<br>            读未提交、不可重复读、可重复读、串行化<br>        分别会产生什么问题：<br>            读未提交：一个事物读到了另一个事务尚未提交的数据，不符合事务的隔离性<br>            不可重复读：同一个事务中针对同一行记录两次读出来的结果不一样，原因就是第二次读到了其他事务修改提交的数据<br>            可重复读：同一个事务中针对同一范围内的数据两次读出来的结果不一样，原因就是第二次读到了其他事务新增提交的数据<br>        mysql默认隔离级别：<br>            可重复读，但是一般会设置为不可重复读，因为在实际业务中常常是，一个事务中需要读到别的事务提交修改的数据<br>        oraclel默认隔离级别：<br>            不可重复读</p>
<h2 id="12、Mysql的行锁、表锁，悲观锁、乐观锁？"><a href="#12、Mysql的行锁、表锁，悲观锁、乐观锁？" class="headerlink" title="12、Mysql的行锁、表锁，悲观锁、乐观锁？"></a>12、Mysql的行锁、表锁，悲观锁、乐观锁？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">行锁：</span><br><span class="line">        访问数据库的时候，锁定整个行数据，防止并发错误。</span><br><span class="line">    表锁：</span><br><span class="line">        访问数据库的时候，锁定整个表数据，防止并发错误。</span><br><span class="line">    乐观锁：</span><br><span class="line">        乐观的认为本次事务操作数据不会有别的事务干扰，操作数据前不进行加锁，只是预先记录版本号，真正修改数据时再进行比对，</span><br><span class="line">        如果版本号没变则修改数据，版本号变了则表面别的事务在本次事务过程中修改了数据，本次事务不修改数据。</span><br><span class="line">    悲观锁：</span><br><span class="line">        悲观的认为本次事务一定会有别的事务干扰，操作数据前必须先加锁</span><br></pre></td></tr></table></figure></div>

<h2 id="13、Mysql的vachar和char的区别？"><a href="#13、Mysql的vachar和char的区别？" class="headerlink" title="13、Mysql的vachar和char的区别？"></a>13、Mysql的vachar和char的区别？</h2><p>vachar：<br>            长度为可变的，实际使用多少空间就占多少空间。<br>        char：<br>            列长度固定，为创建表时声明的长度，长度值范围是1到255，当char值未填满指定长度时，其他空间会用空格进行填充，检索CHAR值时需删除尾随空格。</p>
<h2 id="14、什么是内连接-inner-join-、外连接（left-join）？"><a href="#14、什么是内连接-inner-join-、外连接（left-join）？" class="headerlink" title="14、什么是内连接(inner join)、外连接（left join）？"></a>14、什么是内连接(inner join)、外连接（left join）？</h2><p>内连接：<br>            只显示左右两表中匹配条件的行，在结果表中删除与其他被连接表中没有匹配行的所有行<br>        左外连接：<br>            把左边表的数据全部取出来，而右边表的数据有相等的，显示出来，如果没有，显示NULL</p>
<h2 id="15、平时Mysql的sql练习要练到位！！"><a href="#15、平时Mysql的sql练习要练到位！！" class="headerlink" title="15、平时Mysql的sql练习要练到位！！"></a>15、平时Mysql的sql练习要练到位！！</h2><p>牛客网，练习SQL语句</p>
<h2 id="16、Mybatis底层的原理？一级缓存和二级缓存是什么？"><a href="#16、Mybatis底层的原理？一级缓存和二级缓存是什么？" class="headerlink" title="16、Mybatis底层的原理？一级缓存和二级缓存是什么？"></a>16、Mybatis底层的原理？一级缓存和二级缓存是什么？</h2><p>Mybatis底层的原理：<br>            动态代理<br>        一级缓存：<br>            Mybatis中sqlSession对象的缓存，当执行查询以后，查询的结果会同时存入到SqlSession提供的一块区域中，该区域的结构是一个Map，<br>            当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，的话直接拿出来用，<br>            当SqlSession对象消失时，mybatis的一级缓存也就消失了，<br>            同时一级缓存是SqlSession范围的缓存，当调用SqlSession的修改、添加、删除、commit(),close等方法时，就会清空一级缓存。<br>        二级缓存：<br>            Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessionFactory对象创建的SqlSession共享其缓存，但是其中缓存的是数据而不是对象</p>
<h2 id="17、mybatis-和-的区别？"><a href="#17、mybatis-和-的区别？" class="headerlink" title="17、mybatis #{}和${}的区别？"></a>17、mybatis #{}和${}的区别？</h2><p>#{}方式能够很大程度防止sql注入<br>        ${}的方式无法防止Sql注入</p>
<h2 id="18、Mysql存储过程、存储函数、触发器分别用来干嘛的？创建语法是什么？"><a href="#18、Mysql存储过程、存储函数、触发器分别用来干嘛的？创建语法是什么？" class="headerlink" title="18、Mysql存储过程、存储函数、触发器分别用来干嘛的？创建语法是什么？"></a>18、Mysql存储过程、存储函数、触发器分别用来干嘛的？创建语法是什么？</h2><p>存储过程：<br>            存储过程把经常使用的SQL语句或业务逻辑封装起来,预编译保存在数据库中,当需要时从数据库中直接调用,省去了编译的过程。<br>            提高了运行速度同时降低网络数据传输量<br>        存储函数：<br>            参数可以有多个,也可以没有参数，必须有且只有一个返回值<br>        触发器：<br>            触发器的执行不是由程序调用，也不是由手工启动，而是由事件来触发、激活从而实现执行</p>
<h2 id="19、union和unionAll有什么区别？"><a href="#19、union和unionAll有什么区别？" class="headerlink" title="19、union和unionAll有什么区别？"></a>19、union和unionAll有什么区别？</h2><p>Union：<br>            对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序<br>            在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果<br>        Union All：<br>            对两个结果集进行并集操作，包括重复行，不进行排序<br>            如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了</p>
<h2 id="20、创建表、删除表、更新表字段语句？"><a href="#20、创建表、删除表、更新表字段语句？" class="headerlink" title="20、创建表、删除表、更新表字段语句？"></a>20、创建表、删除表、更新表字段语句？</h2><p>创建表：<br>            create table 表名<br>        删除表：<br>            drop table 表名<br>        更新表字段：<br>            修改字段名称：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 数据类型;<br>            修改字段数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型;</p>
<h2 id="21、mysql左外连接语句的写法？"><a href="#21、mysql左外连接语句的写法？" class="headerlink" title="21、mysql左外连接语句的写法？"></a>21、mysql左外连接语句的写法？</h2><p>Select A.name,B.name from A Left Join B on A.id&#x3D;B.id;</p>
<h2 id="22、听过InnoDB的Mvcc技术吗？说下是什么？"><a href="#22、听过InnoDB的Mvcc技术吗？说下是什么？" class="headerlink" title="22、听过InnoDB的Mvcc技术吗？说下是什么？"></a>22、听过InnoDB的Mvcc技术吗？说下是什么？</h2><p>Mvcc：<br>            多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，<br>            取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能</p>
<h2 id="23、Java实现动态代理有哪些方式？区别是什么？"><a href="#23、Java实现动态代理有哪些方式？区别是什么？" class="headerlink" title="23、Java实现动态代理有哪些方式？区别是什么？"></a>23、Java实现动态代理有哪些方式？区别是什么？</h2><p>Java实现动态代理有哪些方式：<br>            jdk动态代理、cglib动态代理<br>        区别：<br>            jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。<br>            总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效。<br>            还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。<br>            如果没有上述前提，jdk动态代理不能应用。<br>            由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</p>
<h1 id="五、多线程"><a href="#五、多线程" class="headerlink" title="五、多线程"></a>五、多线程</h1><h2 id="1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？"><a href="#1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？" class="headerlink" title="1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？"></a>1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？</h2><p>创建线程的方式：<br>            1、实现Runnable接口<br>            2、继承Thread类<br>        好处：<br>            1、适合多个相同程序代码的线程去处理同一个资源<br>            2、可以避免由于Java的单继承性带来的局限性<br>            3、增强了程序的健壮性，代码能够被多个线程共享，代码与数据是独立的</p>
<h2 id="2、线程的状态有哪些？"><a href="#2、线程的状态有哪些？" class="headerlink" title="2、线程的状态有哪些？"></a>2、线程的状态有哪些？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、新建状态</span><br><span class="line">2、就绪状态</span><br><span class="line">3、运行状态</span><br><span class="line">4、阻塞状态</span><br><span class="line">5、死亡状态</span><br></pre></td></tr></table></figure></div>

<h2 id="3、run-和start-方法有哪些区别？"><a href="#3、run-和start-方法有哪些区别？" class="headerlink" title="3、run()和start()方法有哪些区别？"></a>3、run()和start()方法有哪些区别？</h2><p>run()：<br>            是来完成实际的业务逻辑，当run()方法结束后，此线程就会终止<br>        start()：<br>            是用来开启一个线程的，使线程处于就绪状态，即可以被JVM来调度执行</p>
<h2 id="4、实现线程间通讯的方法有哪些？"><a href="#4、实现线程间通讯的方法有哪些？" class="headerlink" title="4、实现线程间通讯的方法有哪些？"></a>4、实现线程间通讯的方法有哪些？</h2><p>1、wait()：<br>            让线程处于冻结状态，被wait的线程会被存储到线程池中<br>        2、notify()：<br>            唤醒线程池中的一个线程<br>        3、notifyAll()：<br>            唤醒线程池中的所有线程</p>
<h2 id="5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？"><a href="#5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？" class="headerlink" title="5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？"></a>5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？</h2><p>分别的作用：<br>            wait()：<br>                让线程处于冻结状态，被wait的线程会被存储到线程池中<br>            notify()：<br>                唤醒线程池中的一个线程<br>            notifyAll()：<br>                唤醒线程池中的所有线程<br>        可以用在同步代码块之外吗：<br>            不行<br>        为什么：<br>            因为这些方法是用于操作线程状态的方法，必须要明确到底操作的是哪个锁上的线程</p>
<h2 id="6、Sleep和Wait的区别？"><a href="#6、Sleep和Wait的区别？" class="headerlink" title="6、Sleep和Wait的区别？"></a>6、Sleep和Wait的区别？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sleep():</span><br><span class="line">        1、属于Thread类，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态</span><br><span class="line">        2、sleep方法没有释放锁</span><br><span class="line">        3、sleep必须捕获异常</span><br><span class="line">        4、sleep可以在任何地方使用</span><br><span class="line">    wait：</span><br><span class="line">        1、属于Object，一旦一个对象调用了wait方法，必须采用notify()和notifyAll()方法唤醒该进程</span><br><span class="line">        2、wait方法释放了锁</span><br><span class="line">        3、wait不需要捕获异常</span><br><span class="line">        4、wait、notify、notifyAll只能在同步控制方法或者同步控制块中使用</span><br></pre></td></tr></table></figure></div>

<h2 id="7、什么是线程安全问题？什么情况下会产生？如何解决？"><a href="#7、什么是线程安全问题？什么情况下会产生？如何解决？" class="headerlink" title="7、什么是线程安全问题？什么情况下会产生？如何解决？"></a>7、什么是线程安全问题？什么情况下会产生？如何解决？</h2><p>线程安全问题：<br>            多个线程同时访问共享数据时可能会出现问题，称为线程安全问题<br>        什么情况下会产生：<br>            当多线程访问共享数据时，由于CPU的切换，导致一个线程只执行了关键代码的一部分，还没执行完此时另一个线程参与进来，导致共享数据发生异常<br>        如何解决：<br>            通过线程同步机制synchronized + 锁来解决线程安全问题</p>
<h2 id="8、什么是死锁？如何防止产生死锁？"><a href="#8、什么是死锁？如何防止产生死锁？" class="headerlink" title="8、什么是死锁？如何防止产生死锁？"></a>8、什么是死锁？如何防止产生死锁？</h2><p>什么是死锁：<br>            死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去<br>        如何防止产生死锁：<br>            1、设置超时时间<br>            2、使用JUC包提供的并发类，而不是自己设计锁<br>            3、尽量降低锁的粒度<br>            4、尽量使用同步代码块，而不是同步方法<br>            5、给线程其有意义的名字<br>            6、避免的嵌套<br>            7、分配锁资源之前先看能不能回收回来资源<br>            8、专锁专用</p>
<h2 id="9、Synchronized关键字的底层原理是什么"><a href="#9、Synchronized关键字的底层原理是什么" class="headerlink" title="9、Synchronized关键字的底层原理是什么?"></a>9、Synchronized关键字的底层原理是什么?</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当一个线程第一次运行到 <span class="keyword">synchronized</span> 代码，获取到了 myObject 对象的 monitor 的锁，然后计数器就会加<span class="number">1</span>，</span><br><span class="line">然后第二次运行到 <span class="keyword">synchronized</span> 代码，会再次获取 myObject 对象的 monitor 的锁，这个就是重入加锁了，然后计数器会再次加<span class="number">1</span>，变成<span class="number">2</span>，</span><br><span class="line">这个时候，其他的线程运行到第一次 <span class="keyword">synchronized</span> 代码，会发现 myObject 对象的 monitor 锁的计数器是大于<span class="number">0</span>的，</span><br><span class="line">就意味着被别人给加锁了，然后此时线程就会进入 block 阻塞状态，什么都干不了，就是等待获取锁</span><br><span class="line">如果第一个线程出了 <span class="keyword">synchronized</span> 修饰范围的话，就会有一个 moninorexit 的指令，此时，在底层获取锁的线程就会对那个对象</span><br><span class="line">的 monitor 的计数器减<span class="number">1</span>，如果有多次重入加锁，就会对应多次减<span class="number">1</span>，直到最后，计数器是<span class="number">0</span></span><br><span class="line">然后，后面 block 阻塞的线程，会再次尝试获取锁，但是只有一个线程可以获取锁</span><br></pre></td></tr></table></figure></div>

<h2 id="10、Synchronized可以用在哪些地方？分别的锁对象是什么？"><a href="#10、Synchronized可以用在哪些地方？分别的锁对象是什么？" class="headerlink" title="10、Synchronized可以用在哪些地方？分别的锁对象是什么？"></a>10、Synchronized可以用在哪些地方？分别的锁对象是什么？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、同步代码块：锁对象为括号中的对象</span><br><span class="line">    <span class="number">2</span>、同步方法：锁对象为当前对象<span class="built_in">this</span></span><br><span class="line">    <span class="number">3</span>、静态同步方法：锁对象为class字节码文件对象</span><br></pre></td></tr></table></figure></div>

<h2 id="11、Synchronized和JUC下Lock锁的异同？"><a href="#11、Synchronized和JUC下Lock锁的异同？" class="headerlink" title="11、Synchronized和JUC下Lock锁的异同？"></a>11、Synchronized和JUC下Lock锁的异同？</h2><p>1、Lock是JUC包下提供的封装好的锁，是类的概念，而synchronized是一个虚拟机层面的关键字。<br>        2、Lock显示的加锁和解锁，且解锁要在finally代码块中，否则可能会死锁，而synchronized为隐式的上锁和解锁。<br>        3、Lock锁提供了尝试获取锁和设置获取锁时间的机制，可返回取锁状态，当获取不到锁的时候也可以选择放弃取锁，<br>          而synchronized无法判断返回取锁状态，取锁不成功只能阻塞，没有Lock灵活。<br>        4、Lock锁阻塞可被打断，而synchronized阻塞不可被打断。<br>        5、Lock可实现可重入、可公平锁，而synchronized是可重入、非公平锁。<br>        6、Lock可以很灵活的根据线程角色类型去创建Condition监视器对象，调用await()、signal()、signalAll()进行线程通讯调度，<br>          而synchronized使用Object对象本身作为监视器对象去调用wait() 、notify()、notifyAll()进行线程通讯调度。<br>        7、Lock提供了更丰富的锁分类，如读锁、写锁，可以更细粒度的关注线程安全问题。</p>
<h2 id="12、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？"><a href="#12、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？" class="headerlink" title="12、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？"></a>12、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？</h2><p>非公平，会阻塞</p>
<h2 id="13、Synchronized在JDK1-6做了什么优化？"><a href="#13、Synchronized在JDK1-6做了什么优化？" class="headerlink" title="13、Synchronized在JDK1.6做了什么优化？"></a>13、Synchronized在JDK1.6做了什么优化？</h2><p>自适应的CAS自旋、锁消除、锁粗化、偏向锁、轻量级锁</p>
<h2 id="13、同步代码块中执行完wait-x2F-notify-x2F-notifyAll后会立马释放锁吗？"><a href="#13、同步代码块中执行完wait-x2F-notify-x2F-notifyAll后会立马释放锁吗？" class="headerlink" title="13、同步代码块中执行完wait&#x2F;notify&#x2F;notifyAll后会立马释放锁吗？"></a>13、同步代码块中执行完wait&#x2F;notify&#x2F;notifyAll后会立马释放锁吗？</h2><p>不会，必须等其所在的同步代码块执行完才会释放锁</p>
<h2 id="14、Lock锁有哪些实现？分别的特点是什么？"><a href="#14、Lock锁有哪些实现？分别的特点是什么？" class="headerlink" title="14、Lock锁有哪些实现？分别的特点是什么？"></a>14、Lock锁有哪些实现？分别的特点是什么？</h2><p>1、ReentrantLock<br>        2、ReentrantReadWriteLock类中的静态内部类ReadLock(读-写锁)<br>        3、ReentrantReadWriteLock类中的静态内部类WriteLock(读-写锁)</p>
<h2 id="15、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？"><a href="#15、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？" class="headerlink" title="15、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？"></a>15、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JUC下Lock的监视器对象：</span><br><span class="line">    Condition</span><br><span class="line">异同：</span><br><span class="line">    Lock可以很灵活的根据线程角色类型去创建Condition监视器对象，调用await()、signal()、signalAll()进行线程通讯调度，</span><br><span class="line">      而synchronized使用Object对象本身作为监视器对象去调用wait() 、notify()、notifyAll()进行线程通讯调度。</span><br></pre></td></tr></table></figure></div>

<h2 id="16、什么是线程可重入？Synchronized具备吗？Lock呢？"><a href="#16、什么是线程可重入？Synchronized具备吗？Lock呢？" class="headerlink" title="16、什么是线程可重入？Synchronized具备吗？Lock呢？"></a>16、什么是线程可重入？Synchronized具备吗？Lock呢？</h2><p>重入锁就是一个线程能否获取一个已经由它自己持有的锁。如果可以，就是可重入锁，否则为不可重入锁。它的作用就是能够避免重复获取的时候出现死锁<br>        synchronized 是可重入锁<br>        Lock 是可重入锁</p>
<h2 id="17、什么是AQS？"><a href="#17、什么是AQS？" class="headerlink" title="17、什么是AQS？"></a>17、什么是AQS？</h2><p>是一个用于构建锁和同步容器的队列同步器，它是整个JUC包下Lock体系的核心，<br>        如ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore都是基于它来实现的，<br>        它解决了在实现同步容器时设计的大量细节问题，<br>        它的核心构成部分为：使用一个 先进先出的FIFO的队列存储排队等待锁的线程，使用一个用volatile修饰的int类型的state同步状态来记录<br>        当前是否有线程持有锁，0表示没有线程获得锁，1表示有，上锁state就加1，释放锁就对应减1，有重入锁现象，这个值就大于1，然后需要逐级去释放。</p>
<h2 id="18、什么是CAS？什么是CAS的ABA问题？如何解决？"><a href="#18、什么是CAS？什么是CAS的ABA问题？如何解决？" class="headerlink" title="18、什么是CAS？什么是CAS的ABA问题？如何解决？"></a>18、什么是CAS？什么是CAS的ABA问题？如何解决？</h2><p>CAS：<br>            CAS其实就是乐观锁的一种实现方式<br>        ABA问题：<br>            1、线程1读取出指定内存地址的数据A，加载到寄存器，此时读取出来的原值不仅将作为要被计算的值A，还会作为比较值A。<br>            2、此时线程1的cpu被线程2抢占了，线程2也从同样的内存地址中读取了同样的数据A，线程2还比线程1先执行完，线程2产生了新数据B，<br>              并且遵守了CAS原理把新数据B存入该内存地址。 （这个时候内存的值由A被该为B）<br>            3、还没完，线程2执行完之后，线程1又没抢过其它线程，此时cpu被线程3抢占，之后步骤和第 2 步一样，线程3从同样的内存地址中读取了数据B，<br>              线程3还比线程1先执行完，线程3产生了新数据A（没错，与一开始的A相等，但值相等并不意味着此A就是彼A，已经被替换了），<br>              并且遵守了CAS原理把新数据A存入该内存地址。（这个时候内存的值由B又变为A）<br>            4、这个时候线程1执行完了，要遵守CAS原理存入数据，然后比较值A是原来的A（简称原A），而执行内存地址中的A是被替换过的了，<br>              但原A的值与内存中的A值是相等的，根据CAS，线程1会把新的执行结果存入该内存地址<br>              在实际业务中，两个数的值相等，但这两个数并不是同一个数<br>        解决方案：<br>            加个版本号，多一步比较版本号即可解决</p>
<h2 id="19、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Simephore）"><a href="#19、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Simephore）" class="headerlink" title="19、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Simephore）"></a>19、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Simephore）</h2><p>CountdownLatch：<br>            利用它可以实现类似计数器的功能<br>        Cyclicbarrier：<br>            字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行<br>        Simephore：<br>            信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可</p>
<h2 id="20、说下volatile关键字，有什么作用？原理是什么？"><a href="#20、说下volatile关键字，有什么作用？原理是什么？" class="headerlink" title="20、说下volatile关键字，有什么作用？原理是什么？"></a>20、说下volatile关键字，有什么作用？原理是什么？</h2><p>是一个变量类型修饰符，被voltile修饰的变量具有以下特性：<br>        可见性：<br>            保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>            实现(缓存共享协议)：<br>                对于用volatile形容的变量，线程写入本地内存中的同时会将数据立即刷新到主内存中。<br>                他线程读取该变量时，发现被volatile修饰，会将本地变量值置为无效，然后从主内存中读取。<br>        有序性：<br>            禁止进行指令重排序。为提高执行效率，在不影响最终执行结果的前提下，代码在编译成字节码的时候有可能进行指令重新<br>            排序，这在单线程情况下是没有问题的，但是在多线程的情况下会出现问题。volatile修饰的变量则可以避免这个问题。<br>        不保证原子性：<br>            volatile 只能保证对单次读&#x2F;写的原子性。i++ 这种操作不能保证原子性。关于volatile 原子性可以理解为把对volatile<br>            变量的单个读&#x2F;写，看成是使用同一个锁对这些单个读&#x2F;写操作做了同步。</p>
<h2 id="21、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？"><a href="#21、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？" class="headerlink" title="21、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？"></a>21、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？</h2><p>ThreadLocal：<br>            ThreadLocal是除了加锁这种同步方式之外的另一种可以规避出现多线程安全问题的思路。<br>            ThreadLocal是JDK包提供的，它提供线程本地变量，如果创建一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，<br>            在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题<br>        主要方法：<br>            get（）、set（）、remove（）<br>        实现原理：<br>            每个线程都有属于自己的一个ThreadLocalMap，可通过Thread获得，这个map存储着以threadLock对象为key、以设置的值为value的键值对。<br>            调用get或者set还有remove方法都是操作这个map<br>        内存泄漏：<br>            对于线程池里面不会销毁的线程, 里面总会存在着&lt;ThreadLocal, LocalVariable&gt;的强引用,<br>            因为 final static 修饰的 ThreadLocal 并不会释放,<br>            而 ThreadLocalMap 对于 Key 虽然是弱引用, 但是强引用不会释放, 弱引用当然也会一直有值,<br>            同时创建的 LocalVariable 对象也不会释放, 就造成了内存泄露;<br>        解决方案：<br>            为了避免出现内存泄露的情况, ThreadLocal 提供了一个清除线程中对象的方法, 即 remove,<br>            其实内部实现就是调用 ThreadLocalMap 的 remove 方法:</p>
<h2 id="22、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？"><a href="#22、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？" class="headerlink" title="22、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？"></a>22、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？</h2><p>线程池的七大核心参数：<br>            1、核心线程数：<br>                没达到核心线程数时，会创建新的线程。当达到核心线程数时，任务会进去队列<br>            2、最大核心线程数：<br>                当达到核心线程数时，会去创建额外的线程来执行任务，最多不超过最大线程数<br>            3、存活时间：<br>                当任务处理完成，额外的线程存活一段时间后，会自行销毁<br>            4、存活时间单位：<br>                空闲等待时间的单位<br>            5、阻塞队列：<br>                利用什么队列来存放任务，有界队列、无界队列等<br>            6、线程池工厂：<br>                线程创建工厂<br>            7、拒绝策略：<br>                分为四大策略：<br>                    1、AbortPolicy（默认策略）：直接抛出异常，阻止系统正常运行<br>                    2、CallerRunsPolicy 策略：等线程池处理不了的任务，谁提交的任务，就给谁拿回去，让其自己执行<br>                    3、DiscardPolicy 策略：直接抛弃策略，异常也不会抛，什么都不做<br>                    4、DiscardOldestPolicy 策略：丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务<br>        有几种默认的线程池：<br>            1、newCachedThreadPool：<br>                可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程<br>            2、newFixedThreadPool：<br>                指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中<br>            3、newSingleThreadExecutor：<br>                单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。<br>            4、newScheduleThreadPool：<br>                定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行</p>
<h2 id="23、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？"><a href="#23、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？" class="headerlink" title="23、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？"></a>23、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">单例模式写法：</span><br><span class="line">            <span class="number">1</span>、懒汉式</span><br><span class="line">                直到使用前才会创建实例</span><br><span class="line">            <span class="number">2</span>、饿汉式</span><br><span class="line">                类加载的时候就创建实例</span><br><span class="line">        懒汉式中保证线程安全：</span><br><span class="line">            在 getInstance() 方法添加 <span class="keyword">synchronized</span> 关键字，可以解决线程安全问题</span><br><span class="line">        为什么要用双重检查模式：</span><br><span class="line">            第一次校验：</span><br><span class="line">                由于单例模式只需要创建一次实例，如果后面再次调用getInstance方法时，则直接返回之前创建的实例，</span><br><span class="line">                因此大部分时间不需要执行同步方法里面的代码，大大提高了性能。</span><br><span class="line">                如果不加第一次校验的话，那跟上面的懒汉模式没什么区别，每次都要去竞争锁。</span><br><span class="line">　　　　     第二次校验：</span><br><span class="line">                如果没有第二次校验，假设线程t1执行了第一次校验后，判断为<span class="literal">null</span>，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为<span class="literal">null</span>。</span><br><span class="line">                接下来t2获得锁，创建实例。</span><br><span class="line">                这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为<span class="literal">null</span>（不会再次判断），获得锁后，直接创建实例。</span><br><span class="line">                结果就会导致创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。</span><br></pre></td></tr></table></figure></div>

<h1 id="六、Redis-amp-多级缓存"><a href="#六、Redis-amp-多级缓存" class="headerlink" title="六、Redis &amp; 多级缓存"></a>六、Redis &amp; 多级缓存</h1><h2 id="1、Redis是一个什么样的数据库？读写速度怎么样？"><a href="#1、Redis是一个什么样的数据库？读写速度怎么样？" class="headerlink" title="1、Redis是一个什么样的数据库？读写速度怎么样？"></a>1、Redis是一个什么样的数据库？读写速度怎么样？</h2><p>非关系型型数据库<br>        Redis将数据存储在内存上，避免了频繁的IO操作</p>
<h2 id="2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举"><a href="#2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举" class="headerlink" title="2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举"></a>2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举</h2><br/>

<p>数据类型：<br>            1、string（字符串）：<br>                一个key对应一个value<br>            2、hash（哈希）：<br>                是一个键值对集合<br>            3、list（列表）：<br>                简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）<br>            4、set（集合）：<br>                string类型的无序集合,且不允许重复的成员<br>            5、zset(有序集合)：<br>                string类型元素的集合,且不允许重复的成员<br>                不同的是每个元素都会关联一个double类型的分数<br>                redis正是通过分数来为集合中的成员进行从小到大的排序<br>                zset的成员是唯一的,但分数(score)却可以重复<br>        项目有哪些应用场景：<br>            1、计数器：<br>                对 string 进行自增自减运算，从而实现计数器功能<br>                redis 内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。如每日登录次数计数<br>            2、热点数据缓存：<br>                将热点数据放到内存中。如首页排行榜数据，具有很大访问频次，使用zset可以实现基于score分数排序<br>            3、会话缓存：<br>                用redis统一存储多台应用服务器的会话信息<br>                当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，<br>                从而更容易实现高可用性以及可伸缩性<br>            4、取数据交集、并集：<br>                基于 redis set 的特性可以对共同好友进行很方便的查询<br>            5、分布式事务锁的使用：<br>                基于 set lock requestId nx ex time 模式可以很方便编写分布式事务锁</p>
<h2 id="3、Redis的持久化机制是什么样的？"><a href="#3、Redis的持久化机制是什么样的？" class="headerlink" title="3、Redis的持久化机制是什么样的？"></a>3、Redis的持久化机制是什么样的？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）、什么是RDB？RDB的持久化机制（Save、bgSave）?</span><br><span class="line">			RDB：</span><br><span class="line">				把内存中的所有数据都记录到磁盘中。</span><br><span class="line">				当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</span><br><span class="line">				快照文件称为RDB文件，默认是保存在当前运行目录。</span><br><span class="line">			save：</span><br><span class="line">				save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</span><br><span class="line">			bgSave：</span><br><span class="line">				bgSave命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</span><br><span class="line"></span><br><span class="line">		<span class="number">2</span>）、触发RDB的时间点是什么？</span><br><span class="line">			save：关机时会save一次，会阻塞主线程，影响效率。</span><br><span class="line">			bgsave：与配置有关：save m n，当m秒内有n个key发生修改会触发，后台会fork出一个子线程完成快照</span><br><span class="line"></span><br><span class="line">		<span class="number">3</span>）、RDB的优缺点分别有哪些？</span><br><span class="line">			优点：</span><br><span class="line">				由于快照是二进制的，所以加载速度很快</span><br><span class="line">			缺点：</span><br><span class="line">				由于快照的时间间隔比较长，所以有可能会丢失大量数据</span><br><span class="line"></span><br><span class="line">		<span class="number">4</span>）、什么是AOF？分为几个阶段？(命令写入缓冲区、同步至日志文件、文件重写)</span><br><span class="line">			AOF：</span><br><span class="line">				将redis数据以 操作 + 数据的命令形式存在日志文件中(appendonly.aof)，默认是关闭的</span><br><span class="line">			三个阶段：</span><br><span class="line">				<span class="number">1</span>、命令写入缓冲区</span><br><span class="line">				<span class="number">2</span>、文件命令同步（刷盘策略）</span><br><span class="line">				<span class="number">3</span>、文件重写</span><br><span class="line"></span><br><span class="line">		<span class="number">5</span>）、AOF命令同步至日志文件分为哪几种？</span><br><span class="line">			<span class="number">1</span>、always </span><br><span class="line">			<span class="number">2</span>、everyseconds</span><br><span class="line">			<span class="number">3</span>、no</span><br><span class="line"></span><br><span class="line">		<span class="number">6</span>）、AOF文件重写时间点？重写做了什么？</span><br><span class="line">			重写的时机：</span><br><span class="line">				<span class="number">1</span>、文件大小超过64M</span><br><span class="line">				<span class="number">2</span>、跟上次文件大小相比，增长比例超过<span class="number">100</span>%，也就是原来的<span class="number">2</span>倍</span><br><span class="line">			重写干了什么：</span><br><span class="line">				删除没用的命令、合并多条命令以缩小文件大小</span><br><span class="line"></span><br><span class="line">		<span class="number">7</span>）、AOF的优缺点分别有哪些？</span><br><span class="line">			优点：</span><br><span class="line">				数据实时性高，不易丢失数据</span><br><span class="line">			缺点：</span><br><span class="line">				加载速度慢，文件体积大</span><br><span class="line"></span><br><span class="line">		<span class="number">8</span>）、AOF和RDB同时开启会优先使用哪种进行数据恢复？</span><br><span class="line">			AOF</span><br><span class="line"></span><br><span class="line">		<span class="number">9</span>）、RDB-AOF混合模式是什么？优点有哪些？</span><br><span class="line">			RDB-AOF混合模式：</span><br><span class="line">				是在AOF重写阶段创建一个同时包含RDB数据和AOF数据的AOF文件，其中RDB数据位于AOF文件的开头，</span><br><span class="line">				他存储了服务器开始执行重写操作时Redis服务器的数据状态（RDB 快照方案），</span><br><span class="line">				重写操作执行之后的Redis命令，则会继续 append 在AOF文件末尾，一般这部分数据都会比较小。</span><br><span class="line">			优点：</span><br><span class="line">				这样在Redis重启的时候，则可以先加载RDB的内容，然后再加载AOF的日志内容，这样重启的效率则会得到很大的提升，</span><br><span class="line">				而且由于在运行阶段 Redis 命令都会以 append 的方式写入AOF文件，保证了数据的实时性和安全性</span><br></pre></td></tr></table></figure></div>

<h2 id="4、Redis主从结构能解决什么问题？"><a href="#4、Redis主从结构能解决什么问题？" class="headerlink" title="4、Redis主从结构能解决什么问题？"></a>4、Redis主从结构能解决什么问题？</h2><p>提高并发读写效率</p>
<h2 id="5、Redis主从同步具体流程是什么？"><a href="#5、Redis主从同步具体流程是什么？" class="headerlink" title="5、Redis主从同步具体流程是什么？"></a>5、Redis主从同步具体流程是什么？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）、建立连接</span><br><span class="line">		<span class="number">2</span>）、数据同步（全量同步、增量同步）【runid运行ID、offset偏移量、复制积压缓冲区】</span><br><span class="line">			<span class="number">1</span>、全量同步具体场景有哪些？流程？如何避免全量同步次数（全量同步非常耗时）</span><br><span class="line">				具体场景：</span><br><span class="line">					<span class="number">1</span>、slave节点第一次连接master节点时</span><br><span class="line">          <span class="number">2</span>、slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</span><br><span class="line">				流程：</span><br><span class="line">					<span class="number">1</span>、从服务器向主服务器发送SYNC请求</span><br><span class="line">					<span class="number">2</span>、主服务器创建快照，并将快照生成期间产生的写命令存储到缓冲区</span><br><span class="line">					<span class="number">3</span>、主服务器向从服务器发送同步快照命令</span><br><span class="line">					<span class="number">4</span>、从服务器加载解析快照</span><br><span class="line">					<span class="number">5</span>、主服务器将从服务器同步快照期间产生的写命令存储到缓冲区</span><br><span class="line">					<span class="number">6</span>、主服务器向从服务器发送缓冲区中存储的命令</span><br><span class="line">					<span class="number">7</span>、从服务器加载缓冲</span><br><span class="line">					<span class="number">8</span>、完成，主服务器向从服务器同步写操作命令</span><br><span class="line">				如何避免全量同步次数：</span><br><span class="line">					增大复制缓冲区的配置</span><br><span class="line"></span><br><span class="line">			<span class="number">2</span>、增量同步具体场景有哪些？流程？</span><br><span class="line">				具体场景:</span><br><span class="line">					slave节点断开又恢复，并且在repl_baklog中能找到offset时</span><br><span class="line">				流程：</span><br><span class="line">					Slave完成初始化后开始正常工作时，Master每执行一个写命令就会向Slave发送相同的写命令，然后Slave接收并执行</span><br><span class="line">		<span class="number">3</span>）、命令传播</span><br></pre></td></tr></table></figure></div>

<h2 id="6、如何优化主从同步效率？"><a href="#6、如何优化主从同步效率？" class="headerlink" title="6、如何优化主从同步效率？"></a>6、如何优化主从同步效率？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）、从尽量避免全量同步的方面入手（安全重启使runid不发生变化、调大复制积压缓冲区）</span><br><span class="line">			安全重启使runid不发生变化、调大复制积压缓冲区</span><br><span class="line"></span><br><span class="line">		2）、避免slave从结点太多造成复制风暴（使用树状拓补结构）</span><br><span class="line">			1.主节点分散多机器（将master分散到不同机器上部署）</span><br><span class="line">			2.还有我们可以采用高可用手段（slave晋升master）</span><br></pre></td></tr></table></figure></div>

<h2 id="7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？"><a href="#7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？" class="headerlink" title="7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？"></a>7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Redis的故障恢复机制:</span><br><span class="line">			哨兵机制</span><br><span class="line">		工作范围:</span><br><span class="line">			监控、故障转移、通知</span><br><span class="line">		工作流程：	</span><br><span class="line">			<span class="number">1</span>、每个 Sentinel 进程每秒向整个集群中的主服务器，从服务器以及其他 Sentinel 进程发送一个 PING 命令</span><br><span class="line">			<span class="number">2</span>、如果一个实例距离最后一次有效回复 PING 命令的时间超过所指定的值， 则这个实例会被 Sentinel 进程标记为主观下线</span><br><span class="line">			<span class="number">3</span>、如果一个主服务器被标记为主观下线，则正在监视这个主服务器的所有 Sentinel 进程要每秒确认主服务器的确进入了主观下线状态</span><br><span class="line">			<span class="number">4</span>、当有足够数量的 Sentinel 进程在指定的时间范围内确认主服务器进入了主观下线状态， 则主服务器会被标记为客观下线</span><br><span class="line">			<span class="number">5</span>、每个 Sentinel 进程会以每 <span class="number">10</span> 秒向集群中的所有主服务器、从服务器发送 INFO 命令，更新redis主从最新的一个拓补情况</span><br><span class="line">			<span class="number">6</span>、当主服务器被 Sentinel 进程标记为客观下线时，Sentinel 进程向下线的主服务器的所有从服务器发送 INFO 命令的频率会从 <span class="number">10</span> 秒一次改为每秒一次</span><br><span class="line">			<span class="number">7</span>、若没有足够数量的 Sentinel 进程同意主服务器下线，主服务器的客观下线状态就会被移除。</span><br><span class="line">			  若主服务器重新向 Sentinel 进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</span><br><span class="line">		作用：</span><br><span class="line">			<span class="number">1</span>、监控：<span class="number">3</span>个心跳</span><br><span class="line">				<span class="number">10</span>秒一次：更新redis主从最新的一个拓补情况</span><br><span class="line">				<span class="number">3</span>秒一次：用于Sentinel哨兵节点之间交流对redis数据节点的看法</span><br><span class="line">				<span class="number">1</span>秒一次：用于发出ping，检测redis节点是否还存活（主观下线、客观下线）</span><br><span class="line">			<span class="number">2</span>、故障转移：当对主节点进行客观下线后，选举出一个新的主节点，并且将其他节点连接上新的主节点，最后将原来的master标记为从结点</span><br><span class="line">			<span class="number">3</span>、通知：用于master发生了变动，将变化推送给客户端</span><br></pre></td></tr></table></figure></div>

<h2 id="8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？"><a href="#8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？" class="headerlink" title="8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？"></a>8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">缓存雪崩：</span><br><span class="line">			Redis挂掉了，请求全部走数据库。</span><br><span class="line">			对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库</span><br><span class="line">			解决方案：</span><br><span class="line">				<span class="number">1</span>、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</span><br><span class="line">				<span class="number">2</span>、如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中</span><br><span class="line">				<span class="number">3</span>、允许的话，设置热点数据永远不过期</span><br><span class="line">				<span class="number">4</span>、要保证redis的高可用，可以使用主从+哨兵或redis cluster，避免服务器不可用</span><br><span class="line">				<span class="number">5</span>、使用redis的持久化RDB+AOF组合策略，防止缓存丢失并且可以快速恢复数据</span><br><span class="line"></span><br><span class="line">		缓存击穿：</span><br><span class="line">			缓存中没有但数据库中有的数据，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，</span><br><span class="line">			引起数据库压力瞬间增大，造成过大压力</span><br><span class="line">			解决方案：</span><br><span class="line">				<span class="number">1</span>）、设置热点数据不过期；</span><br><span class="line">				<span class="number">2</span>）、第一时间去数据库获取数据填充到redis中，但是这个过程需要加锁，防止所有线程都去读取数据库，</span><br><span class="line">					一旦有一个线程去数据库获取数据了，其他线程取锁失败后可设置一个合理睡眠时间之后再去尝试去redis中获取数据；</span><br><span class="line">		缓存穿透：</span><br><span class="line">			缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为 -<span class="number">1</span> 的数据或id为特别大不存在的数据。</span><br><span class="line">			这时的用户很可能是攻击者，攻击会导致数据库压力过大</span><br><span class="line">			解决方案：</span><br><span class="line">				<span class="number">1</span>、接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=<span class="number">0</span>的直接拦截；</span><br><span class="line">				<span class="number">2</span>、从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-<span class="literal">null</span>，</span><br><span class="line">				  缓存有效时间可以设置短点，设置太长会导致正常情况也没法使用。这样可以防止攻击用户反复用同一个id暴力攻击；</span><br><span class="line">				<span class="number">3</span>、引入布隆过滤器，过滤一些异常的请求。</span><br></pre></td></tr></table></figure></div>

<h2 id="9、Redis是单线程的，为什么读写效率还那么高？"><a href="#9、Redis是单线程的，为什么读写效率还那么高？" class="headerlink" title="9、Redis是单线程的，为什么读写效率还那么高？"></a>9、Redis是单线程的，为什么读写效率还那么高？</h2><p>基于非阻塞的IO多路复用机制的线程模型</p>
<h2 id="10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）"><a href="#10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）" class="headerlink" title="10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）"></a>10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）</h2><p>基于非阻塞的IO多路复用机制的线程模型，单线程</p>
<h2 id="11、Redis过期数据的删除策略是什么？有哪些？"><a href="#11、Redis过期数据的删除策略是什么？有哪些？" class="headerlink" title="11、Redis过期数据的删除策略是什么？有哪些？"></a>11、Redis过期数据的删除策略是什么？有哪些？</h2><p>定时删除、惰性过期、定期过期</p>
<h2 id="12、Redis的数据淘汰策略是什么？有哪些？"><a href="#12、Redis的数据淘汰策略是什么？有哪些？" class="headerlink" title="12、Redis的数据淘汰策略是什么？有哪些？"></a>12、Redis的数据淘汰策略是什么？有哪些？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、volatile-lru：</span><br><span class="line">			从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</span><br><span class="line">		2、volatile-ttl：</span><br><span class="line">			从已设置过期时间的数据集中挑选将要过期的数据淘汰</span><br><span class="line">		3、volatile-random：</span><br><span class="line">			从已设置过期时间的数据集中任意选择数据淘汰</span><br><span class="line">		4、allkeys-lru：</span><br><span class="line">			从数据集中挑选最近最少使用的数据淘汰</span><br><span class="line">		5、allkeys-random：</span><br><span class="line">			从数据集中任意选择数据淘汰</span><br><span class="line">		6、no-enviction（驱逐）：</span><br><span class="line">			禁止驱逐数据</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="13、Redis的慢查询如何排查？"><a href="#13、Redis的慢查询如何排查？" class="headerlink" title="13、Redis的慢查询如何排查？"></a>13、Redis的慢查询如何排查？</h2><p>Redis 慢查询可通过配置两个参数进行：<br>            slowlog-log-slower-than：设置慢查询预设的超时阈值，单位是微秒<br>            slowlog-max-len：表示慢查询日志存储的条数</p>
<h2 id="14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）"><a href="#14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）" class="headerlink" title="14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）"></a>14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正确使用redis分布式事务锁需要保证两个原子性：</span><br><span class="line">			1、上锁和设置过期时间需要保证原子性；</span><br><span class="line">			2、 判断锁ID是否为自己所有和解锁需要保证原子性</span><br></pre></td></tr></table></figure></div>

<h2 id="15、Redis的双写一致性如何保证？"><a href="#15、Redis的双写一致性如何保证？" class="headerlink" title="15、Redis的双写一致性如何保证？"></a>15、Redis的双写一致性如何保证？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">采用延时双删策略：</span><br><span class="line">			<span class="number">1</span>、先淘汰缓存</span><br><span class="line">			<span class="number">2</span>、再写数据库</span><br><span class="line">			<span class="number">3</span>、休眠<span class="number">1</span>秒，再次淘汰缓存</span><br></pre></td></tr></table></figure></div>

<h2 id="16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）"><a href="#16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）" class="headerlink" title="16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）"></a>16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）</h2><p>好处：<br>            可以避免缓存雪崩（缓存失效，大量请求直达DB），提高系统的可用性<br>        流程：<br>            1、反向代理nginx将请求负载均衡到业务nginx集群<br>            2、接着业务Nginx读取本地缓存（本地缓存可以使用Lua），如果本地缓存命中则直接返回，<br>              使用应用Nginx本地缓存可以提升整体的吞吐量，降低后端的压力，尤其应对热点问题非常有效<br>            3、如果Nginx本地缓存没有命中，则会读取相应的分布式缓存（如Redis缓存，另外可以考虑使用主从架构来提升性能和吞吐量），<br>              如果分布式缓存命中则直接返回相应的数据（并会写到Nginx本地缓存）<br>            4、如果分布式缓存也没有命中，则会回源到Tomcat集群，在回源到Tomcat集群时也可以使用轮询和一致性哈希作为负载均衡算法<br>            5、在Tomcat中，首先读取本地堆缓存，如果有则直接返回（并会写到Redis集群）<br>            6、如果所有的缓存都没有命中只能查询DB或相关服务获取相关数据并返回<br>            7、返回的数据异步写到Redis</p>
<h2 id="17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？"><a href="#17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？" class="headerlink" title="17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？"></a>17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">个数：</span><br><span class="line">			16384</span><br><span class="line">		数据进行入槽方式：</span><br><span class="line">			对Key的有效部分进行运算产生hash值，再拿hash对16384进行取余，余数是多少，所属的槽就是哪个</span><br><span class="line">		实现动态扩容方式：</span><br><span class="line">			1、重新分配哈希槽</span><br><span class="line">			2、输入要分配多少个哈希槽（数量）</span><br><span class="line">			3、输入指定要分配哈希槽的节点ID</span><br><span class="line">			4、选择需要分配的哈希槽来源，分配哈希槽有两种方式：</span><br><span class="line">				1、将所有节点用作哈希槽的源节点</span><br><span class="line">				2、在指定的节点拿出指定数量的哈希槽分配到目标节点</span><br></pre></td></tr></table></figure></div>

<h1 id="七、Rabbitmq"><a href="#七、Rabbitmq" class="headerlink" title="七、Rabbitmq"></a>七、Rabbitmq</h1><h2 id="1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）"><a href="#1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）" class="headerlink" title="1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）"></a>1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、简单模式：</span><br><span class="line">			单发送单消费</span><br><span class="line">		2、工作模式：</span><br><span class="line">			单发送多接收</span><br><span class="line">		3、发布、订阅模式：</span><br><span class="line">			生产者端发送消息，多个消费者同时接收所有的消息</span><br><span class="line">		4、路由模式：</span><br><span class="line">			生产者按 routing key 发送消息，不同的消费者端按不同的 routing key 接收消息</span><br><span class="line">		5、Topic：</span><br><span class="line">			生产者端不只按固定的 routing key 发送消息，而是按字符串“匹配”发送，消费者端同样如此</span><br></pre></td></tr></table></figure></div>

<h2 id="2、Rabbitmq如何保证mq消息可靠性？（3大方面）"><a href="#2、Rabbitmq如何保证mq消息可靠性？（3大方面）" class="headerlink" title="2、Rabbitmq如何保证mq消息可靠性？（3大方面）"></a>2、Rabbitmq如何保证mq消息可靠性？（3大方面）</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、保证消息投递到MQ不丢：</span><br><span class="line">			开启生产者消息确认机制</span><br><span class="line">			<span class="number">1</span>）、开启 ConfirmCallBack 回调：消息投递至交换机的回调（成功、失败、异常）</span><br><span class="line">			<span class="number">2</span>）、开启 ReturnCallBack 回调：消息从交换机未路由到队列的回调</span><br><span class="line">		<span class="number">2</span>、保证消息到达MQ之后不丢（MQ宕机了也不影响）：</span><br><span class="line">			消息持久化(三者默认就是持久化的)</span><br><span class="line">			<span class="number">1</span>）、交换机的持久化</span><br><span class="line">			<span class="number">2</span>）、队列的持久化</span><br><span class="line">			<span class="number">3</span>）、消息的持久化</span><br><span class="line">		<span class="number">3</span>、保证消费者不丢(必须至少消费一次)：</span><br><span class="line">			开启消费者消息确认机制</span><br><span class="line">			<span class="number">1</span>）、none：没有确认机制，如果出现异常也会直接丢弃</span><br><span class="line">			<span class="number">2</span>）、manual：手动确认</span><br><span class="line">				<span class="number">1</span>、可以自己灵活的控制消息的确认和拒收</span><br><span class="line">				<span class="number">2</span>、注意：开启这个机制后一定要记得手动回执，否则将造成消息大量堆积问题</span><br><span class="line">			<span class="number">3</span>）、auto：自动确认</span><br><span class="line">				优点：</span><br><span class="line">					出现异常返回nack，正常执行返回ack，无需编写业务代码、无侵入（原理：AOP）</span><br><span class="line">				缺点：</span><br><span class="line">					当消费消息出现异常返回nack时会一直反复投递，解决：开启消费者重试机制（有一个最大重试次数）</span><br><span class="line">				消费者重试机制：</span><br><span class="line">					消息消费失败，消费者会自己发起重试，重试间隔和最大重试次数可灵活配置</span><br><span class="line">				    当超过最大重试次数时，消费者对于消息会有几种执行策略：</span><br><span class="line">						<span class="number">1</span>、直接丢弃：该消息从MQ删除</span><br><span class="line">						<span class="number">2</span>、放回队列：将消息放回至队列，然后投递给消费者，消费者进行重试，如此循环往复</span><br><span class="line">						<span class="number">3</span>、投递至指定的交换机（常用）：将消息投递至专用的交换机，绑定队列后进行精准消费</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="3、Rabbitmq如何实现延时消息？（2种）"><a href="#3、Rabbitmq如何实现延时消息？（2种）" class="headerlink" title="3、Rabbitmq如何实现延时消息？（2种）"></a>3、Rabbitmq如何实现延时消息？（2种）</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、利用死信交换机实现延时投递</span><br><span class="line">			原理：</span><br><span class="line">				消息超时未被消费会被投递至死信队列</span><br><span class="line">			设置超时：</span><br><span class="line">				<span class="number">1</span>、针对消息设置延时时间</span><br><span class="line">				<span class="number">2</span>、针对队列设置延时时间</span><br><span class="line">		<span class="number">2</span>、利用延时交换机插件实现延时投递</span><br><span class="line">			原理：</span><br><span class="line">				交换机延时路由，到达指定时间会被路由至队列</span><br></pre></td></tr></table></figure></div>

<h2 id="4、什么是死信队列？什么样的消息会进入死信队列？"><a href="#4、什么是死信队列？什么样的消息会进入死信队列？" class="headerlink" title="4、什么是死信队列？什么样的消息会进入死信队列？"></a>4、什么是死信队列？什么样的消息会进入死信队列？</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">死信队列：</span><br><span class="line">			当消息在一个队列中变成一个死信之后，如果配置了死信队列，它将被重新publish到死信交换机，</span><br><span class="line">			死信交换机将死信投递到一个队列上，这个队列就是死信队列</span><br><span class="line">		什么样的消息会进入死信队列</span><br><span class="line">			<span class="number">1</span>、超时过期的消息</span><br><span class="line">			<span class="number">2</span>、被拒绝或者nack的消息</span><br><span class="line">			<span class="number">3</span>、队列放不下的消息</span><br></pre></td></tr></table></figure></div>

<h2 id="5、Rabbitmq如何解决消息堆积问题？（3种思路）"><a href="#5、Rabbitmq如何解决消息堆积问题？（3种思路）" class="headerlink" title="5、Rabbitmq如何解决消息堆积问题？（3种思路）"></a>5、Rabbitmq如何解决消息堆积问题？（3种思路）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、针对同一队列增加多个消费者进行消息消费</span><br><span class="line">		2、针对同一消费者开启多个线程进行消息消费</span><br><span class="line">		3、加大队列的存储容量：</span><br><span class="line">			惰性队列</span><br><span class="line">			1）、原理：直接将消息写到磁盘</span><br><span class="line">			2）、优点：存储容量大，减少从内存刷消息数据至磁盘的次数，性能更稳定</span><br><span class="line">			3）、缺点：性能取决于磁盘IO</span><br></pre></td></tr></table></figure></div>

<h2 id="6、如何保证消息的幂等性？（从业务层面进行判断）"><a href="#6、如何保证消息的幂等性？（从业务层面进行判断）" class="headerlink" title="6、如何保证消息的幂等性？（从业务层面进行判断）"></a>6、如何保证消息的幂等性？（从业务层面进行判断）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、数据要写mysql，先根据主键查一下，如果这数据都有了，就别插入了，update一下</span><br><span class="line">		2、如果是写redis，那没问题了，反正每次都是set，天然幂等性</span><br><span class="line">		3、让生产者发送每条数据的时候，里面加一个全局唯一的id，然后你这里消费到了之后，先根据这个id去数据库查一下，之前消费过吗？</span><br><span class="line">		  如果没有消费过，就处理，然后这个id写到数据库。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可</span><br></pre></td></tr></table></figure></div>

<h1 id="八、微服务"><a href="#八、微服务" class="headerlink" title="八、微服务"></a>八、微服务</h1><h2 id="1、概念问题"><a href="#1、概念问题" class="headerlink" title="1、概念问题"></a>1、概念问题</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）、什么是微服务？解决微服务各种问题都用了哪些组件？</span><br><span class="line">			微服务：</span><br><span class="line">				一种良好的分布式架构方案</span><br><span class="line">				<span class="number">1</span>、优点：拆分粒度更小、服务更独立、耦合度更低</span><br><span class="line">				<span class="number">2</span>、缺点：架构非常复杂，运维、监控、部署难度提高</span><br><span class="line">			组件：</span><br><span class="line">				<span class="number">1</span>、Nacos：</span><br><span class="line">					服务注册中心和配置中心</span><br><span class="line">				<span class="number">2</span>、Ribbon：</span><br><span class="line">					服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</span><br><span class="line">				<span class="number">3</span>、Feign：</span><br><span class="line">					基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</span><br><span class="line">				<span class="number">4</span>、Hystrix：</span><br><span class="line">					发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</span><br><span class="line">				<span class="number">5</span>、Gateway：</span><br><span class="line">					如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</span><br><span class="line"></span><br><span class="line">		<span class="number">2</span>）、什么是单体架构、什么是分布式架构、什么是微服务架构？</span><br><span class="line">			单体架构：</span><br><span class="line">				将业务的所有功能集中在一个项目中开发，打成一个包部署</span><br><span class="line">				优点：</span><br><span class="line">					架构简单</span><br><span class="line">					部署成本低</span><br><span class="line">				缺点：</span><br><span class="line">					耦合度高（维护困难、升级困难）</span><br><span class="line">			分布式架构：</span><br><span class="line">				根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务</span><br><span class="line">				优点：</span><br><span class="line">					降低服务耦合</span><br><span class="line">					有利于服务升级和拓展</span><br><span class="line">				缺点：</span><br><span class="line">					服务调用关系错综复杂</span><br><span class="line">			微服务的架构：</span><br><span class="line">				给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</span><br><span class="line">				因此，可以认为微服务是一种经过良好架构设计的分布式架构方案</span><br><span class="line"></span><br><span class="line">		<span class="number">3</span>）、微服务有哪些特点？</span><br><span class="line">			单一职责：</span><br><span class="line">				微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</span><br><span class="line">			自治：</span><br><span class="line">				团队独立、技术独立、数据独立，独立部署和交付</span><br><span class="line">			面向服务：</span><br><span class="line">				服务提供统一标准的接口，与语言和技术无关</span><br><span class="line">			隔离性强：</span><br><span class="line">				服务调用做好隔离、容错、降级，避免出现级联问题</span><br></pre></td></tr></table></figure></div>

<h2 id="2、远程调用"><a href="#2、远程调用" class="headerlink" title="2、远程调用"></a>2、远程调用</h2><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span>）、什么是Feign，用来做什么的？Feign底层调用是怎么实现的？底层协议是什么？优势是什么？</span><br><span class="line">	Feign：</span><br><span class="line">		Feign是一个声明式WebService客户端。</span><br><span class="line">		使用Feign能让编写Web Service客户端更加简单，它的使用方法就是定义一个接口，然后在上面添加注解，同时也支持JAX-RS标准</span><br><span class="line">	作用：</span><br><span class="line">		使编写 java http 客户端变得容易，封装了Http调用流程，更适合面向接口化的编程习惯</span><br><span class="line">	底层调用实现流程;</span><br><span class="line">		<span class="number">1</span>、基于面向接口的动态代理方式生成实现类</span><br><span class="line">		<span class="number">2</span>、根据Contract协议规则，解析接口类的注解信息，解析成内部表现</span><br><span class="line">		<span class="number">3</span>、基于RequestBean，动态生成Request</span><br><span class="line">		<span class="number">4</span>、使用Encoder将Bean转换成Http报文正文（消息解析和转码逻辑）</span><br><span class="line">		<span class="number">5</span>、拦截器负责对请求和返回进行装饰处理</span><br><span class="line">		<span class="number">6</span>、日志记录</span><br><span class="line">		<span class="number">7</span>、基于重试器发送HTTP请求</span><br><span class="line">		<span class="number">8</span>、发送Http请求</span><br><span class="line">	底层协议：</span><br><span class="line">		Https协议</span><br><span class="line">	优势： </span><br><span class="line">      		<span class="number">1.</span>feign 采用的是基于接口的注解</span><br><span class="line">		<span class="number">2.</span>feign 整合了 ribbon，具有负载均衡的能力</span><br><span class="line">		<span class="number">3.</span>整合了 Hystrix，具有熔断的能力</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）、服务间调用，其中一个服务宕机了，这个时候怎么做呢？</span><br><span class="line">	<span class="number">1</span>、超时处理</span><br><span class="line">	<span class="number">2</span>、舱壁模式（隔离）</span><br><span class="line">	<span class="number">3</span>、熔断，降级</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）、Ribbon是什么？负载均衡策略有哪些？底层原理是什么？默认是哪种？</span><br><span class="line">	Ribbon：</span><br><span class="line">		主要功能是提供客户端的软件负载均衡算法</span><br><span class="line">	负载均衡策略：</span><br><span class="line">		<span class="number">1</span>、随机策略：</span><br><span class="line">			随机选择server</span><br><span class="line">		<span class="number">2</span>、轮询策略：</span><br><span class="line">			按照顺序选择server（ribbon默认策略）</span><br><span class="line">		<span class="number">3</span>、重试策略：</span><br><span class="line">			在一个配置时间段内，当选择server不成功，则一直尝试选择一个可用的server</span><br><span class="line">		<span class="number">4</span>、最低并发策略：</span><br><span class="line">			逐个考察server，如果server断路器打开，则忽略，再选择其中并发链接最低的server</span><br><span class="line">		<span class="number">5</span>、可用过滤策略：</span><br><span class="line">			过滤掉一直失败并被标记为 circuit tripped 的 server，过滤掉那些高并发链接的 server（active connections超过配置的阈值）</span><br><span class="line">		<span class="number">6</span>、响应时间加权重策略：</span><br><span class="line">			根据server的响应时间分配权重，响应时间越长，权重越低，被选择到的概率也就越低</span><br><span class="line">		<span class="number">7</span>、区域权重策略：</span><br><span class="line">			综合判断server所在区域的性能，和server的可用性，轮询选择server并且判断一个AWS Zone的运行性能是否可用，</span><br><span class="line">			剔除不可用的Zone中的所有server</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）、Ribbon是如何实现轮询的？如果让你自己实现轮询，如何实现？	</span><br><span class="line">	原理：</span><br><span class="line">		rest 接口的第几次请求数 % 服务器集群总数量 = 实际调用服务器的下标，每次服务重启，rest接口计数从<span class="number">1</span>开始</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）、Feign和Ribbon的关系是什么？</span><br><span class="line">	Feign 是在 Ribbon的基础上进行了一次改进，是一个使用起来更加方便的 HTTP 客户端</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）、你们项目中如何使用Feign的（Feign的最佳实践）</span><br><span class="line">	将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）、Feign远程调用时的日志级别有哪些？</span><br><span class="line">	<span class="number">1</span>、NONE，无记录（DEFAULT）</span><br><span class="line">　　　　		<span class="number">2</span>、BASIC，只记录请求方法和URL以及响应状态代码和执行时间</span><br><span class="line">　　　　		<span class="number">3</span>、HEADERS，记录基本信息以及请求和响应标头</span><br><span class="line">　　　　		<span class="number">4</span>、FULL，记录请求和响应的头文件，正文和元数据</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>）、如何优化Feign的调用性能？</span><br><span class="line">	<span class="number">1</span>、配置连接池</span><br><span class="line">	<span class="number">2</span>、设置合理的日志级别（basic级别就ok了，强烈不建议使用full）</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）、Feign的默认超时时间是多久？重试次数是几次？</span><br><span class="line">	默认超时时间：</span><br><span class="line">		<span class="number">1</span>秒</span><br><span class="line">	重试次数：</span><br><span class="line">		<span class="number">1</span>次</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>）、Dubbo服务注册与发现的原理？（官方原理图）</span><br><span class="line">	<span class="number">1</span>、服务器容器负责启动、加载、运行服务提供者</span><br><span class="line">	<span class="number">2</span>、服务提供者在启动时，向注册中心注册自己提供的服务</span><br><span class="line">	<span class="number">3</span>、服务消费者在启动时，向注册中心订阅自己需要的服务</span><br><span class="line">	<span class="number">4</span>、注册中心返沪服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</span><br><span class="line">	<span class="number">5</span>、服务消费者从提供者地址列表中基于负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用</span><br><span class="line">	<span class="number">6</span>、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>）、Dubbo负载均衡策略有哪些？默认是哪种？</span><br><span class="line">	<span class="number">1</span>、Random LoadBalance（默认）：</span><br><span class="line">		随机，按权重设置随机概率</span><br><span class="line">	<span class="number">2</span>、RoundRobin LoadBalance: </span><br><span class="line">		轮询，按公约后的权重设置轮询比例</span><br><span class="line">	<span class="number">3</span>、LeastActive LoadBalance：</span><br><span class="line">		最少活跃调用数，相同活跃数的随机</span><br><span class="line">	<span class="number">4</span>、ConstantHash LoadBalance：</span><br><span class="line">		一致性 Hash，相同参数的请求总是发到同意提供者</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>）、Dubbo支持哪些通信协议？默认是哪种？一般用哪种协议？有什么好处？</span><br><span class="line">	Dubbo支持<span class="number">9</span>种通信协议：</span><br><span class="line">		<span class="number">1</span>、dubbo 协议</span><br><span class="line">		<span class="number">2</span>、rmi 协议</span><br><span class="line">		<span class="number">3</span>、hessian 协议</span><br><span class="line">		<span class="number">4</span>、http 协议</span><br><span class="line">		<span class="number">5</span>、webservice 协议</span><br><span class="line">		<span class="number">6</span>、thrift 协议</span><br><span class="line">		<span class="number">7</span>、memcached 协议</span><br><span class="line">		<span class="number">8</span>、redis 协议</span><br><span class="line">		<span class="number">9</span>、rest</span><br><span class="line">	默认是哪种：</span><br><span class="line">		dubbo 协议 (默认)</span><br><span class="line">	一般用哪种协议：</span><br><span class="line">		dubbo 协议</span><br><span class="line">	好处：</span><br><span class="line">		底层是TCP，效率快</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>）、注册中心挂了影响服务调用吗？为什么？</span><br><span class="line">	不会</span><br><span class="line">	因为启动dubbo时，消费者会从注册中心拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>）、Dubbo启动检查如何设置？多版本支持如何设置？</span><br><span class="line">	启动检查：</span><br><span class="line">		可以通过配置信息 check=<span class="string">&quot;false&quot;</span> 关闭检查</span><br><span class="line">	多版本支持：</span><br><span class="line">		<span class="meta">@DubboService(version = “2.0.0”)</span></span><br><span class="line">		<span class="meta">@DubboReference(version = &quot;2.0.0&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="number">13</span>）、Dubbo的默认超时时间是多久？重试次数是几次？</span><br><span class="line">	默认超时时间：</span><br><span class="line">		<span class="number">1</span>秒</span><br><span class="line">	默认重试次数：</span><br><span class="line">		<span class="number">2</span>次</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>）、Dubbo进行服务注册和发现的核心注解是哪个？</span><br><span class="line">	<span class="meta">@DubboService</span></span><br><span class="line">	<span class="meta">@DubboReference</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>）、Dubbo服务如何进行监控和管理？</span><br><span class="line">	dubbo-admin 监控中心</span><br></pre></td></tr></table></figure></div>

<h2 id="3、注册中心"><a href="#3、注册中心" class="headerlink" title="3、注册中心"></a>3、注册中心</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">3、配置中心1）、Eureka</span><br><span class="line">			1、eureka是属于什么体系的技术（Spring Cloud）</span><br><span class="line">				Spring Cloud</span><br><span class="line">			2、eureka技术体系有哪些角色？（服务端用作注册中心，客户端用作微服务）</span><br><span class="line">				服务端用作注册中心，客户端用作微服务</span><br><span class="line">			3、eureka的自我保护机制是什么？什么时候开启？为什么开启？开启了会发生什么？</span><br><span class="line">				自我保护机制：</span><br><span class="line">					某时刻某个微服务不能用了，eureka不会立刻清理，而是对该微服务进行保存</span><br><span class="line">				开启时间：</span><br><span class="line">					当EurekaServer节点在短时间内丢失过多客户端时候(可能发生了网络分区故障)</span><br><span class="line">				为什么开启：</span><br><span class="line">					默认情况下，如果EurekaServer在一定时间内没有收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90s)。</span><br><span class="line">					但是当网络分区故障发生(延时、卡顿、拥挤)时候，微服务与EurekaServer之间无法正常通信，</span><br><span class="line">					以上行为可能变得非常危险了，因为微服务本身其实是健康的。此时本不应该注销这个微服务的</span><br><span class="line">				开启了会发生什么：</span><br><span class="line">					一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据。也就是不会注销任何微服务</span><br><span class="line"></span><br><span class="line">			4、eureka作为注册中心的原理是什么？心跳检测某个服务是否健康的原理详细说下？</span><br><span class="line">				原理：</span><br><span class="line">					1、服务提供者启动后将注册到注册中心，提供IP, 名字，什么服务等信息，</span><br><span class="line">				    2、服务消费者作为客户端注册到注册中心后，拉取注册中心的服务列表，在通过负载均衡调用对应的服务提供者。</span><br><span class="line">				    3、注册中心可以建立集群，生成多台eureka，注册中心为了监测各个服务的心跳，将在每 30S 向所注册的服务发起请求判断</span><br><span class="line">				    4、服务是否挂掉，如果挂掉90S后将会将服务从注册中心剔除。</span><br><span class="line">				      一个服务可以监测多台服务实例，从而可实现均衡负载。</span><br><span class="line">				心跳检测：</span><br><span class="line">					在应用启动后，节点们将会向Eureka Server发送心跳,默认周期为30秒，</span><br><span class="line">					如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，</span><br><span class="line">					Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)。</span><br><span class="line"></span><br><span class="line">			5、eureka集群是属于AP还是CP？(AP)</span><br><span class="line">				AP</span><br><span class="line">	2）、Nacos</span><br><span class="line">			1、nacos是属于什么体系的技术（Spring Cloud Alibaba）</span><br><span class="line">				Spring Cloud Alibaba</span><br><span class="line"></span><br><span class="line">			2、nacos作为注册中心的原理是什么？</span><br><span class="line">				服务注册时在服务端本地会通过轮询注册中心集群节点地址进行服务注册，</span><br><span class="line">				在注册中心上，即Nacos Server上采用了Map保存实例信息，当然配置了持久化的服务会被保存到数据库中，</span><br><span class="line">				在服务的调用方，为了保证本地服务实例列表的动态感知，Nacos与其他注册中心不同的是，采用了 Pull/Push同时运作的方式</span><br><span class="line"></span><br><span class="line">			3、nacos如何确定唯一的一个服务?（通过namespace、group、service、集群唯一确定一个服务）</span><br><span class="line">				通过namespace、group、service、集群唯一确定一个服务</span><br><span class="line"></span><br><span class="line">			4、nacos中namespace、group分别的作用是什么？</span><br><span class="line">				namespace：</span><br><span class="line">					用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置</span><br><span class="line">				group：</span><br><span class="line">					Nacos中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串对配置集进行分组，从而区分 Data ID 相同的配置集</span><br><span class="line"></span><br><span class="line">			5、nacos和eureka的异同有哪些？</span><br><span class="line">				相同点：</span><br><span class="line">					1、都支持服务注册和服务拉取</span><br><span class="line">					2、都支持服务提供者心跳的方式做健康检测</span><br><span class="line">				不同点：</span><br><span class="line">					1、nacos支持服务端主动检测提供者状态：</span><br><span class="line">						临时实例采用心跳模式，非临时实例采用主动检测模式（一般情况下都使用临时实例，主动检测消费的服务器资源较大，服务器压力大）</span><br><span class="line">					2、临时实例心跳不正常会被剔除，非临时实例则不会被剔除</span><br><span class="line">					3、nacos支持服务列表变更的消息推送模式，服务列表更新及时</span><br><span class="line">					4、nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；eureka采用AP方式</span><br><span class="line"></span><br><span class="line">			6、nacos的临时节点和非临时节点有什么区别？</span><br><span class="line">				非临时实例挂掉后不会被nacos剔除，而是等待他重连</span><br><span class="line"></span><br><span class="line">			7、nacos集群是属于AP还是CP？(AP或CP)</span><br><span class="line">				nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式</span><br><span class="line">			</span><br><span class="line">		3）、Zookeeper</span><br><span class="line">			1、Zookeeper的内部结构是什么？</span><br><span class="line">				ZooKeeper维护和操作一个小型的数据节点，这些节点被称之为znode，采用类似于文件系统的层级树状结构进行管理</span><br><span class="line"></span><br><span class="line">			2、使用Zookeeper作为分布式事务锁的原理是什么？</span><br><span class="line">				锁分为两种：</span><br><span class="line">					共享锁（读锁）和排他锁（写锁）</span><br><span class="line">				读锁：</span><br><span class="line">					当有一个线程获取读锁后，其他线程也可以获取读锁，但是在读锁没有完全被释放之前，其他线程不能获取写锁。</span><br><span class="line">				写锁：</span><br><span class="line">					当有一个线程获取写锁后，其他线程就无法获取读锁和写锁了。</span><br><span class="line">				zookeeper 有一种节点类型叫做临时序号节点，它会按序号自增地创建临时节点，这正好可以作为分布式锁的实现工具。</span><br><span class="line"></span><br><span class="line">			3、Zookeeper集群属于AP还是CP？(CP)</span><br><span class="line">				CP</span><br></pre></td></tr></table></figure></div>

<h2 id="3、配置中心"><a href="#3、配置中心" class="headerlink" title="3、配置中心"></a>3、配置中心</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1）、实现配置中心都可以使用哪些技术？</span><br><span class="line">			1、Spring Cloud Config</span><br><span class="line">			2、Apollo</span><br><span class="line">			3、Nacos</span><br><span class="line"></span><br><span class="line">		2）、使用nacos作为配置中心，如何实现热更新？</span><br><span class="line">			1、在 @Value 注入的变量所在的类上添加注解 @RefreshScope</span><br><span class="line">			2、使用 @ConfigurationProperties(prefix = &quot;pattern&quot;) 注解</span><br><span class="line"></span><br><span class="line">		3）、nacos作为配置中心，为什么需要用到bootstrap文件？</span><br><span class="line">			得知nacos地址、配置文件id</span><br><span class="line"></span><br><span class="line">		4）、远程配置文件和本地配置文件属性加载优先级是什么样的？</span><br><span class="line">			远程 &gt; 本地</span><br><span class="line">			高优先级的会覆盖低优先级的重复的配置内容</span><br><span class="line"></span><br><span class="line">		5）、使用配置中心的好处是什么？能解决什么问题？</span><br><span class="line">			好处：</span><br><span class="line">				将配置文件集中管理</span><br><span class="line">			解决的问题：</span><br><span class="line">				可以在配置变更时，及时通知微服务，实现配置的热更新</span><br></pre></td></tr></table></figure></div>

<h2 id="4、服务保护"><a href="#4、服务保护" class="headerlink" title="4、服务保护"></a>4、服务保护</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">1）、Hystrix</span><br><span class="line">			1、hystrix是属于什么体系的技术？（SpringCloud）</span><br><span class="line">				SpringCloud</span><br><span class="line"></span><br><span class="line">			2、hystrix可以用来干嘛？（服务熔断降级）</span><br><span class="line">				服务熔断降级</span><br><span class="line"></span><br><span class="line">			3、hystrix默认的触发熔断策略是什么？（5分钟之内服务调用异常比例达到一半或者失败次数超过20次）</span><br><span class="line">				5分钟之内服务调用异常比例达到一半或者失败次数超过20次</span><br><span class="line"></span><br><span class="line">			4、hystrix的隔离是基于什么？（线程池隔离【低扇出】）</span><br><span class="line">				线程池隔离（低扇出）</span><br><span class="line"></span><br><span class="line">		2）、Sentinel</span><br><span class="line">			1、sentinel可以用来干嘛？（限流、隔离、熔断、降级）</span><br><span class="line">				限流、隔离、熔断、降级</span><br><span class="line"></span><br><span class="line">			2、什么是微服务雪崩现象？如何解决微服务雪崩问题？</span><br><span class="line">				微服务雪崩：</span><br><span class="line">					微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况</span><br><span class="line">				解决方案：</span><br><span class="line">					 1、超时处理</span><br><span class="line">				     2、船壁模式（隔离）</span><br><span class="line">				     3、熔断，降级</span><br><span class="line"></span><br><span class="line">			3、sentinel的限流模式有哪些？分别的运用场景是什么？</span><br><span class="line">				1、直接：</span><br><span class="line">					对当前资源限流</span><br><span class="line">			    2、关联： </span><br><span class="line">			    	比如用户支付时需要修改订单状态，同时用户要查询订单。</span><br><span class="line">					查询和修改操作会争抢数据库锁，产生竞争。</span><br><span class="line">					业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</span><br><span class="line">			    3、链路：</span><br><span class="line">			    	阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流</span><br><span class="line"></span><br><span class="line">			4、sentinel的限流效果有哪些？分别的运用场景是什么？</span><br><span class="line">				1、快速失败：</span><br><span class="line">					QPS超过阈值时，拒绝新的请求</span><br><span class="line">	      		2、warm up：</span><br><span class="line">	      			QPS超过阈值时，拒绝新的请求；</span><br><span class="line">	      			QPS阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机</span><br><span class="line">	      		3、排队等待：</span><br><span class="line">	      			请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝</span><br><span class="line">	      		4、热点参数：</span><br><span class="line">	      			分别统计参数值相同的请求，判断是否超过QPS阈值</span><br><span class="line"></span><br><span class="line">			5、sentinel支持对热点参数进行限流吗？</span><br><span class="line">				支持</span><br><span class="line"></span><br><span class="line">			6、实现微服务调用隔离有两种方式（信号量隔离和线程池隔离），区别是什么？sentinel是使用的哪种？</span><br><span class="line">				区别：</span><br><span class="line">					1、信号量隔离：</span><br><span class="line">			            不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</span><br><span class="line">			            特点：基于计数器模式，简单，开销小；高扇出</span><br><span class="line">		    		2、线程池隔离</span><br><span class="line">			            给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</span><br><span class="line">			            特点：基于线程池模式，有额外开销，但隔离控制更强；低扇出</span><br><span class="line">			    sentinel是使用的哪种：</span><br><span class="line">			    	信号量隔离</span><br><span class="line"></span><br><span class="line">			7、什么是熔断？熔断的原理是什么？什么时候会触发sentinel的熔断？断路器的三种状态是哪些？是怎样进行切换的？</span><br><span class="line">				概念：</span><br><span class="line">					熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），</span><br><span class="line">					对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误</span><br><span class="line">				熔断的原理：</span><br><span class="line">					断路器</span><br><span class="line">				什么时候会触发sentinel的熔断：</span><br><span class="line">					1、慢调用</span><br><span class="line">					2、异常比例或者异常数</span><br><span class="line">				断路器的三种状态是哪些，是怎样进行切换的：</span><br><span class="line">					1、关闭：默认就是关闭的</span><br><span class="line">					2、半开：开启后到达指定（可配置）的时间，开启半开状态，尝试接收请求</span><br><span class="line">									如果成功：状态置为关闭</span><br><span class="line">									如果失败：状态置为开启</span><br><span class="line">					3、开启：当触发配置的阈值，会开启</span><br><span class="line"></span><br><span class="line">			8、什么是降级？如何实现降级？</span><br><span class="line">				概念：</span><br><span class="line">					当微服务调用失败，客户端走降级逻辑</span><br><span class="line">				如何实现降级：</span><br><span class="line">					1、FallBackClass</span><br><span class="line">					2、FallBackFactoryClass（优势：可以获取服务端抛出的异常）</span><br><span class="line"></span><br><span class="line">			9、sentinel授权规则是用来干什么的？</span><br><span class="line">				授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式：</span><br><span class="line">					1、白名单：来源（origin）在白名单内的调用者允许访问</span><br><span class="line">					2、黑名单：来源（origin）在黑名单内的调用者不允许访问</span><br><span class="line"></span><br><span class="line">			10、sentinel的规则持久化方式有哪些？一般使用哪种？</span><br><span class="line">				sentinel的规则持久化方式：</span><br><span class="line">					1、原始模式：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。</span><br><span class="line">				    2、pull模式</span><br><span class="line">				    3、push模式</span><br><span class="line">			    一般使用哪种：</span><br><span class="line">			    	push模式</span><br></pre></td></tr></table></figure></div>

<h2 id="5、网关"><a href="#5、网关" class="headerlink" title="5、网关"></a>5、网关</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1）、网关有什么作用？在你们项目中用网关来干嘛了？</span><br><span class="line">			1、权限控制：</span><br><span class="line">				网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</span><br><span class="line">			2、路由和负载均衡：</span><br><span class="line">				一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。</span><br><span class="line">				当然路由的目标服务有多个时，还需要做负载均衡。</span><br><span class="line">			3、限流：</span><br><span class="line">				当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</span><br><span class="line"></span><br><span class="line">		2）、网关的核心技术点有哪些？</span><br><span class="line">			1、断言工厂</span><br><span class="line">			2、过滤器工厂</span><br><span class="line">			3、全局过滤器</span><br><span class="line">			4、解决跨域</span><br><span class="line"></span><br><span class="line">		3）、网关的路由是用来干嘛的？分为哪几种？</span><br><span class="line">			路由的作用：</span><br><span class="line">				一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务</span><br><span class="line">			分为哪几种：</span><br><span class="line">				静态路由、动态路由</span><br><span class="line"></span><br><span class="line">		4）、网关的过滤器是用来干嘛的？分为哪几种？</span><br><span class="line">			网关的过滤器作用：</span><br><span class="line">				可以对进入网关的请求和微服务返回的响应做处理</span><br><span class="line">			分为哪几种：</span><br><span class="line">				1、路由过滤器</span><br><span class="line">				2、请求头过滤器</span><br><span class="line">				3、默认过滤器</span><br><span class="line"></span><br><span class="line">		5）、网关局部过滤器和全局过滤器的区别有哪些？</span><br><span class="line">			局部过滤器：</span><br><span class="line">				拦截经过网关的特定服务的请求</span><br><span class="line">			全局过滤器：</span><br><span class="line">				无差别拦截所有经过网关 的请求</span><br><span class="line"></span><br><span class="line">		6）、网关中局部过滤器、默认过滤器、全局过滤器的执行顺序是什么？</span><br><span class="line">			默认过滤器 &gt; 局部过滤器 &gt; 全局过滤器</span><br><span class="line"></span><br><span class="line">		7）、加入网关后，访问一个链接，你们项目的执行流程是什么？</span><br><span class="line">			1、客户端发送请求</span><br><span class="line">			2、进行权限校验，如果是登录或者注册操作则直接放行</span><br><span class="line">			3、校验通过生成该用户的token，校验失败拦截</span><br><span class="line">			4、路由匹配到某个微服务</span><br><span class="line"></span><br><span class="line">		8）、定义全局过滤器需要实现哪几个接口？</span><br><span class="line">			GlobalFilter</span><br></pre></td></tr></table></figure></div>

<h2 id="6、分布式事务"><a href="#6、分布式事务" class="headerlink" title="6、分布式事务"></a>6、分布式事务</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">1）、什么是本地事务？什么是分布式事务？</span><br><span class="line">			本地事务：</span><br><span class="line">				无需跨越多个服务或者数据源的单体事务，一般由spring控制即可（声明式事务处理：AOP）</span><br><span class="line">			分布式事务：</span><br><span class="line">				指一个业务跨越多个服务或者数据源，每个事务叫做分支事务，要保证所有分支事务要么成功，要么失败</span><br><span class="line"></span><br><span class="line">		2）、什么是CAP定理？为什么必须保证P？为什么在保证P的前提下只能保证C或者A其中一个？</span><br><span class="line">			CAP定理：</span><br><span class="line">				Consistency（一致性）、Availability（可用性）、Partition tolerance （分区容错性），这三个指标不可能同时做到</span><br><span class="line">			为什么必须保证P：	</span><br><span class="line">				在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免</span><br><span class="line">			为什么在保证P的前提下只能保证C或者A其中一个：</span><br><span class="line">				如果此时要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。</span><br><span class="line">				如果此时要保证可用性，就不能等待网络恢复，那 node01、node02、node03 之间就会出现数据不一致。</span><br><span class="line"></span><br><span class="line">		3）、什么是BASE理论？</span><br><span class="line">			BASE理论是对CAP的一种解决思路，包含三个思想：</span><br><span class="line">				1、Basically Available（基本可用）：</span><br><span class="line">					分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</span><br><span class="line">				2、Soft State（软状态）：</span><br><span class="line">					在一定时间内，允许出现中间状态，比如临时的不一致状态</span><br><span class="line">				3、Eventually Consistent（最终一致性）：</span><br><span class="line">					虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</span><br><span class="line"></span><br><span class="line">		4）、seata解决分布式事务的三个角色以及分别的作用什么？</span><br><span class="line">			1、TC (Transaction Coordinator) - 事务协调者：</span><br><span class="line">				维护全局和分支事务的状态，协调全局事务提交或回滚</span><br><span class="line">            2、TM (Transaction Manager) - 事务管理器：</span><br><span class="line">            	定义全局事务的范围、开始全局事务、提交或回滚全局事务</span><br><span class="line">            3、RM (Resource Manager) - 资源管理器：</span><br><span class="line">            	管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</span><br><span class="line"></span><br><span class="line">		5）、seata解决分布式事务的四种模式</span><br><span class="line">			1、XA</span><br><span class="line">			2、AT</span><br><span class="line">			3、TCC</span><br><span class="line">			4、SAGA</span><br><span class="line"></span><br><span class="line">		6）、XA模式特点、原理以及应用场景？优缺点有哪些？</span><br><span class="line">			特点：</span><br><span class="line">				强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入 （CP）</span><br><span class="line">			原理：</span><br><span class="line">				1）、第一阶段：</span><br><span class="line">					1、TM：</span><br><span class="line">						1、开启全局事务</span><br><span class="line">						2、调用分支事务</span><br><span class="line">					2、TC: </span><br><span class="line">						接收开启全局事务的请求</span><br><span class="line">					3、RM: </span><br><span class="line">						1、将分支事务注册到TC服务</span><br><span class="line">						2、执行本地sql，但是，重点：不提交事务！！！！</span><br><span class="line">						3、将本地事务状态报告至TC服务	</span><br><span class="line">				2）、第二阶段：</span><br><span class="line">					1、TM：</span><br><span class="line">						等第一阶段所有分支事务执行完，发起提交/回滚全局事务的命令</span><br><span class="line">					2、TC:</span><br><span class="line">						接收全局事务提交/回滚请求，核查所有分支事务的状态，对RM发起提交/回滚的命令</span><br><span class="line">					3、RM:</span><br><span class="line">						提交或者回滚当前的分支事务(依赖于数据库)</span><br><span class="line">			优点：</span><br><span class="line">				强一致性、无代码侵入、实现简单</span><br><span class="line">			缺点：</span><br><span class="line">				强依赖于关系型数据库实现回滚、性能比较差</span><br><span class="line"></span><br><span class="line">		7）、AT模式特点、原理以及应用场景？优缺点有哪些？有可能会出现什么问题？如何解决？</span><br><span class="line">			特点：</span><br><span class="line">				同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷，属于最终一致（AP）</span><br><span class="line">			原理：</span><br><span class="line">				1）、第一阶段：</span><br><span class="line">					1、TM:</span><br><span class="line">						1、开启全局事务</span><br><span class="line">						2、调用分支事务</span><br><span class="line">					2、TC:</span><br><span class="line">						接收开启全局事务的请求</span><br><span class="line">					3、RM：</span><br><span class="line">						1、将分支事务注册到TC服务</span><br><span class="line">						2、执行本地sql，重点：提交事务！！！！</span><br><span class="line">						3、执行sql前后，生成快照:undo_log</span><br><span class="line">						4、将本地事务状态报告至TC服务</span><br><span class="line">				2）、第二阶段：</span><br><span class="line">					1、TM：</span><br><span class="line">						等第一阶段所有分支事务执行完，发起提交/回滚全局事务的命令</span><br><span class="line">					2、TC:</span><br><span class="line">						接收全局事务提交/回滚请求，核查所有分支事务的状态，对RM发起提交/回滚的命令</span><br><span class="line">					3、RM:</span><br><span class="line">						提交或者回滚当前的分支事务（依赖于undo_log快照数据）</span><br><span class="line">						提交：删除快照数据</span><br><span class="line">						回滚：根据快照进行数据恢复</span><br><span class="line">			优点：</span><br><span class="line">				1、一阶段完成直接提交事务，释放数据库资源，性能比较好</span><br><span class="line">				2、利用全局锁实现读写隔离</span><br><span class="line">				3、没有代码侵入，框架自动完成回滚和提交</span><br><span class="line">			缺点：</span><br><span class="line">				1、两阶段之间属于软状态，属于最终一致</span><br><span class="line">				2、框架的快照功能会影响性能，但比XA模式要好很多</span><br><span class="line">			可能出现的问题：</span><br><span class="line">				脏写：当全局事务1提交修改的数据后，此时全局事务2又过来修改了这条数据</span><br><span class="line">					 后续阶段二全局事务1需要利用快照进行回滚，将全局事务2的所有修改进行了覆盖</span><br><span class="line">			解决方案：</span><br><span class="line">				seata内部提供了全局锁的概念（需要在seata server新增一张全局锁的表）</span><br><span class="line">				但是全局锁有可能导致死锁（内部通过限制获取全局锁的次数来解决：30次/10ms）</span><br><span class="line"></span><br><span class="line">		8）、重点：TCC模式特点、原理以及应用场景？优缺点有哪些？有可能会出现什么问题？什么是空回滚和业务悬挂，如何解决？</span><br><span class="line">			特点：</span><br><span class="line">				与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。属于最终一致（AP）</span><br><span class="line">			原理：</span><br><span class="line">				1、T: Try，进行资源的检测和预留</span><br><span class="line">				2、C：Confirm，对资源进行确认操作（业务执行和提交）</span><br><span class="line">				3、C：Cancle，对资源进行回滚操作（预留资源的释放）</span><br><span class="line">			优点：</span><br><span class="line">				1、一阶段完成直接提交事务，释放数据库资源，性能好</span><br><span class="line">				2、相比AT模型，无需生成快照，无需使用全局锁，性能最强</span><br><span class="line">				3、不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</span><br><span class="line">			缺点：</span><br><span class="line">				1、有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦</span><br><span class="line">				2、软状态，事务是最终一致</span><br><span class="line">				3、需要考虑Confirm和Cancel的失败情况，做好幂等处理</span><br><span class="line">			可能出现的问题：</span><br><span class="line">				1、空回滚</span><br><span class="line">					问题描述：</span><br><span class="line">						当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。</span><br><span class="line">						在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，则就是空回滚。</span><br><span class="line">					解决办法：</span><br><span class="line">						执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。</span><br><span class="line">				2、业务悬挂</span><br><span class="line">					问题描述：</span><br><span class="line">						对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能</span><br><span class="line">					  	confirm或cancel ，事务一直处于中间状态，这就是业务悬挂。</span><br><span class="line">					解决办法：</span><br><span class="line">						执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂		</span><br><span class="line"></span><br><span class="line">		9）、SAGA模式特点、原理以及应用场景？优缺点有哪些？</span><br><span class="line">			概念：</span><br><span class="line">				Saga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。</span><br><span class="line">			原理：</span><br><span class="line">				在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</span><br><span class="line">				分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。</span><br><span class="line">				如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，</span><br><span class="line">				使分布式事务回到初始状态。</span><br><span class="line">			优点：</span><br><span class="line">				1、事务参与者可以基于事件驱动实现异步调用，吞吐高</span><br><span class="line">				2、一阶段直接提交事务，无锁，性能好</span><br><span class="line">				3、不用编写TCC中的三个阶段，实现简单</span><br><span class="line">			缺点：</span><br><span class="line">				1、软状态持续时间不确定，时效性差</span><br><span class="line">				2、没有锁，没有事务隔离，会有脏写</span><br></pre></td></tr></table></figure></div>

<h1 id="九、Docker"><a href="#九、Docker" class="headerlink" title="九、Docker"></a>九、Docker</h1><h2 id="1、什么是Docker？优点是什么？有哪些核心概念？"><a href="#1、什么是Docker？优点是什么？有哪些核心概念？" class="headerlink" title="1、什么是Docker？优点是什么？有哪些核心概念？"></a>1、什么是Docker？优点是什么？有哪些核心概念？</h2><p>概念：<br>            Docker是一个快速交付应用、运行应用的技术<br>        优点：<br>            1、可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统<br>            2、运行时利用沙箱机制形成隔离容器，各个应用互不干扰<br>            3、启动、移除都可以通过一行命令完成，方便快捷<br>        核心概念：<br>            解决大型项目依赖关系复杂，不同组件依赖的兼容性问题：<br>                1、Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像<br>                2、Docker应用运行在容器中，使用沙箱机制，相互隔离<br>            解决开发、测试、生产环境有差异的问题：<br>                Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</p>
<h2 id="2、镜像操作命令有哪些？"><a href="#2、镜像操作命令有哪些？" class="headerlink" title="2、镜像操作命令有哪些？"></a>2、镜像操作命令有哪些？</h2><p>拉取、推送、查看、查看所有、删除、删除所有、制作镜像、导出镜像、加载镜像</p>
<h2 id="3、容器操作命令有哪些？"><a href="#3、容器操作命令有哪些？" class="headerlink" title="3、容器操作命令有哪些？"></a>3、容器操作命令有哪些？</h2><p>查看所有、查看正在运行的容器、删除、强制删除、创建容器、创建并运行、<br>        启动容器、停止容器、重启容器、暂停容器、恢复容器、进入容器</p>
<h2 id="4、数据卷操作命令有哪些？"><a href="#4、数据卷操作命令有哪些？" class="headerlink" title="4、数据卷操作命令有哪些？"></a>4、数据卷操作命令有哪些？</h2><p>创建数据卷、查看单个数据卷详情、查看数据卷列表、删除数据卷、删除未使用的数据卷、创建容器时挂载数据卷</p>
<h2 id="5、docker如何自定义镜像？docker-file的语法是什么样的？"><a href="#5、docker如何自定义镜像？docker-file的语法是什么样的？" class="headerlink" title="5、docker如何自定义镜像？docker file的语法是什么样的？"></a>5、docker如何自定义镜像？docker file的语法是什么样的？</h2><p>自定义镜像：<br>            1、准备基础镜像和tar包<br>            2、创建Dockerfile<br>            3、使用Dockerfile创建镜像<br>        docker file的语法：<br>            保留字指令要大写，后边有空格，后边必须有内容。 比如：FROM scratch<br>             指令从上往下依次执行</p>
<h2 id="6、docker-compose是干嘛的-语法是什么样的？"><a href="#6、docker-compose是干嘛的-语法是什么样的？" class="headerlink" title="6、docker compose是干嘛的?语法是什么样的？"></a>6、docker compose是干嘛的?语法是什么样的？</h2><p>作用：<br>            调用docker服务的API负责实现对docker容器集群的快速编排，即通过一个单独的yaml文件，来定义一组相关的容器来为一个项目服务<br>        语法：<br>            一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分</p>
<h1 id="十、ElasticSearch"><a href="#十、ElasticSearch" class="headerlink" title="十、ElasticSearch"></a>十、ElasticSearch</h1><h2 id="1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？"><a href="#1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？" class="headerlink" title="1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？"></a>1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？</h2><p>概念：<br>            1）、是一款分布式、高性能、高扩展，支持海量数据分析、搜索、计算的搜索引擎<br>            2）、基于Java语言编写，发起的请求时基于Json风格的符合RestFull风格的DSL语句<br>            3）、前身Lucene诞生于1999年，2004年变为了compass，2010年重构成了现在的ES<br>            4）、ELK：是一个围绕ElasticSearch的技术栈，包含：ElasticSearch、Logstatch、Kibana，最新版本7.16.3<br>            5）、Solr：是ES的一款竞品，2016被ES反超，主流成为ES<br>        由什么语言编写:<br>            Java<br>        和Lunce的关系:<br>            前身Lucene诞生于1999年，2004年变为了compass，2010年重构成了现在的ES<br>        什么是ELK:<br>            是一个围绕ElasticSearch的技术栈，包含：ElasticSearch、Logstatch、Kibana，最新版本7.16.3    </p>
<h2 id="2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？"><a href="#2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？" class="headerlink" title="2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？"></a>2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？</h2><p>核心概念：<br>            1）、倒排索引<br>                对文档进行合理化的分词，形成一个不重复的词条列表，每一个词条对应一个文档id集合，将来根据文档分成词条找id，<br>                再根据id找到相应的文档（涉及到两次的Btree查询）<br>            2）、索引 – index<br>                同一类型文档的集合，相当于mysql的表<br>            3）、映射 – mapping<br>                对索引结构的约束，相当于mysql的schema（约束）（表结构）<br>            4）、文档 – document<br>                Json格式的数据，相当于mysql的row（行）<br>            5）、字段 – field<br>                一个个的字段，相当于mysql的列<br>            6）、DSL语句<br>                Json风格的符合restful风格的请求语句    </p>
<h2 id="3、什么是倒排索引？倒排索引建立过程？"><a href="#3、什么是倒排索引？倒排索引建立过程？" class="headerlink" title="3、什么是倒排索引？倒排索引建立过程？"></a>3、什么是倒排索引？倒排索引建立过程？</h2><p>倒排索引：<br>            对文档进行合理化的分词，形成一个不重复的词条列表，每一个词条对应一个文档id集合，将来根据文档分成词条找id，<br>            再根据id找到相应的文档（涉及到两次的Btree查询）<br>        倒排索引建立过程：<br>            1、将每一个文档的数据利用算法分词，得到一个个词条<br>            2、创建表，每行数据包括词条、词条所在文档id、位置等信息<br>            3、因为词条唯一性，可以给词条创建索引，例如hash表结构索引</p>
<h2 id="4、ES有哪些数据类型？keyword和text有什么区别？"><a href="#4、ES有哪些数据类型？keyword和text有什么区别？" class="headerlink" title="4、ES有哪些数据类型？keyword和text有什么区别？"></a>4、ES有哪些数据类型？keyword和text有什么区别？</h2><p>数据类型：<br>            1、字符串：<br>                text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）<br>            2、数值：<br>                long、integer、short、byte、double、float、<br>            3、布尔：<br>                boolean<br>            4、日期：<br>                date<br>            5、对象：<br>                object<br>        keyword和text有什么区别：<br>            text可分词，keyword不可分词</p>
<h2 id="5、重要：说说用户输入框输入查询条件-进行ES搜索的底层原理过程"><a href="#5、重要：说说用户输入框输入查询条件-进行ES搜索的底层原理过程" class="headerlink" title="5、重要：说说用户输入框输入查询条件 进行ES搜索的底层原理过程"></a>5、重要：说说用户输入框输入查询条件 进行ES搜索的底层原理过程</h2><p>1、如果用户输入条件“华为手机”进行搜索。<br>        2、对用户输入内容分词，得到词条：“华为”、“手机”。<br>        3、拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。<br>        4、拿着文档id到正向索引中查找具体文档。</p>
<h2 id="6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）"><a href="#6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）" class="headerlink" title="6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）"></a>6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）</h2><p>建立倒排索引时对文档分词和用户搜索时对搜索条件分词</p>
<h2 id="7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？"><a href="#7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？" class="headerlink" title="7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？"></a>7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？</h2><p>用的哪种:<br>            IK分词器<br>        为什么要自定义拼音分词器：<br>            要实现根据字母做补全，就必须对文档按照拼音分词。<br>            默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器<br>        为什么搜索时不能用拼音分词器：<br>            为了避免搜索到同音字，搜索时不要使用拼音分词器</p>
<h2 id="8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？"><a href="#8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？" class="headerlink" title="8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？"></a>8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？</h2><p>查询类型：<br>            1、查询所有：<br>                查询出所有数据，一般测试用。例如：match_all<br>            2、全文检索（full text）查询：<br>                利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：<br>                match_query<br>                multi_match_query<br>            3、精确查询：<br>                根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：<br>                    ids<br>                    range<br>                    term<br>            4、地理（geo）查询：<br>                根据经纬度查询。例如：<br>                    geo_distance<br>                    eo_bounding_box<br>            5、复合（compound）查询：<br>                复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：<br>                    bool<br>                    function_score<br>        如何实现复合查询：<br>            1、根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score）<br>            2、根据过滤条件，过滤文档<br>            3、符合过滤条件的文档，基于算分函数运算，得到函数算分（function score）<br>            4、将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。<br>        给指定的数据进行加分如何实现：<br>            算分函数：<br>                可以简单粗暴，直接给固定的算分结果，weight</p>
<h2 id="9、给指定的数据进行加分如何实现？如何实现高亮？"><a href="#9、给指定的数据进行加分如何实现？如何实现高亮？" class="headerlink" title="9、给指定的数据进行加分如何实现？如何实现高亮？"></a>9、给指定的数据进行加分如何实现？如何实现高亮？</h2><p>给指定的数据进行加分如何实现：<br>            1、排序<br>            2、分页<br>            3、高亮<br>        如何实现高亮：<br>            1、给文档中的所有关键字都添加一个标签，例如<em>标签<br>            2、页面给<em>标签编写CSS样式</p>
<h2 id="10、ES有哪些聚合查询？"><a href="#10、ES有哪些聚合查询？" class="headerlink" title="10、ES有哪些聚合查询？"></a>10、ES有哪些聚合查询？</h2><p>1、桶（Bucket）聚合：<br>            用来对文档做分组<br>        2、度量（Metric）聚合：<br>            用以计算一些值，比如：最大值、最小值、平均值等<br>        3、管道（pipeline）聚合：<br>            其它聚合的结果为基础做聚合</p>
<h2 id="11、ES如何实现自动补全查询"><a href="#11、ES如何实现自动补全查询" class="headerlink" title="11、ES如何实现自动补全查询"></a>11、ES如何实现自动补全查询</h2><p>1、修改索引库结构，设置自定义拼音分词器<br>        2、修改索引库的需要补全的属性，使用自定义分词器<br>        3、索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器<br>        4、给实体类doc添加suggestion字段<br>        5、重新导入数据到索引库</p>
<h2 id="12、如何自定义分词器？"><a href="#12、如何自定义分词器？" class="headerlink" title="12、如何自定义分词器？"></a>12、如何自定义分词器？</h2><p>1、创建索引库时，在settings中配置，可以包含三部分<br>        2、character filter：<br>            在tokenizer之前对文本进行处理。例如删除字符、替换字符<br>        3、tokenizer：<br>            将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart<br>        4、filter：<br>            将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</p>
<h2 id="13、如何实现es与mysql的数据同步？"><a href="#13、如何实现es与mysql的数据同步？" class="headerlink" title="13、如何实现es与mysql的数据同步？"></a>13、如何实现es与mysql的数据同步？</h2><p>1、同步调用：<br>            1、ES微服务对外提供接口，用来修改elasticsearch中的数据<br>            2、操作数据库微服务在完成数据库操作后，直接调用微服务提供的接口，<br>        2、异步通知：<br>            1、操作数据库微服务对mysql数据库数据完成增、删、改后，发送MQ消息<br>            2、ES微服务监听MQ，接收到消息后完成elasticsearch数据修改<br>        3、监听binlog<br>            1、给mysql开启binlog功能<br>            2、mysql完成增、删、改操作都会记录在binlog中<br>            3、ES微服务基于canal监听binlog变化，实时更新elasticsearch中的内容</p>
<h2 id="14、es集群节点有哪些类型？分别的职责是什么？"><a href="#14、es集群节点有哪些类型？分别的职责是什么？" class="headerlink" title="14、es集群节点有哪些类型？分别的职责是什么？"></a>14、es集群节点有哪些类型？分别的职责是什么？</h2><p>1、备选主节点（master eligible）：<br>            主节点可以管理和记录集群状态、决定分片在哪个节点、处理创建和删除索引库的请求<br>        2、数据节点（data）：<br>            存储数据、搜查、聚合、CRUD<br>        3、ingest：<br>            数据存储之前的预处理<br>        4、coordinating：<br>            路由请求到其他节点，合并其他节点处理的结果，返回给用户</p>
<h2 id="15、什么是es脑裂问题？"><a href="#15、什么是es脑裂问题？" class="headerlink" title="15、什么是es脑裂问题？"></a>15、什么是es脑裂问题？</h2><p>1、一个集群中，主节点与其它节点失联<br>        2、此时，node2和node3认为node1宕机，就会重新选主<br>        3、当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异<br>        4、当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况</p>
<h1 id="十一、压测、高并发性能优化"><a href="#十一、压测、高并发性能优化" class="headerlink" title="十一、压测、高并发性能优化"></a>十一、压测、高并发性能优化</h1><p>1、jemiter压测工具使用<br>    2、多级缓存（nginx共享字典、redis缓存、tomcat进程缓存）<br>    3、数据库主从读写分离（mycat）<br>    4、发布：<br>        开发环境、测试环境用的shell脚本自动发布（包括从git上拉取代码、打包编译、启动）<br>        预上线、线上环境用的jenkins持续集成<br>    5、提交代码之前需要做什么？</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> Java面试题库</li>
        <li><strong>作者:</strong> 小颜同学</li>
        <li><strong>创建于:</strong> 2023-05-28 11:05:48</li>
        
            <li>
                <strong>更新于:</strong> 2023-05-28 15:34:33
            </li>
        
        <li>
            <strong>链接:</strong> https://www.wy-studio.cn/2023/05/28/Java面试题库/
        </li>
        <li>
            <strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/Java/">#Java</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/07/18/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E5%BE%88%E7%81%AB%E7%9A%84ChatGPT%E8%A7%A3%E8%AF%BB/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">关于最近很火的ChatGPT解读</span>
                                    <span class="post-nav-item">上一篇</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/05/22/Typora-PicGo-%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">Typora+PicGo+阿里云OSS搭建博客图床</span>
                                    <span class="post-nav-item">下一篇</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
                <div class="comment-container">
                    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;评论
    </div>
    

        
            
 
    <div id="waline"></div>
    <script type="module"  data-pjax>
        import { init } from 'https://evan.beee.top/js/waline.mjs';

        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://example.example.com',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
            });
        }

        if ('true') {
            const loadWalineTimeout = setTimeout(() => {
                loadWaline();
                clearTimeout(loadWalineTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadWaline);
        }
        
    </script>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">Java面试题库</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%EF%BC%8C%E5%9F%BA%E7%A1%80"><span class="nav-text">一，基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Java%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%88%86%E5%88%AB%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9F%E5%A4%9A%E5%B0%91%E4%BD%8D%EF%BC%9F%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">1、Java都有哪些数据类型？基本数据类型有哪些？分别占多少字节？多少位？引用数据类型又有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Java%E8%AF%AD%E8%A8%80%E7%9A%84%E5%87%A0%E5%A4%A7%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F-%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-text">2、Java语言的几大特性是什么？分别怎么理解？(封装、继承、多态的好处)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Java%E7%9A%84%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%83%BD%E8%83%BD%E5%8A%A0%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="nav-text">3、Java的权限修饰符有哪些？都能加在哪些地方？分别代表什么意义？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E8%BD%BD%EF%BC%9F"><span class="nav-text">4、什么是重写？什么是重载？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81final%E5%85%B3%E9%94%AE%E5%AD%97%E8%83%BD%E5%8A%A0%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">5、final关键字能加在哪些地方？分别代表什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E8%83%BD%E5%8A%A0%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">6、static关键字能加在哪些地方？分别代表什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%88%90%E5%91%98%EF%BC%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%91%A2%EF%BC%9F%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E6%B3%A8%E6%84%8FJDK1-8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%87%BA%E7%8E%B0%E9%9D%9E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%EF%BC%9Adefault%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-text">7、接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？（注意JDK1.8接口中是可以出现非抽象方法的：default方法、静态方法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E6%A3%80%E6%9F%A5-%E7%BC%96%E8%AF%91-%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">8、Java异常体系是什么? 运行时异常和检查(编译)异常有什么区别？常见的运行时异常有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81-x3D-x3D-%E5%92%8C-equals%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="nav-text">9、&#x3D;&#x3D; 和 equals的异同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81-amp-%E4%B8%8E-amp-amp-%E3%80%81-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">10、&amp;与&amp;&amp;、|与||的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81String%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E6%9C%AC%E8%BA%AB%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">11、String可以修改本身吗？为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">12、StringBuffer和StringBuilder的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81valueOf%E5%92%8CtoString%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">13、valueOf和toString的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81%E5%A4%A7%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%A8-%E2%80%9C-%E2%80%9D-%E5%8F%B7%E8%BF%9B%E8%A1%8C%E6%8B%BC%E6%8E%A5%E6%95%88%E7%8E%87%E9%AB%98%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BA%94%E8%AF%A5%E7%94%A8%E4%BB%80%E4%B9%88%E6%9B%BF%E4%BB%A3%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">14、大量字符串用 “+” 号进行拼接效率高吗？为什么？应该用什么替代？为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="nav-text">15、创建一个类的实例都有哪些办法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16%E3%80%81Java%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%93%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">16、Java集合的体系是什么样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17%E3%80%81Set%E5%92%8CList%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9FSet%E5%8E%BB%E9%87%8D%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">17、Set和List分别有哪些特点？Set去重的原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18%E3%80%81ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">18、ArrayList底层原理是什么？扩容原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19%E3%80%81LinkedList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%92%8CArrayList%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">19、LinkedList底层原理是什么？和ArrayList的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20%E3%80%81HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">20、HashMap的底层原理是什么？扩容原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21%E3%80%81concurrentHashMap%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">21、concurrentHashMap原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22%E3%80%81JDK8%E5%AF%B9%E4%BA%8EHashMap%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">22、JDK8对于HashMap做了哪些优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFsocket%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFIO-x2F-NIO-x2F-BIO-x2F-AIO%EF%BC%9F%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">23、什么是socket？什么是IO&#x2F;NIO&#x2F;BIO&#x2F;AIO？区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%EF%BC%9F%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9A%B4%E5%8A%9B%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="nav-text">24、什么是反射？可以用来干嘛？列举一下反射应用场景？什么是暴力反射？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25%E3%80%81%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E6%8E%92%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">25、算法了解过吗？冒泡排序、选择排序、快排原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26%E3%80%81JDK1-8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B-lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81stream%E6%B5%81%E3%80%81%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%AD%89%E7%AD%89"><span class="nav-text">26、JDK1.8的新特性有哪些?(lamda表达式、stream流、函数式接口、接口中默认方法、方法引用等等)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27%E3%80%81IO%E6%B5%81%E4%BD%93%E7%B3%BB"><span class="nav-text">27、IO流体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E%EF%BC%9F"><span class="nav-text">28、如何实现分布式主键自增？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81JVM"><span class="nav-text">二、JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81JDK%E5%92%8CJRE%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1、JDK和JRE的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">2、JVM内存模型是什么样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81JVM%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88JVM%E8%BF%99%E4%B9%88%E5%81%9A%EF%BC%9F%E6%9C%89%E8%BF%9D%E5%8F%8D%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%9A%84%E4%BE%8B%E5%AD%90%E5%90%97%EF%BC%9F"><span class="nav-text">3、JVM双亲委派加载机制，为什么JVM这么做？有违反双亲委派的例子吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%AF%8F%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B"><span class="nav-text">4、类的加载流程是什么样的，每个阶段解释一下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81JVM%E7%9A%84GC%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%90%84%E8%87%AA%E7%9A%84GC%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">5、JVM的GC的主要区域以及各自的GC机制是什么样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81JVM%E7%9A%84GC%E7%AE%97%E6%B3%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">6、JVM的GC算法都有哪些？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Spring-amp-SpringBoot"><span class="nav-text">三、Spring &amp; SpringBoot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E8%AF%B4%E4%B8%8B%E5%AF%B9SpringIOC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%9FIOC%E5%AE%B9%E5%99%A8%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="nav-text">1、说下对SpringIOC的理解，怎么理解控制反转？IOC容器中Bean的生命周期？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3IOC%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">2、Spring如何解决IOC中的循环依赖问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E8%AF%B4%E4%B8%8B%E5%AF%B9SpringAOP%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%9A%E7%9F%A5%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%9A%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%89"><span class="nav-text">3、说下对SpringAOP的理解、有哪些通知？使用场景有哪些？（底层原理：两种动态代理）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E8%AF%B4%E4%B8%8BSpringMvc%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%8E%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AAURL%E5%88%B0%E5%BE%97%E5%88%B0%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9ADispatcherServlet%E7%9A%84%E8%81%8C%E8%B4%A3%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="nav-text">4、说下SpringMvc的流程（从访问一个URL到得到页面结果的具体流程：DispatcherServlet的职责流程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%AF%B9Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9FSpring%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9FSpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%9F"><span class="nav-text">5、对Spring声明式事务的理解？Spring的事务隔离级别？Spring事务传播行为？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%AE%A9spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="nav-text">6、什么情况下会让spring事务失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81Spring%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%EF%BC%9F%E5%88%86%E5%88%AB%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">7、Spring有哪些核心注解？分别的作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81Spring%E5%92%8CSpringBoot%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-text">8、Spring和SpringBoot的关系？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">9、SpringBoot的自动装配原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81SpringBoot%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%8B"><span class="nav-text">10、SpringBoot的核心注解是哪个？详细说下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%A4%A7%E6%A6%82%E8%AF%B4%E4%B8%8B"><span class="nav-text">11、SpringBoot项目的启动加载流程大概说下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="nav-text">12、SpringBoot项目读取配置文件的方式有几种？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89SpringBoot-starter%EF%BC%9F"><span class="nav-text">13、如何自定义SpringBoot starter？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Mysql-amp-Mybatis%EF%BC%9F"><span class="nav-text">四、Mysql &amp; Mybatis？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-text">1、什么是索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E8%BF%99%E7%A7%8D%E7%BB%93%E6%9E%84%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%A3%81%E7%9B%98IO%E6%95%88%E7%8E%87%EF%BC%89"><span class="nav-text">2、Mysql的数据结构是什么（mysql索引的数据结构）？为什么用这种结构？（如何提高磁盘IO效率）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Mysql%E7%9A%84%E6%95%B0%E6%8D%AEIO%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">3、Mysql的数据IO查找流程是什么样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81B-tree%E5%92%8CBtree%E7%94%B1%E4%BB%80%E4%B9%88%E7%BB%84%E6%88%90%EF%BC%9F%E4%BB%96%E4%BB%AC%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="nav-text">4、B+tree和Btree由什么组成？他们的异同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81Mysql%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%88InnoDB%E5%92%8CMysiam%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E8%BF%99%E4%B8%A4%E7%A7%8D%E5%BC%95%E6%93%8EB-tree%E7%9A%84%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E5%92%8C%E9%9D%9E%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E5%88%86%E5%88%AB%E5%AD%98%E5%82%A8%E7%9A%84%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">5、Mysql两种存储引擎（InnoDB和Mysiam）的区别？这两种引擎B+tree的叶子结点和非叶子结点分别存储的什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81Mysql%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-text">6、Mysql索引有哪些类型？什么场景使用哪种索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CMysql%E4%BC%98%E5%8C%96%EF%BC%9F%EF%BC%88sql%E4%BC%98%E5%8C%96%E5%B1%82%E9%9D%A2%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E5%B1%82%E9%9D%A2%EF%BC%89"><span class="nav-text">7、如何进行Mysql优化？（sql优化层面和服务器优化层面）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81Sql%E8%B0%83%E4%BC%98%E4%BD%A0%E4%BC%9A%E4%BB%8E%E4%BD%95%E5%85%A5%E6%89%8B%EF%BC%88%E6%8E%AA%E6%96%BD%EF%BC%89%EF%BC%9F"><span class="nav-text">8、Sql调优你会从何入手（措施）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81Mysql%E4%B8%AD%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%9A%E4%BD%BF%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-text">9、Mysql中如何合理使用索引？有哪些会使索引失效的情况？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81Mysql%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%85%A2%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%93%AA%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89%EF%BC%9F%E5%88%86%E5%88%AB%E4%BC%9A%E5%88%97%E5%87%BA%E6%9D%A5%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF%E9%A1%B9%EF%BC%9F"><span class="nav-text">10、Mysql如何排查慢查询（哪个关键字）？分别会列出来哪些信息项？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FMysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%88%86%E5%88%AB%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9FMysql%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FOracle%E5%91%A2%EF%BC%9F"><span class="nav-text">11、事务的特性是什么？Mysql事务隔离级别有哪几种？分别会产生什么问题？Mysql默认隔离级别是什么？Oracle呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81Mysql%E7%9A%84%E8%A1%8C%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%9F"><span class="nav-text">12、Mysql的行锁、表锁，悲观锁、乐观锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81Mysql%E7%9A%84vachar%E5%92%8Cchar%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">13、Mysql的vachar和char的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%BF%9E%E6%8E%A5-inner-join-%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%88left-join%EF%BC%89%EF%BC%9F"><span class="nav-text">14、什么是内连接(inner join)、外连接（left join）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81%E5%B9%B3%E6%97%B6Mysql%E7%9A%84sql%E7%BB%83%E4%B9%A0%E8%A6%81%E7%BB%83%E5%88%B0%E4%BD%8D%EF%BC%81%EF%BC%81"><span class="nav-text">15、平时Mysql的sql练习要练到位！！</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16%E3%80%81Mybatis%E5%BA%95%E5%B1%82%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">16、Mybatis底层的原理？一级缓存和二级缓存是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17%E3%80%81mybatis-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">17、mybatis #{}和${}的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18%E3%80%81Mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E3%80%81%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E5%88%86%E5%88%AB%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F%E5%88%9B%E5%BB%BA%E8%AF%AD%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">18、Mysql存储过程、存储函数、触发器分别用来干嘛的？创建语法是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19%E3%80%81union%E5%92%8CunionAll%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">19、union和unionAll有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20%E3%80%81%E5%88%9B%E5%BB%BA%E8%A1%A8%E3%80%81%E5%88%A0%E9%99%A4%E8%A1%A8%E3%80%81%E6%9B%B4%E6%96%B0%E8%A1%A8%E5%AD%97%E6%AE%B5%E8%AF%AD%E5%8F%A5%EF%BC%9F"><span class="nav-text">20、创建表、删除表、更新表字段语句？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21%E3%80%81mysql%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%86%99%E6%B3%95%EF%BC%9F"><span class="nav-text">21、mysql左外连接语句的写法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22%E3%80%81%E5%90%AC%E8%BF%87InnoDB%E7%9A%84Mvcc%E6%8A%80%E6%9C%AF%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">22、听过InnoDB的Mvcc技术吗？说下是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23%E3%80%81Java%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">23、Java实现动态代理有哪些方式？区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">五、多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%9B%B8%E6%AF%94%E7%BB%A7%E6%89%BFThread%E7%B1%BB%EF%BC%8C%E5%AE%9E%E7%8E%B0Runable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">2、线程的状态有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81run-%E5%92%8Cstart-%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">3、run()和start()方法有哪些区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">4、实现线程间通讯的方法有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81wait%E3%80%81notify%E3%80%81notifyAll%E5%88%86%E5%88%AB%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B9%8B%E5%A4%96%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81Sleep%E5%92%8CWait%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">6、Sleep和Wait的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%BA%A7%E7%94%9F%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">7、什么是线程安全问题？什么情况下会产生？如何解决？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-text">8、什么是死锁？如何防止产生死锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81Synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">9、Synchronized关键字的底层原理是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81Synchronized%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F%E5%88%86%E5%88%AB%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">10、Synchronized可以用在哪些地方？分别的锁对象是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81Synchronized%E5%92%8CJUC%E4%B8%8BLock%E9%94%81%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="nav-text">11、Synchronized和JUC下Lock锁的异同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81Synchronized%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%E8%BF%98%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E9%94%81%E6%97%B6%E4%BC%9A%E9%98%BB%E5%A1%9E%E5%90%97%EF%BC%9F"><span class="nav-text">12、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81Synchronized%E5%9C%A8JDK1-6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">13、Synchronized在JDK1.6做了什么优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%AE%8Cwait-x2F-notify-x2F-notifyAll%E5%90%8E%E4%BC%9A%E7%AB%8B%E9%A9%AC%E9%87%8A%E6%94%BE%E9%94%81%E5%90%97%EF%BC%9F"><span class="nav-text">13、同步代码块中执行完wait&#x2F;notify&#x2F;notifyAll后会立马释放锁吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81Lock%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%88%86%E5%88%AB%E7%9A%84%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">14、Lock锁有哪些实现？分别的特点是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81JUC%E4%B8%8BLock%E7%9A%84%E7%9B%91%E8%A7%86%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%93%AA%E4%B8%AA%E7%B1%BB%EF%BC%9F%E4%B8%8ESynchronized%E7%9A%84%E7%9B%91%E8%A7%86%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="nav-text">15、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%8F%AF%E9%87%8D%E5%85%A5%EF%BC%9FSynchronized%E5%85%B7%E5%A4%87%E5%90%97%EF%BC%9FLock%E5%91%A2%EF%BC%9F"><span class="nav-text">16、什么是线程可重入？Synchronized具备吗？Lock呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F"><span class="nav-text">17、什么是AQS？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFCAS%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFCAS%E7%9A%84ABA%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">18、什么是CAS？什么是CAS的ABA问题？如何解决？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19%E3%80%81%E4%BD%A0%E4%BA%86%E8%A7%A3JUC%E4%B8%8B%E7%9A%84%E5%93%AA%E4%BA%9B%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%8C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88CountdownLatch%E3%80%81Cyclicbarrier%E3%80%81Simephore%EF%BC%89"><span class="nav-text">19、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Simephore）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20%E3%80%81%E8%AF%B4%E4%B8%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">20、说下volatile关键字，有什么作用？原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21%E3%80%81%E8%AF%B4%E4%B8%8BThreadLocal%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">21、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22%E3%80%81%E8%AF%B4%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%9F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E6%9C%89%E5%87%A0%E7%A7%8D%E9%BB%98%E8%AE%A4%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E4%BB%96%E4%BB%AC%E7%9A%847%E4%B8%AA%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%82%A3%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="nav-text">22、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%86%99%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%EF%BC%88%E6%87%92%E6%B1%89%E5%92%8C%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%89%E9%82%A3%E4%B9%88%E6%87%92%E6%B1%89%E5%BC%8F%E4%B8%AD%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%86%99%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">23、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81Redis-amp-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-text">六、Redis &amp; 多级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Redis%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="nav-text">1、Redis是一个什么样的数据库？读写速度怎么样？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F%E5%9C%A8%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%AF%B7%E5%88%97%E4%B8%BE"><span class="nav-text">2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">3、Redis的持久化机制是什么样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81Redis%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">4、Redis主从结构能解决什么问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">5、Redis主从同步具体流程是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%95%88%E7%8E%87%EF%BC%9F"><span class="nav-text">6、如何优化主从同步效率？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81Redis%E7%9A%84%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E4%BE%9D%E9%9D%A0%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B7%A5%E4%BD%9C%E8%8C%83%E5%9B%B4%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F%E5%88%86%E5%88%AB%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD%EF%BC%9F"><span class="nav-text">8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%BB%E5%86%99%E6%95%88%E7%8E%87%E8%BF%98%E9%82%A3%E4%B9%88%E9%AB%98%EF%BC%9F"><span class="nav-text">9、Redis是单线程的，为什么读写效率还那么高？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81Redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F%EF%BC%88%E5%85%B8%E5%9E%8B%E7%9A%84NIO%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO%EF%BC%89"><span class="nav-text">10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81Redis%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">11、Redis过期数据的删除策略是什么？有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">12、Redis的数据淘汰策略是什么？有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81Redis%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="nav-text">13、Redis的慢查询如何排查？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8Redis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%94%81%EF%BC%9F%EF%BC%88Zookeeper%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%89"><span class="nav-text">14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81Redis%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F"><span class="nav-text">15、Redis的双写一致性如何保证？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16%E3%80%81%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%8A%A0%E5%88%86%E9%A1%B9%EF%BC%89"><span class="nav-text">16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17%E3%80%81Redis%E7%9A%84hash%E6%A7%BD%E4%B8%80%E5%85%B1%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%EF%BC%9F%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%85%A5%E6%A7%BD%E7%9A%84%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="nav-text">17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81Rabbitmq"><span class="nav-text">七、Rabbitmq</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81Rabbitmq%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BD%A0%E4%BB%AC%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F%EF%BC%885%E7%A7%8D%EF%BC%89"><span class="nav-text">1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81Rabbitmq%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81mq%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F%EF%BC%883%E5%A4%A7%E6%96%B9%E9%9D%A2%EF%BC%89"><span class="nav-text">2、Rabbitmq如何保证mq消息可靠性？（3大方面）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81Rabbitmq%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F%EF%BC%882%E7%A7%8D%EF%BC%89"><span class="nav-text">3、Rabbitmq如何实现延时消息？（2种）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%9A%E8%BF%9B%E5%85%A5%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-text">4、什么是死信队列？什么样的消息会进入死信队列？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81Rabbitmq%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%883%E7%A7%8D%E6%80%9D%E8%B7%AF%EF%BC%89"><span class="nav-text">5、Rabbitmq如何解决消息堆积问题？（3种思路）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%9F%EF%BC%88%E4%BB%8E%E4%B8%9A%E5%8A%A1%E5%B1%82%E9%9D%A2%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD%EF%BC%89"><span class="nav-text">6、如何保证消息的幂等性？（从业务层面进行判断）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="nav-text">八、微服务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5%E9%97%AE%E9%A2%98"><span class="nav-text">1、概念问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="nav-text">2、远程调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-text">3、注册中心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="nav-text">3、配置中心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4"><span class="nav-text">4、服务保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E7%BD%91%E5%85%B3"><span class="nav-text">5、网关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">6、分布式事务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81Docker"><span class="nav-text">九、Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFDocker%EF%BC%9F%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="nav-text">1、什么是Docker？优点是什么？有哪些核心概念？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">2、镜像操作命令有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">3、容器操作命令有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">4、数据卷操作命令有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81docker%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F%EF%BC%9Fdocker-file%E7%9A%84%E8%AF%AD%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">5、docker如何自定义镜像？docker file的语法是什么样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81docker-compose%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84-%E8%AF%AD%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">6、docker compose是干嘛的?语法是什么样的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81ElasticSearch"><span class="nav-text">十、ElasticSearch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFES%EF%BC%9F%E7%94%B1%E4%BB%80%E4%B9%88%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%EF%BC%9F%E5%92%8CLunce%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFELK%EF%BC%9F"><span class="nav-text">1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81ES%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3%EF%BC%9F%E6%96%87%E6%A1%A3%E6%A0%BC%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%98%A0%E5%B0%84%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFDSL%EF%BC%9F"><span class="nav-text">2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%EF%BC%9F%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">3、什么是倒排索引？倒排索引建立过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81ES%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9Fkeyword%E5%92%8Ctext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">4、ES有哪些数据类型？keyword和text有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E9%87%8D%E8%A6%81%EF%BC%9A%E8%AF%B4%E8%AF%B4%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E6%A1%86%E8%BE%93%E5%85%A5%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6-%E8%BF%9B%E8%A1%8CES%E6%90%9C%E7%B4%A2%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-text">5、重要：说说用户输入框输入查询条件 进行ES搜索的底层原理过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81ES%E5%88%86%E8%AF%8D%E5%99%A8%E9%80%82%E5%90%88%E5%9C%A8%E4%BB%80%E4%B9%88%E5%AD%97%E6%AE%B5%E4%B8%8A%E4%BD%BF%E7%94%A8%EF%BC%9F%E5%88%86%E8%AF%8D%E5%99%A8%E5%9C%A8ES%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%88%E5%BB%BA%E7%AB%8B%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%97%B6%E5%AF%B9%E6%96%87%E6%A1%A3%E5%88%86%E8%AF%8D%E5%92%8C%E7%94%A8%E6%88%B7%E6%90%9C%E7%B4%A2%E6%97%B6%E5%AF%B9%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E5%88%86%E8%AF%8D%EF%BC%89"><span class="nav-text">6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81%E4%BD%A0%E4%BB%AC%E5%88%86%E8%AF%8D%E5%99%A8%E7%94%A8%E7%9A%84%E5%93%AA%E7%A7%8D%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%BC%E9%9F%B3%E5%88%86%E8%AF%8D%E5%99%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%90%9C%E7%B4%A2%E6%97%B6%E4%B8%8D%E8%83%BD%E7%94%A8%E6%8B%BC%E9%9F%B3%E5%88%86%E8%AF%8D%E5%99%A8%EF%BC%9F"><span class="nav-text">7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81ES%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2%EF%BC%9F%E8%A6%81%E7%BB%99%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%88%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81%E7%BB%99%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%88%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E4%BA%AE%EF%BC%9F"><span class="nav-text">9、给指定的数据进行加分如何实现？如何实现高亮？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81ES%E6%9C%89%E5%93%AA%E4%BA%9B%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="nav-text">10、ES有哪些聚合查询？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81ES%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%9F%A5%E8%AF%A2"><span class="nav-text">11、ES如何实现自动补全查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E8%AF%8D%E5%99%A8%EF%BC%9F"><span class="nav-text">12、如何自定义分词器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0es%E4%B8%8Emysql%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="nav-text">13、如何实现es与mysql的数据同步？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81es%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%88%86%E5%88%AB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">14、es集群节点有哪些类型？分别的职责是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFes%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">15、什么是es脑裂问题？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%8E%8B%E6%B5%8B%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">十一、压测、高并发性能优化</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">小颜同学</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br>
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.2.0</a>
        </div>
        
            <div class="icp-info info-item"><a target="_blank" rel="nofollow" href="
                
                    https://beian.miit.gov.cn/
                
                ">湘ICP备2022018939号</a></div>
        
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <div class="customize-info info-item">祝你看的开心，玩的愉快！</div>
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>



    
<script src="/js/tools/localSearch.js"></script>




    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>






    
<script src="/js/libs/minimasonry.min.js"></script>

    
<script src="/js/plugins/masonry.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/tools/tocToggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
